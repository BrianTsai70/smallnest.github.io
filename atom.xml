<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[鸟窝]]></title>
  <subtitle><![CDATA[大道至简 Simplicity is the ultimate form of sophistication]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://colobu.com/"/>
  <updated>2016-07-04T07:31:21.684Z</updated>
  <id>http://colobu.com/</id>
  
  <author>
    <name><![CDATA[smallnest]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[深入Go语言 - 11]]></title>
    <link href="http://colobu.com/2016/07/04/dive-into-go-11/"/>
    <id>http://colobu.com/2016/07/04/dive-into-go-11/</id>
    <published>2016-07-03T22:12:42.000Z</published>
    <updated>2016-07-04T07:30:58.000Z</updated>
    <content type="html"><![CDATA[<p>本章重点介绍Go程序的调试和性能监控。</p>
<a id="more"></a>
<h3 id="GDB">GDB</h3>
<p>当你在Linux、macOS、FreeBSD、NetBSD环境中使用gc工具链编译和链接你的程序的时候，生成的二进制文件中包含 DWARFv3调试信息, 最新的GDB(&gt;7.1)可以用它们来调试程序。</p>
<p>gc工具链的名字来自Go前端编译器(compiler frontend), <code>cmd/gc</code>,以区分<code>gccgo</code>工具链。当人们谈论Go编译器的时候，通常所指就是gc工具链。</p>
<p>gc工具链包含一个Go编译器、一个C编译器、一个汇编工具和一个链接工具，所有这些工具都可以在<code>src\cmd</code>文件夹下找到，比如<code>5g</code>、<code>6g</code>、｀8g｀、<code>5c</code>、<code>6c</code>、<code>8c</code>、<code>5a</code>、<code>6a</code>、<code>8a</code>、<code>5l</code>、<code>6l</code>、<code>8l</code>等。</p>
<p>自Go 1.5 gc工具链改变了，从C的实现改变成Go的实现，所以你在Go1.5以上的版本中找不到这些工具，而是由统一的compile、link工具所取代。 你编译的时候可以看到工具链是如何工作的：</p>
<pre class="highlight">
smallnestMBP:ch10 smallnest$ go build  -x -gcflags "-N -l" pi.go
WORK=/var/folders/lv/5kl1rvvj2jsfqxyw_1_pvw380000gn/T/go-build974068189
mkdir -p $WORK/command-line-arguments/_obj/
mkdir -p $WORK/command-line-arguments/_obj/exe/
cd /Users/smallnest/go/src/github.com/smallnest/dive-into-go/ch10
/usr/local/go/pkg/tool/darwin_amd64/compile -o $WORK/command-line-arguments.a -trimpath $WORK -N -l -p main -complete -buildid ab0109c737108c5646adfbf53bff79b7a49b96d4 -D _/Users/smallnest/go/src/github.com/smallnest/dive-into-go/ch10 -I $WORK -pack ./pi.go
cd .
/usr/local/go/pkg/tool/darwin_amd64/link -o $WORK/command-line-arguments/_obj/exe/a.out -L $WORK -extld=clang -buildmode=exe -buildid=ab0109c737108c5646adfbf53bff79b7a49b96d4 $WORK/command-line-arguments.a
mv $WORK/command-line-arguments/_obj/exe/a.out pi
</pre>

<blockquote>
<p>The suites of programs that were the compilers (6g, 8g, etc.), the assemblers (6a, 8a, etc.), and the linkers (6l, 8l, etc.) have each been consolidated into a single tool that is configured by the environment variables GOOS and GOARCH. The old names are gone; the new tools are available through the go tool mechanism as go tool compile, go tool asm, and go tool link. Also, the file suffixes .6, .8, etc. for the intermediate object files are also gone; now they are just plain .o files.</p>
<p>For example, to build and link a program on amd64 for Darwin using the tools directly, rather than through go build, one would run:</p>
<pre class="highlight">
$ export GOOS=darwin GOARCH=amd64
$ go tool compile program.go
$ go tool link program.o
</pre>

<p>摘自 <a href="https://golang.org/doc/go1.5#rename" target="_blank" rel="external">https://golang.org/doc/go1.5#rename</a></p>
</blockquote>
<p><code>-w</code>参数会告诉连接器忽略这些调试信息(<code>go build -ldflags &quot;-w&quot; example.go</code>)。</p>
<p>gc编译器可能会做优化，比如inline函数，这会让gdb调试更加困难。如果不想让编译器做这些优化可以指定参数<code>-gcflags &quot;-N -l&quot;</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> build  -gcflags <span class="string">"-N -l"</span> pi.<span class="keyword">go</span></div></pre></td></tr></table></figure>

<p>GDB具体的执行命令你可以搜索相关的文档，网络上有居多的文章介绍。</p>
<p>以<a href="https://golang.org/doc/play/pi.go" target="_blank" rel="external">计算圆周率 Pi 的代码为例</a>，在<code>macOS</code>中你需要执行 <code>sudo gdb pi</code>,然后进入GDB的控制台。</p>
<p><code>list</code>可以显示源代码。</p>
<p><code>break</code>加断点，比如<code>break 16</code>。</p>
<p><code>bt</code> 、<code>frame n</code>可以显示调用栈信息。</p>
<p><code>info</code>显示变量的信息：</p>
<pre class="highlight">
(gdb) next
17            go term(ch, float64(k))
(gdb) info args
n = 5000
~r1 = 0
(gdb) info locals
k = 0
k = 16
f = 4.3922040662770145e-318
ch = 0xc820066000
(gdb) p ch
$1 = (chan float64) 0xc820066000
</pre>

<p>基本上，如果你熟悉gdb工具，可以轻松地进行调试，还可以使用<a href="https://golang.org/src/runtime/runtime-gdb.py" target="_blank" rel="external">扩展脚本</a>对复杂类型进行检查。</p>
<p>参考</p>
<ul>
<li><a href="https://golang.org/doc/gdb" target="_blank" rel="external">https://golang.org/doc/gdb</a></li>
<li><a href="https://astaxie.gitbooks.io/build-web-application-with-golang/content/en/11.2.html" target="_blank" rel="external">https://astaxie.gitbooks.io/build-web-application-with-golang/content/en/11.2.html</a></li>
<li><a href="https://lincolnloop.com/blog/introduction-go-debugging-gdb/" target="_blank" rel="external">https://lincolnloop.com/blog/introduction-go-debugging-gdb/</a></li>
<li><a href="https://blog.codeship.com/using-gdb-debugger-with-go/" target="_blank" rel="external">https://blog.codeship.com/using-gdb-debugger-with-go/</a></li>
<li><a href="http://dave.cheney.net/2013/10/15/how-does-the-go-build-command-work" target="_blank" rel="external">http://dave.cheney.net/2013/10/15/how-does-the-go-build-command-work</a></li>
<li><a href="https://github.com/golang/go/wiki/GcToolchainTricks" target="_blank" rel="external">https://github.com/golang/go/wiki/GcToolchainTricks</a></li>
<li><a href="https://github.com/golang/go/wiki/GcToolchainTricks" target="_blank" rel="external">https://github.com/golang/go/wiki/GcToolchainTricks</a></li>
</ul>
<h3 id="delve及IDE集成调试">delve及IDE集成调试</h3>
<p>虽然gdb工具很强大，但是这种基于命令行的调试方式确实不方便，而且它也不是专门为Go语言提供的调试工具，尤其对于并发程序的调试。</p>
<p>但是G官方一直没有提供一个Go调试器。</p>
<p>幸运地是，有人提供了专门针对 Go语言的调试器：<br><img src="https://raw.githubusercontent.com/derekparker/delve/master/assets/delve_horizontal.png" alt=""></p>
<p>网址： <a href="https://github.com/derekparker/delve" target="_blank" rel="external">https://github.com/derekparker/delve</a></p>
<p>虽然当前delve的版本还是pre 1.0，但是已经提供了很好的Go调试的功能，并且可以很好的Intellj、Atom、Vscode等Go IDE工具集成。</p>
<p>当然你可以用命令行的方式调试,它有多种方式启动<code>dlv</code>： <code>dlv attach</code>、<code>dlv debug</code>、<code>dlv exec</code>、<code>dlv test</code>、<code>dlv trace</code>等，用来调试一个进程或者程序等。我们用<code>dlv exec ./pi</code>调试刚才编译好的程序。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(dlv) b pi.go:<span class="number">16</span> <span class="comment">#在 pi.go 的第 16 行设置断点。</span></div><div class="line">(dlv) bp   <span class="comment">#查看当前所有断点</span></div><div class="line">(dlv) c    <span class="comment">#运行到下一个断点或者程序结尾</span></div><div class="line">(dlv) n    <span class="comment">#单步执行代码</span></div><div class="line">(dlv) p ch  <span class="comment">#打印变量 ch 的值</span></div><div class="line">(dlv) goroutines  <span class="comment">#打印所有的goroutine</span></div><div class="line">(dlv) goroutine  <span class="comment">#打印当前的或者指定的goroutine信息</span></div></pre></td></tr></table></figure>

<p>它的信息要比gdb的详细，更适合Go程序的调试。</p>
<p>以下IDE工具可以集成delve。</p>
<ul>
<li><a href="https://github.com/go-lang-plugin-org/go-lang-idea-plugin" target="_blank" rel="external">Golang Plugin for IntelliJ IDEA</a></li>
<li><a href="https://github.com/Microsoft/vscode-go" target="_blank" rel="external">Go for Visual Studio Code</a></li>
<li><a href="https://github.com/benma/go-dlv.el/" target="_blank" rel="external">Emacs plugin</a></li>
<li><a href="https://github.com/visualfc/liteide" target="_blank" rel="external">LiteIDE</a></li>
<li><a href="https://github.com/lloiser/go-debug" target="_blank" rel="external">Go Debugger for Atom</a></li>
</ul>
<p>关于vscode IDE,你可以参考: <a href="http://colobu.com/2016/04/21/use-vscode-to-develop-go-programs/" target="_blank" rel="external">使用visual studio code开发Go程序
</a>。</p>
<p><img src="http://colobu.com/2016/04/21/use-vscode-to-develop-go-programs/vscode.png" alt=""></p>
<p>参考</p>
<ul>
<li><a href="https://github.com/derekparker/delve" target="_blank" rel="external">https://github.com/derekparker/delve</a></li>
<li><a href="https://github.com/derekparker/delve/tree/master/Documentation" target="_blank" rel="external">https://github.com/derekparker/delve/tree/master/Documentation</a></li>
<li><a href="https://blog.gopheracademy.com/advent-2015/debugging-with-delve/" target="_blank" rel="external">https://blog.gopheracademy.com/advent-2015/debugging-with-delve/</a></li>
<li><a href="http://blog.ralch.com/tutorial/golang-debug-with-delve/" target="_blank" rel="external">http://blog.ralch.com/tutorial/golang-debug-with-delve/</a></li>
<li><a href="https://github.com/joefitzgerald/go-plus" target="_blank" rel="external">https://github.com/joefitzgerald/go-plus</a></li>
<li><a href="https://atom.io/packages/go-debug" target="_blank" rel="external">https://atom.io/packages/go-debug</a></li>
<li><a href="https://code.visualstudio.com/" target="_blank" rel="external">https://code.visualstudio.com/</a></li>
<li><a href="https://www.reddit.com/r/golang/comments/3jyfvd/go_plugin_for_intellij_ides_now_has_delve/" target="_blank" rel="external">https://www.reddit.com/r/golang/comments/3jyfvd/go_plugin_for_intellij_ides_now_has_delve/</a></li>
<li><a href="https://github.com/go-lang-plugin-org/go-lang-idea-plugin" target="_blank" rel="external">https://github.com/go-lang-plugin-org/go-lang-idea-plugin</a></li>
<li><a href="https://github.com/DisposaBoy/GoSublime" target="_blank" rel="external">https://github.com/DisposaBoy/GoSublime</a></li>
<li><a href="https://github.com/fatih/vim-go" target="_blank" rel="external">https://github.com/fatih/vim-go</a></li>
<li><a href="https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins" target="_blank" rel="external">https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins</a></li>
</ul>
<h3 id="pprof">pprof</h3>
<p>Go官方库提供了两个类似的包pprof,分别为HTTP应用和通用应用提供了性能监控的功能。我们先看看 &quot;runtime/pprof&quot;包的使用，正好Go项目组有一个使用的例子，而且他们专门写了一篇文章介绍： <a href="https://blog.golang.org/profiling-go-programs" target="_blank" rel="external">profiling go programs</a>:</p>
<p>2011年的Scala Days会议上，Robert Hundt介绍了论文: <a href="http://research.google.com/pubs/pub37122.html" target="_blank" rel="external">Loop Recognition in C++/Java/Go/Scala</a>,这个文章中的Go程序运行的非常慢。</p>
<p>Go项目组正好利用Go profiling tool查找程序的瓶颈。他们选择了一个开发环境，测试C++和Go程序，发现C++程序用了17.8秒，内存使用700M,而Go称许用了25.2秒，内存占用1302M,所以他们尝试使用<code>go tool pprof</code>查找原因。</p>
<p>首先输入<code>runtime/pprof</code>,并使用两个参数<code>-cpuprofile</code>和<code>-memprofile</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> cpuprofile = flag.String(<span class="string">"cpuprofile"</span>, <span class="string">""</span>, <span class="string">"write cpu profile to file"</span>)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    flag.Parse()</div><div class="line">    <span class="keyword">if</span> *cpuprofile != <span class="string">""</span> {</div><div class="line">        f, err := os.Create(*cpuprofile)</div><div class="line">        <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">            log.Fatal(err)</div><div class="line">        }</div><div class="line">        pprof.StartCPUProfile(f)</div><div class="line">        <span class="keyword">defer</span> pprof.StopCPUProfile()</div><div class="line">    }</div><div class="line">    ...</div></pre></td></tr></table></figure>

<p>程序启动的时候启动<a href="https://golang.org/pkg/runtime/pprof/#StartCPUProfile），程序结束的时候记得一定要调用[StopCPUProfile](" target="_blank" rel="external">CPU性能监控</a><a href="http://golang.org/pkg/runtime/pprof/#StopCPUProfile，这样才能将缓存的监控数据写入都文件中。" target="_blank" rel="external">http://golang.org/pkg/runtime/pprof/#StopCPUProfile，这样才能将缓存的监控数据写入都文件中。</a></p>
<p>执行程序，执行完后用<code>go tool pprof</code>工具分析性能数据。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ make havlak1.prof</div><div class="line">./havlak1 -cpuprofile=havlak1.prof</div><div class="line"><span class="comment"># of loops: 76000 (including 1 artificial root node)</span></div><div class="line">$ go tool pprof havlak1 havlak1.prof</div><div class="line">Welcome to pprof!  For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">'help'</span>.</div><div class="line">(pprof)</div></pre></td></tr></table></figure>

<p><code>go tool pprof</code>是 <a href="https://code.google.com/p/gperftools/wiki/GooglePerformanceTools" target="_blank" rel="external">Google&#39;s pprof C++ profiler</a> 的变种。最重要的命令就是<code>topN</code>,它显示top N的采样结果:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(pprof) top10</div><div class="line">Total: <span class="number">2525</span> samples</div><div class="line">     <span class="number">298</span>  <span class="number">11.8</span>%  <span class="number">11.8</span>%      <span class="number">345</span>  <span class="number">13.7</span>% runtime.mapaccess1_fast64</div><div class="line">     <span class="number">268</span>  <span class="number">10.6</span>%  <span class="number">22.4</span>%     <span class="number">2124</span>  <span class="number">84.1</span>% main.FindLoops</div><div class="line">     <span class="number">251</span>   <span class="number">9.9</span>%  <span class="number">32.4</span>%      <span class="number">451</span>  <span class="number">17.9</span>% scanblock</div><div class="line">     <span class="number">178</span>   <span class="number">7.0</span>%  <span class="number">39.4</span>%      <span class="number">351</span>  <span class="number">13.9</span>% <span class="built_in">hash</span>_insert</div><div class="line">     <span class="number">131</span>   <span class="number">5.2</span>%  <span class="number">44.6</span>%      <span class="number">158</span>   <span class="number">6.3</span>% sweepspan</div><div class="line">     <span class="number">119</span>   <span class="number">4.7</span>%  <span class="number">49.3</span>%      <span class="number">350</span>  <span class="number">13.9</span>% main.DFS</div><div class="line">      <span class="number">96</span>   <span class="number">3.8</span>%  <span class="number">53.1</span>%       <span class="number">98</span>   <span class="number">3.9</span>% flushptrbuf</div><div class="line">      <span class="number">95</span>   <span class="number">3.8</span>%  <span class="number">56.9</span>%       <span class="number">95</span>   <span class="number">3.8</span>% runtime.aeshash64</div><div class="line">      <span class="number">95</span>   <span class="number">3.8</span>%  <span class="number">60.6</span>%      <span class="number">101</span>   <span class="number">4.0</span>% runtime.settype_flush</div><div class="line">      <span class="number">88</span>   <span class="number">3.5</span>%  <span class="number">64.1</span>%      <span class="number">988</span>  <span class="number">39.1</span>% runtime.mallocgc</div></pre></td></tr></table></figure>

<p>当监控的时候(profiling),Go程序每0.01秒采样一次，每次采样会记录当前执行的goroutine的程序计数器。上例中共2525次采样，所以它运行了大约25秒。 （注意go tool pprof执行的时候需要程序和采样数据，无果没有指定程序，则不会出现上面的结果）。如果程序执行太快，还没来得及采样，则无法分析其数据。</p>
<p>我们也可以分析一下上一节的Pi程序<code>go tool pprof pi pi.prof</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">smallnestMBP:ch10 smallnest$ go tool pprof pi pi.prof</div><div class="line">Entering interactive mode (<span class="built_in">type</span> <span class="string">"help"</span> <span class="keyword">for</span> commands)</div><div class="line">(pprof) top10</div><div class="line"><span class="number">64.75</span>s of <span class="number">73.30</span>s total (<span class="number">88.34</span>%)</div><div class="line">Dropped <span class="number">73</span> nodes (cum &lt;= <span class="number">0.37</span>s)</div><div class="line">Showing top <span class="number">10</span> nodes out of <span class="number">65</span> (cum &gt;= <span class="number">1.56</span>s)</div><div class="line">      flat  flat%   sum%        cum   cum%</div><div class="line">    <span class="number">21.66</span>s <span class="number">29.55</span>% <span class="number">29.55</span>%     <span class="number">21.66</span>s <span class="number">29.55</span>%  fmt.(*fmt).padString</div><div class="line">    <span class="number">10.45</span>s <span class="number">14.26</span>% <span class="number">43.81</span>%     <span class="number">10.45</span>s <span class="number">14.26</span>%  fmt.(*fmt).integer</div><div class="line">    <span class="number">10.26</span>s <span class="number">14.00</span>% <span class="number">57.80</span>%     <span class="number">10.28</span>s <span class="number">14.02</span>%  runtime.send</div><div class="line">     <span class="number">6.60</span>s  <span class="number">9.00</span>% <span class="number">66.81</span>%      <span class="number">6.60</span>s  <span class="number">9.00</span>%  fmt.(*fmt).pad</div><div class="line">     <span class="number">4.52</span>s  <span class="number">6.17</span>% <span class="number">72.97</span>%      <span class="number">4.77</span>s  <span class="number">6.51</span>%  runtime.stackfree</div><div class="line">     <span class="number">3.26</span>s  <span class="number">4.45</span>% <span class="number">77.42</span>%      <span class="number">3.26</span>s  <span class="number">4.45</span>%  fmt.(*fmt).fmt_boolean</div><div class="line">     <span class="number">2.86</span>s  <span class="number">3.90</span>% <span class="number">81.32</span>%     <span class="number">11.13</span>s <span class="number">15.18</span>%  type..hash.[<span class="number">1</span>]interface {}</div><div class="line">     <span class="number">2.06</span>s  <span class="number">2.81</span>% <span class="number">84.13</span>%      <span class="number">2.06</span>s  <span class="number">2.81</span>%  reflect.Kind.String</div><div class="line">     <span class="number">1.91</span>s  <span class="number">2.61</span>% <span class="number">86.74</span>%      <span class="number">2.18</span>s  <span class="number">2.97</span>%  runtime.SetFinalizer</div><div class="line">     <span class="number">1.17</span>s  <span class="number">1.60</span>% <span class="number">88.34</span>%      <span class="number">1.56</span>s  <span class="number">2.13</span>%  reflect.chanrecv</div><div class="line">(pprof)</div></pre></td></tr></table></figure>

<p>前两列显示采样中函数正在执行的次数和百分比（不包含等待函数调用返回的值），数值越大函数执行的频率越大。第三列显示的是前面的数值在整个列表中总数的百分比，Go team的例子中前三行的占比已经达到了32.4%。第4列、第5列显示正在运行和等待的函数出现的数量和占比，虽然函数<code>main.FindLoops</code>运行的次数才占10.6%,但是它确出现在84.1％采样的调用堆栈上(call stack)。</p>
<p>如果要按照第4列第5列排序，可以<code>(pprof) top5 -cum</code> :</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(pprof) top5 -cum</div><div class="line">Total:<span class="number"> 2525</span> samples</div><div class="line">      <span class="number"> 0</span>  <span class="number"> 0.0</span>%  <span class="number"> 0.0</span>%    <span class="number"> 2144</span> <span class="number"> 84.9</span>% gosched0</div><div class="line">      <span class="number"> 0</span>  <span class="number"> 0.0</span>%  <span class="number"> 0.0</span>%    <span class="number"> 2144</span> <span class="number"> 84.9</span>% main.main</div><div class="line">      <span class="number"> 0</span>  <span class="number"> 0.0</span>%  <span class="number"> 0.0</span>%    <span class="number"> 2144</span> <span class="number"> 84.9</span>% runtime.main</div><div class="line">      <span class="number"> 0</span>  <span class="number"> 0.0</span>%  <span class="number"> 0.0</span>%    <span class="number"> 2124</span> <span class="number"> 84.1</span>% main.FindHavlakLoops</div><div class="line">    <span class="number"> 268</span> <span class="number"> 10.6</span>% <span class="number"> 10.6</span>%    <span class="number"> 2124</span> <span class="number"> 84.1</span>% main.FindLoops</div><div class="line">(pprof) top5 -cum</div></pre></td></tr></table></figure>

<p>事实上<code>main.FindLoops</code>和<code>main.main</code>的占比应该是100%，但是由于每次采样只分析最底部的100个栈帧(stack frame)，大于四分之一的采样中，<code>main.DFS</code>递归调用的太深，超过了100帧，所有有些没有计数。</p>
<p>起始，性能数据中还包含更有趣的函数调用关系。<br>使用命令 web 可以产生SVG图形，用一个浏览器就能打开它，不过需要你的机器安装graphviz: <code>(pprof) web</code></p>
<p><img src="profiling-go-programs_havlak1a-75.png" alt=""></p>
<p>图形中的每个方框代表一个函数，方框的大小代表函数运行的采样数据大小。箭头x指向Y表示X调用Y,箭头指向自身表示递归调用。箭头上的数量代表一次采样中的调用次数。</p>
<p>从图中可以看出，程序花费了很多的时间在hash值的计算上，使用go map对象。我们可以让web只显示特定函数的采样，比如<code>runtime.mapaccess1_fast64</code>: <code>(pprof) web mapaccess1</code>。</p>
<p><img src="profiling-go-programs_havlak1-hash_lookup-75.png" alt=""></p>
<p>好了，我们知道了性能的大概情况以及哪个函数占的时间太多，现在通过<code>list</code>命令查看函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">(pprof) list DFS</div><div class="line">Total:<span class="number"> 2525</span> samples</div><div class="line">ROUTINE ====================== main.DFS in /home/rsc/g/benchgraffiti/havlak/havlak1.<span class="keyword">go</span></div><div class="line">  <span class="number"> 119</span>   <span class="number"> 697</span> Total samples (flat / cumulative)</div><div class="line">    <span class="number"> 3</span>     <span class="number"> 3</span> <span class="number"> 240</span>: <span class="keyword">func</span> DFS(currentNode *BasicBlock, nodes []*UnionFindNode, number <span class="keyword">map</span>[*BasicBlock]<span class="typename">int</span>, last []<span class="typename">int</span>, current <span class="typename">int</span>) <span class="typename">int</span> {</div><div class="line">    <span class="number"> 1</span>     <span class="number"> 1</span> <span class="number"> 241</span>:     nodes[current].Init(currentNode, current)</div><div class="line">    <span class="number"> 1</span>    <span class="number"> 37</span> <span class="number"> 242</span>:     number[currentNode] = current</div><div class="line">     .      . <span class="number"> 243</span>:</div><div class="line">    <span class="number"> 1</span>     <span class="number"> 1</span> <span class="number"> 244</span>:     lastid := current</div><div class="line">   <span class="number"> 89</span>    <span class="number"> 89</span> <span class="number"> 245</span>:     <span class="keyword">for</span> _, target := <span class="keyword">range</span> currentNode.OutEdges {</div><div class="line">    <span class="number"> 9</span>   <span class="number"> 152</span> <span class="number"> 246</span>:             <span class="keyword">if</span> number[target] == unvisited {</div><div class="line">    <span class="number"> 7</span>   <span class="number"> 354</span> <span class="number"> 247</span>:                     lastid = DFS(target, nodes, number, last, lastid<span class="number">+1</span>)</div><div class="line">     .      . <span class="number"> 248</span>:             }</div><div class="line">     .      . <span class="number"> 249</span>:     }</div><div class="line">    <span class="number"> 7</span>    <span class="number"> 59</span> <span class="number"> 250</span>:     last[number[currentNode]] = lastid</div><div class="line">    <span class="number"> 1</span>     <span class="number"> 1</span> <span class="number"> 251</span>:     <span class="keyword">return</span> lastid</div><div class="line">(pprof)</div></pre></td></tr></table></figure>

<p>前三列分别代表程序运行都此的采样数、运行到此或者在此调用的采样数、代码行数。</p>
<p>前面已经知道性能出现在map查找的实现上，我们重点分析第二列。时间很多花费在第247行。除了这个递归调用，其它时间花费较高的是 242、246和250行。分析得知map对于一些特殊的查找并不总是有效，所以我们可以用<code>[]int</code>代替<code>map [*BasicBlock]int</code>，根据索引查找更有效。</p>
<p>Go team根据分析修改了代码实现，再一次运行测试，果然有效。</p>
<p>整个源代码在 <a href="https://code.google.com/archive/p/benchgraffiti/source/default/source" target="_blank" rel="external">google code</a> 上可以下载，你可以测试演练一把。</p>
<p>测试修改后的结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">make</span> havlak2.prof</div><div class="line">./havlak2 -cpuprofile=havlak2.prof</div><div class="line"># of loops:<span class="number"> 76000</span> (including<span class="number"> 1</span> artificial root node)</div><div class="line">$ <span class="keyword">go</span> tool pprof havlak2 havlak2.prof</div><div class="line">Welcome to pprof!  For help, <span class="keyword">type</span> <span class="string">'help'</span>.</div><div class="line">(pprof)</div><div class="line">(pprof) top5</div><div class="line">Total:<span class="number"> 1652</span> samples</div><div class="line">    <span class="number"> 197</span> <span class="number"> 11.9</span>% <span class="number"> 11.9</span>%     <span class="number"> 382</span> <span class="number"> 23.1</span>% scanblock</div><div class="line">    <span class="number"> 189</span> <span class="number"> 11.4</span>% <span class="number"> 23.4</span>%    <span class="number"> 1549</span> <span class="number"> 93.8</span>% main.FindLoops</div><div class="line">    <span class="number"> 130</span>  <span class="number"> 7.9</span>% <span class="number"> 31.2</span>%     <span class="number"> 152</span>  <span class="number"> 9.2</span>% sweepspan</div><div class="line">    <span class="number"> 104</span>  <span class="number"> 6.3</span>% <span class="number"> 37.5</span>%     <span class="number"> 896</span> <span class="number"> 54.2</span>% runtime.mallocgc</div><div class="line">     <span class="number"> 98</span>  <span class="number"> 5.9</span>% <span class="number"> 43.5</span>%     <span class="number"> 100</span>  <span class="number"> 6.1</span>% flushptrbuf</div><div class="line">(pprof)</div></pre></td></tr></table></figure>

<p><code>main.DFS</code>不再出现在前几个占用时间较多的函数列表中，但是内存分配和垃圾回收占用确很多。使用<code>-memprofile</code>参数监控内存：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> memprofile = flag.String(<span class="string">"memprofile"</span>, <span class="string">""</span>, <span class="string">"write memory profile to this file"</span>)</div><div class="line">...</div><div class="line"></div><div class="line">    FindHavlakLoops(cfgraph, lsgraph)</div><div class="line">    <span class="keyword">if</span> *memprofile != <span class="string">""</span> {</div><div class="line">        f, err := os.Create(*memprofile)</div><div class="line">        <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">            log.Fatal(err)</div><div class="line">        }</div><div class="line">        pprof.WriteHeapProfile(f)</div><div class="line">        f.Close()</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div></pre></td></tr></table></figure>

<p>执行程序，得到内存采样数据：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ make havlak3.mprof</div><div class="line">go build havlak3.go</div><div class="line">./havlak3 -memprofile=havlak3.mprof</div><div class="line">$</div></pre></td></tr></table></figure>

<p>使用<code>go tool pprof</code>分析采样数据：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ go tool pprof havlak3 havlak3.mprof</div><div class="line">Adjusting heap profiles <span class="keyword">for</span> <span class="number">1</span>-in-<span class="number">524288</span> sampling rate</div><div class="line">Welcome to pprof!  For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">'help'</span>.</div><div class="line">(pprof) top5</div><div class="line">Total: <span class="number">82.4</span> MB</div><div class="line">    <span class="number">56.3</span>  <span class="number">68.4</span>%  <span class="number">68.4</span>%     <span class="number">56.3</span>  <span class="number">68.4</span>% main.FindLoops</div><div class="line">    <span class="number">17.6</span>  <span class="number">21.3</span>%  <span class="number">89.7</span>%     <span class="number">17.6</span>  <span class="number">21.3</span>% main.(*CFG).CreateNode</div><div class="line">     <span class="number">8.0</span>   <span class="number">9.7</span>%  <span class="number">99.4</span>%     <span class="number">25.6</span>  <span class="number">31.0</span>% main.NewBasicBlockEdge</div><div class="line">     <span class="number">0.5</span>   <span class="number">0.6</span>% <span class="number">100.0</span>%      <span class="number">0.5</span>   <span class="number">0.6</span>% itab</div><div class="line">     <span class="number">0.0</span>   <span class="number">0.0</span>% <span class="number">100.0</span>%      <span class="number">0.5</span>   <span class="number">0.6</span>% fmt.init</div><div class="line">(pprof)</div></pre></td></tr></table></figure>

<p><code>FindLoops</code>函数分配了大约56.3M内存，占总分配内存82.4M的68.4%。<br><code>CreateNode</code>分配了17.6M的内存。</p>
<p><code>list FindLoop</code>可以显示函数的详细的内存分配：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">(pprof) list FindLoops</div><div class="line">Total: <span class="number">82.4</span> MB</div><div class="line">ROUTINE ====================== main.FindLoops <span class="keyword">in</span> /home/rsc/g/benchgraffiti/havlak/havlak3.go</div><div class="line">  <span class="number">56.3</span>   <span class="number">56.3</span> Total MB (flat / cumulative)</div><div class="line">...</div><div class="line">   <span class="number">1.9</span>    <span class="number">1.9</span>  <span class="number">268</span>:     nonBackPreds := make([]map[int]bool, size)</div><div class="line">   <span class="number">5.8</span>    <span class="number">5.8</span>  <span class="number">269</span>:     backPreds := make([][]int, size)</div><div class="line">     .      .  <span class="number">270</span>:</div><div class="line">   <span class="number">1.9</span>    <span class="number">1.9</span>  <span class="number">271</span>:     number := make([]int, size)</div><div class="line">   <span class="number">1.9</span>    <span class="number">1.9</span>  <span class="number">272</span>:     header := make([]int, size, size)</div><div class="line">   <span class="number">1.9</span>    <span class="number">1.9</span>  <span class="number">273</span>:     types := make([]int, size, size)</div><div class="line">   <span class="number">1.9</span>    <span class="number">1.9</span>  <span class="number">274</span>:     last := make([]int, size, size)</div><div class="line">   <span class="number">1.9</span>    <span class="number">1.9</span>  <span class="number">275</span>:     nodes := make([]*UnionFindNode, size, size)</div><div class="line">     .      .  <span class="number">276</span>:</div><div class="line">     .      .  <span class="number">277</span>:     <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ {</div><div class="line">   <span class="number">9.5</span>    <span class="number">9.5</span>  <span class="number">278</span>:             nodes[i] = new(UnionFindNode)</div><div class="line">     .      .  <span class="number">279</span>:     }</div><div class="line">...</div><div class="line">     .      .  <span class="number">286</span>:     <span class="keyword">for</span> i, bb := range cfgraph.Blocks {</div><div class="line">     .      .  <span class="number">287</span>:             number[bb.Name] = unvisited</div><div class="line">  <span class="number">29.5</span>   <span class="number">29.5</span>  <span class="number">288</span>:             nonBackPreds[i] = make(map[int]bool)</div><div class="line">     .      .  <span class="number">289</span>:     }</div><div class="line">...</div></pre></td></tr></table></figure>

<p>问题出在第28行，还是map对象。<br>如果我们使用<code>--inuse_objects</code>参数,它将显示分配的对象数量而不是大小：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">$ go tool pprof --inuse_objects havlak3 havlak3.mprof</div><div class="line">Adjusting heap profiles <span class="keyword">for</span> <span class="number">1</span>-in-<span class="number">524288</span> sampling rate</div><div class="line">Welcome to pprof!  For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">'help'</span>.</div><div class="line">(pprof) list FindLoops</div><div class="line">Total: <span class="number">1763108</span> objects</div><div class="line">ROUTINE ====================== main.FindLoops <span class="keyword">in</span> /home/rsc/g/benchgraffiti/havlak/havlak3.go</div><div class="line"><span class="number">720903</span> <span class="number">720903</span> Total objects (flat / cumulative)</div><div class="line">...</div><div class="line">     .      .  <span class="number">277</span>:     <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ {</div><div class="line"><span class="number">311296</span> <span class="number">311296</span>  <span class="number">278</span>:             nodes[i] = new(UnionFindNode)</div><div class="line">     .      .  <span class="number">279</span>:     }</div><div class="line">     .      .  <span class="number">280</span>:</div><div class="line">     .      .  <span class="number">281</span>:     // Step a:</div><div class="line">     .      .  <span class="number">282</span>:     //   - initialize all nodes as unvisited.</div><div class="line">     .      .  <span class="number">283</span>:     //   - depth-first traversal and numbering.</div><div class="line">     .      .  <span class="number">284</span>:     //   - unreached BB<span class="string">'s are marked as dead.</span></div><div class="line">     .      .  285:     //</div><div class="line">     .      .  286:     for i, bb := range cfgraph.Blocks {</div><div class="line">     .      .  287:             number[bb.Name] = unvisited</div><div class="line">409600 409600  288:             nonBackPreds[i] = make(map[int]bool)</div><div class="line">     .      .  289:     }</div><div class="line">...</div><div class="line">(pprof)</div></pre></td></tr></table></figure>

<p>原因map会保存一个键值对，太浪费空间，可以用一个slice代替，当然程序逻辑要求要保存一个不重复的对象，所以我们可以提供一个辅助方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> appendUnique(a []<span class="typename">int</span>, x <span class="typename">int</span>) []<span class="typename">int</span> {</div><div class="line">    <span class="keyword">for</span> _, y := <span class="keyword">range</span> a {</div><div class="line">        <span class="keyword">if</span> x == y {</div><div class="line">            <span class="keyword">return</span> a</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(a, x)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>测试内存和CPU都比最开始的程序要好很多。</p>
<p>web 命令也可以显示内存分配和垃圾回收的占比图<code>(pprof) web mallocgc</code>：</p>
<p><img src="profiling-go-programs_havlak4a-mallocgc.png" alt=""></p>
<p>如果你觉得图中太多节点不好分析，可以忽略占比小于 10%的节点：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ go tool pprof --nodefraction=<span class="number">0.1</span> havlak4 havlak4.prof</div><div class="line">Welcome to pprof!  For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">'help'</span>.</div><div class="line">(pprof) web mallocgc</div></pre></td></tr></table></figure>

<p>这节上面的分析翻译自Go的官方文档。我觉得官方的这篇文档很详细，很好的演示了如何对一个性能有问题的命令行程序进行代码分析。</p>
<p>除了上面的两个profile,Go还提供了heap profile、block profile、trace信息。</p>
<p>如果你正在开发HTTP程序，你可以使用<code>net/http/pprof</code>包来得到这些监控数据。</p>
<p>在包引入时增加：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> _ <span class="string">"net/http/pprof"</span></div></pre></td></tr></table></figure>

<p>它会增加一些handler在/debug/pprof/下。你可以直接运行<code>go tool pprof</code>访问这些链接:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">go tool pprof http://localhost:<span class="number">6060</span>/debug/pprof/profile   <span class="comment"># 30-second CPU profile</span></div><div class="line">go tool pprof http://localhost:<span class="number">6060</span>/debug/pprof/heap      <span class="comment"># heap profile</span></div><div class="line">go tool pprof http://localhost:<span class="number">6060</span>/debug/pprof/block     <span class="comment"># goroutine blocking profile</span></div></pre></td></tr></table></figure>

<p>你可以访问<code>http://localhost:6060/debug/pprof</code>查看这些profile。</p>
<p>可以看一下这些profile handler如何配置的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> init() {</div><div class="line">    		http.Handle(<span class="string">"/debug/pprof/"</span>, http.HandlerFunc(Index))</div><div class="line">    		http.Handle(<span class="string">"/debug/pprof/cmdline"</span>, http.HandlerFunc(Cmdline))</div><div class="line">    		http.Handle(<span class="string">"/debug/pprof/profile"</span>, http.HandlerFunc(Profile))</div><div class="line">    		http.Handle(<span class="string">"/debug/pprof/symbol"</span>, http.HandlerFunc(Symbol))</div><div class="line">    		http.Handle(<span class="string">"/debug/pprof/trace"</span>, http.HandlerFunc(Trace))</div><div class="line">    	}</div></pre></td></tr></table></figure>

<p>可以看到它们设置在缺省的Mux上。所以如果你使用自己的Mux，或者使用第三方的框架，你可以模仿这个实现自己添建，甚至加上访问权限的控制。</p>
<p>具体可以看一个<code>Profile</code>方法的实现:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Profile(w http.ResponseWriter, r *http.Request) {</div><div class="line">    		sec, _ := strconv.ParseInt(r.FormValue(<span class="string">"seconds"</span>),<span class="number"> 10</span>,<span class="number"> 64</span>)</div><div class="line">    		<span class="keyword">if</span> sec ==<span class="number"> 0</span> {</div><div class="line">    			sec =<span class="number"> 30</span></div><div class="line">   		}</div><div class="line"></div><div class="line">   		<span class="comment">// Set Content Type assuming StartCPUProfile will work,</span></div><div class="line">   		<span class="comment">// because if it does it starts writing.</span></div><div class="line">   		w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"application/octet-stream"</span>)</div><div class="line">   		<span class="keyword">if</span> err := pprof.StartCPUProfile(w); err != <span class="constant">nil</span> {</div><div class="line">   			<span class="comment">// StartCPUProfile failed, so no writes yet.</span></div><div class="line">   			<span class="comment">// Can change header back to text content</span></div><div class="line">   			<span class="comment">// and send error code.</span></div><div class="line">   			w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"text/plain; charset=utf-8"</span>)</div><div class="line">   			w.WriteHeader(http.StatusInternalServerError)</div><div class="line">   			fmt.Fprintf(w, <span class="string">"Could not enable CPU profiling: %s\n"</span>, err)</div><div class="line">   			<span class="keyword">return</span></div><div class="line">   		}</div><div class="line">   		sleep(w, time.Duration(sec)*time.Second)</div><div class="line">   		pprof.StopCPUProfile()</div><div class="line">   	}</div></pre></td></tr></table></figure>

<p>可见它会暂停n秒取得采样数据后才完全返回给客户端。</p>
<p>参考</p>
<ul>
<li><a href="https://golang.org/pkg/net/http/pprof/" target="_blank" rel="external">https://golang.org/pkg/net/http/pprof/</a></li>
<li><a href="https://golang.org/pkg/runtime/pprof/" target="_blank" rel="external">https://golang.org/pkg/runtime/pprof/</a></li>
<li><a href="https://blog.golang.org/profiling-go-programs" target="_blank" rel="external">https://blog.golang.org/profiling-go-programs</a></li>
<li><a href="https://github.com/gperftools/gperftools" target="_blank" rel="external">https://github.com/gperftools/gperftools</a></li>
<li><a href="http://saml.rilspace.org/profiling-and-creating-call-graphs-for-go-programs-with-go-tool-pprof" target="_blank" rel="external">http://saml.rilspace.org/profiling-and-creating-call-graphs-for-go-programs-with-go-tool-pprof</a></li>
<li><a href="http://stackoverflow.com/questions/30871691/cant-get-golang-pprof-working" target="_blank" rel="external">http://stackoverflow.com/questions/30871691/cant-get-golang-pprof-working</a></li>
<li><a href="https://signalfx.com/blog/a-pattern-for-optimizing-go-2/" target="_blank" rel="external">https://signalfx.com/blog/a-pattern-for-optimizing-go-2/</a></li>
<li><a href="http://blog.ralch.com/tutorial/golang-performance-and-memory-analysis/" target="_blank" rel="external">http://blog.ralch.com/tutorial/golang-performance-and-memory-analysis/</a></li>
</ul>
<h3 id="benchmark测试">benchmark测试</h3>
<p>Go提供了benchmark的通用解决方案，但我不准备在本文中介绍了，而是和Go测试技术放在一起介绍。</p>
<p>Go 测试技术一文会介绍官方的测试方法、benchmark的测试方法，示例代码的编写，文档的生成等。</p>
<p>在这里需要提到的是<code>go test</code>提供了生成这些profile数据的参数<code>cpuprofile</code>、``memprofile等，所以很容易的分析测试时的性能的问题。</p>
<h3 id="Go调试参数">Go调试参数</h3>
<p>go的运行时<code>runtime</code>提供了一堆的参数。</p>
<p><code>GOGC</code>环境变量可以设置触发GC时的内存占用。<code>runtime/debug</code>的<code>SetFGCPercent</code>可以在运行时修改这个参数。</p>
<p>另一个重要的环境变量就是<code>GODEBUG</code>。它包含多个参数可以逗号分隔<code>name=val</code>设置多个变量：</p>
<pre class="highlight">
allocfreetrace: 设置 allocfreetrace=1 会监控每次分配，但因每次分配和释放的栈信息（stack trace）

cgocheck: 设置 cgocheck=0 禁用所有cgo检查将Go指针传递给非Go代码是否正确。
cgocheck=1 (缺省值) 轻量级检查。cgocheck=2 重量级检查。

efence: 设置 efence=1 导致分配器 allocator将每个对象分配在一个唯一的页page上，地址不重用。

gccheckmark: 设置 gccheckmark=1 允许垃圾回收器执行并发mark阶段的校验。会导致Stop The World。

gcpacertrace: 设置 gcpacertrace=1 会让来几回收器打印出concurrent pacer的内部状态。

gcshrinkstackoff: 设置 gcshrinkstackoff=1 则禁止将 goroutines 的栈缩小为更小栈。

gcstackbarrieroff: 设置 gcstackbarrieroff=1 禁用stack barriers，会影响垃圾回收器的重复搜索栈的功能。

gcstackbarrierall: 设置 gcstackbarrierall=1 会为每个栈帧安装一 stack barriers。

gcstoptheworld: 设置 gcstoptheworld=1 则禁用并发垃圾回收,每次回收都会触发STW。设置gcstoptheworld=2则禁用垃圾回收后的concurrent sweeping。

gctrace: 设置 gctrace=1导致每次垃圾回收器触发一行日志，包含内存回收的概要信息和暂停的时间。设置gctrace=2起同样的效果，but also repeats each collection。格式如下：

    gc # @#s #%: #+#+# ms clock, #+#/#/#+# ms cpu, #->#-># MB, # MB goal, # P
where the fields are as follows:
    gc #        GC id,每次GC加一
    @#s         程序启动后的时间，单位秒
    #%          程序启动后GC所用的时间比
    #+...+#     此次GC所用的wall-clock/CPU时间
    #->#-># MB  GC开始时的堆大小, GC结束时的堆大小, 活着的(live)堆大小
    # MB goal   总的堆大小
    # P         CPU使用数
垃圾回收分为下面的几个阶段：stop-the-world (STW) sweep termination, concurrent
mark and scan, and STW mark termination。 mark/scan的CPU时间又分为 assist time (GC performed in
line with allocation), background GC time, and idle GC time。
如果日志后以"(forced)"结尾,则GC通过runtime.GC()调用执行，此时所有的阶段都是STW.

memprofilerate: 设置 memprofilerate=X 会更新runtime.MemProfileRate的值。0则禁用这个profie。

invalidptr: 默认设为invalidptr=1, 如果指针被赋予一个无效值,会引起程序的崩溃，设置该值为0，会停止该检查，
0只能临时用于查找bug，真正的解决方法是不要把整数类型的值存在指针变量里面。

sbrk: 设置 sbrk=1 会使用实验性的实现替换memory allocator 和 garbage collector。

scavenge: scavenge=1 允许heap scavenger的debug模式。

scheddetail: 设置 schedtrace=X 和 scheddetail=1 会导致goroutine调度器每个X毫秒输出多行调度信息。

schedtrace: 设置 schedtrace=X导致调度器每个X秒输出一行调度器的概要信息。
</pre>

<p>包<code>runtime/debug</code>提供了程序设置/查看运行时的一些方法。</p>
<p>垃圾回收信息相当有用，有一个工具提供了可视化显示垃圾回收的信息，拿就是<a href="https://github.com/davecheney/gcvis" target="_blank" rel="external">gcvis</a>,你可以通过<br><code>env GOMAXPROCS=4 gcvis godoc -index -http=:6060</code><br>或者<br><code>GODEBUG=gctrace=1 godoc -index -http=:6060 2&gt;&amp;1 | gcvis</code><br>或者</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">GODEBUG=gctrace=<span class="number">1</span> godoc -index -<span class="keyword">http</span>=:<span class="number">6060</span> <span class="number">2</span>&gt; <span class="keyword">stderr</span>.<span class="built_in">log</span></div><div class="line">cat <span class="keyword">stderr</span>.<span class="built_in">log</span> | gcvis</div></pre></td></tr></table></figure>

<p>来执行。</p>
<p>下面是一个图例：<br><img src="gcvis.png" alt=""></p>
<p>参考</p>
<ul>
<li><a href="https://golang.org/pkg/runtime/" target="_blank" rel="external">https://golang.org/pkg/runtime/</a></li>
<li><a href="http://golanghome.com/post/158" target="_blank" rel="external">http://golanghome.com/post/158</a></li>
<li><a href="http://dave.cheney.net/2014/07/11/visualising-the-go-garbage-collector" target="_blank" rel="external">http://dave.cheney.net/2014/07/11/visualising-the-go-garbage-collector</a></li>
<li><a href="https://holys.im/2016/07/01/monitor-golang-gc/" target="_blank" rel="external">https://holys.im/2016/07/01/monitor-golang-gc/</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>本章重点介绍Go程序的调试和性能监控。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]JVM上最快的Bloom filter实现]]></title>
    <link href="http://colobu.com/2016/07/02/bloom-filter-for-scala/"/>
    <id>http://colobu.com/2016/07/02/bloom-filter-for-scala/</id>
    <published>2016-07-02T15:52:19.000Z</published>
    <updated>2016-07-04T02:03:17.000Z</updated>
    <content type="html"><![CDATA[<p>英文原始出处: <a href="https://alexandrnikitin.github.io/blog/bloom-filter-for-scala/" target="_blank" rel="external">Bloom filter for Scala, the fastest for JVM</a></p>
<p>本文介绍的是我用Scala实现的Bloom filter。 源代码在<a href="https://github.com/alexandrnikitin/bloom-filter-scala" target="_blank" rel="external">github</a>上。依照<a href="">性能测试结果</a>，它是JVM上的<strong>最快</strong>的Bloom filter实现。零分配(Zero-allocation)和高度优化的代码。 无内存限制，所以没有包含元素的数量限制和可控的误报率(false positive rate)。<br>扩展：可插拔的Hash算法，任意的元素类型。<br>没错，它使用<code>sun.misc.unsafe</code>。<br><a id="more"></a></p>
<h3 id="介绍">介绍</h3>
<blockquote>
<p>&quot;A Bloom filter is a space-efficient probabilistic data structure that is used to test whether an element is a member of a set. False positive matches are possible, but false negatives are not. In other words, a query returns either “possibly in set” or “definitely not in set”. Elements can be added to the set, but not removed,” says <a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="external">Wikipedia</a>.</p>
<p>Bloom filter 是由 Howard Bloom 在 1970 年提出的二进制向量数据结构，它具有很好的空间和时间效率，被用来检测一个元素是不是集合中的一个成员。如果检测结果为是，该元素不一定在集合中；但如果检测结果为否，该元素一定不在集合中。因此Bloom filter具有100%的召回率。这样每个检测请求返回有“在集合内（可能错报）”和“不在集合内（绝对不在集合内）”两种情况，可见 Bloom filter 是牺牲了正确率和时间以节省空间。 引自 <a href="http://baike.baidu.com/view/1912944.htm" target="_blank" rel="external">百度百科</a></p>
</blockquote>
<p>简而言之，Bloom filter是:</p>
<ul>
<li>优化内存占用， 当整个集合太大而不能全部放到内存中。Optimization for memory. It comes into play when you cannot put whole set into memory.</li>
<li>解决成员存在性的问题。它可以回答下面的问题：一个元素属于一个集合还是不属于？</li>
<li>概率(有损)数据结构。它可以返回一个元素有多大的概率属于一个集合</li>
</ul>
<p>后面这篇文章介绍的Bloom filter很详尽 - <a href="https://sc5.io/posts/what-are-bloom-filters-and-why-are-they-useful/" target="_blank" rel="external">“What are Bloom filters, and why are they useful?”</a> by <a href="https://twitter.com/maxpagels" target="_blank" rel="external">@Max Pagels</a>。我没必要再献丑了，如果你还不熟悉Bloom filter不妨看一看。</p>
<h3 id="为何再造轮子？">为何再造轮子？</h3>
<p>因为性能或者内存限制的原因，已有的Bloom filter并不能满足我们的需求，或者你发现你可以做的更好。坦率的说，都不是。只不过有时候你厌倦了而已。(作者吐槽，可忽略之)</p>
<p>主要的原因是性能。当开发高性能和低延迟的系统的时候，你可不想被外部的库所拖累，甚至分配了很多的内存。你的注意力应该集中在业务逻辑上，依赖的库应该尽可能的有效。</p>
<p>另一个原因还是内存限制。所有的实现都会因为JVM数组的大小的限制而受限制。JVM中，数字使用整数integer做索引，所以数组的最大长度也就是整数的最大值<strong>2147483647</strong>。如果我们创建一个元素类型为long的数组存储比特位bit的值，那么最多我们可以存储64 bit * 2147483647 = 137438953408 bits,大概需要15 GB左右的内存。你可以放入大约10000000000左右的元素到误报率为0.1%的Bloom filter。这对于大部分软件来说足够了，但是当你处理大数据，比如URL，图标广告，实时竞价请求或者是事件流的时候，100亿的数据只是一个起步量。当然你可以有一些变通的办法：部署多个Bloom filter,将它们分布到多个节点，或者设计你的软件适应这些限制，但这些办法并不总是有效，可能花费较高护着不满足你的架构。</p>
<p>让我们看看当前已有的一些Bllom filter的实现。</p>
<h4 id="Google_guava">Google guava</h4>
<p><a href="https://github.com/google/guava" target="_blank" rel="external">Guava</a>是Google开发的一个高质量的核心库，它包含集合、基本数据、并发、I/O、Cache等模块。 它也包含一个<a href="https://github.com/google/guava/wiki/HashingExplained#bloomfilter" target="_blank" rel="external">Bloom filter</a>实现。Guava是我的初始选择，它经受考验、也很快，但是……</p>
<p>令人咂舌的是，它会额外分配内存。我使用Google的<a href="https://github.com/google/allocation-instrumenter" target="_blank" rel="external">Allocation Instrumenter</a>监控所有的分配allocation。下面的分配监控显示了检查包含100字符的字符串是否存在于一个Bloom filter中:</p>
<pre class="highlight">
I just allocated the object [B@39420d59 of type byte whose size is 40 It's an array of size 23
I just allocated the object java.nio.HeapByteBuffer[pos=0 lim=23 cap=23] of type java/nio/HeapByteBuffer whose size is 48
I just allocated the object com.google.common.hash.Murmur3_128HashFunction$Murmur3_128Hasher@5dd227b7 of type com/google/common/hash/Murmur3_128HashFunction$Murmur3_128Hasher whose size is 48
I just allocated the object [B@3d3b852e of type byte whose size is 24 It's an array of size 1
I just allocated the object [B@14ba7f15 of type byte whose size is 24 It's an array of size 1
I just allocated the object sun.nio.cs.UTF_8$Encoder@55cb3b7 of type sun/nio/cs/UTF_8$Encoder whose size is 56
I just allocated the object [B@497fd334 of type byte whose size is 320 It's an array of size 300
I just allocated the object [B@280c3dc0 of type byte whose size is 312 It's an array of size 296
I just allocated the object java.nio.HeapByteBuffer[pos=0 lim=296 cap=296] of type java/nio/HeapByteBuffer whose size is 48
I just allocated the object [B@6f89ad03 of type byte whose size is 32 It's an array of size 16
I just allocated the object java.nio.HeapByteBuffer[pos=0 lim=16 cap=16] of type java/nio/HeapByteBuffer whose size is 48
I just allocated the object 36db757cdd5ae408ef61dca2406d0d35 of type com/google/common/hash/HashCode$BytesHashCode whose size is 16
</pre>

<p>一共1016个字节。想象一下，我们计算一个短字符串的hash值，检查它相应的bit位设置已经设置，它需要分配大于1Kb的数据。太多了。那你可能会说内存占用已经很小了，好吧，当你做一个单独的微性能测试的时候，影响不是很大，但是在产品级的环境中，它会变得更糟：它会影响GC，导致分配变慢，触发GC，导致更高的延迟等。</p>
<p>不管怎样，review一下代码会很有趣，有时候你会发现一些复活节彩蛋在里面，比如下面的例子：<br><img src="guava-review.png" alt=""></p>
<p>这些注释行来自Naughty by Nature说唱组合的歌曲“O.P.P.”,在上世纪90年代早期很流行。这段代码的开发者可能那时是四五十岁的人(偏题了)。</p>
<h4 id="Twitter_Algebird">Twitter Algebird</h4>
<p>Algebird &quot;为Scala提供的抽象代数库，这些代码主要是用于建立聚合系统（通过Scalding或Storm）。 它是函数式functional，不可变<br>immutable, monadic,但是非常非常非常慢，并且仅仅支持字符串作为元素类型。字符串是万能的数据格式，你可硬用它存任何值 :) 。</p>
<p>它使用人人皆爱的MurmurHash3算法，它是最好的通用的hash算法。它计算出128-bit的 hash值，分割成4个32-bit的数字。然后它为每个32-bit的数字设置相应的位，而不是整个的hash值。这是相当有争议的设计，我进行了粗略的测试，测试表明Teitter Bloom filter有超过 10% 的误报率。</p>
<p>更深一步，有趣的是Twitter Bloom filter 底层使用 <a href="https://github.com/lemire/javaewah" target="_blank" rel="external">EWAHCompressedBitmap</a>,它是一个压缩的可替代BitSet的实现。它专门为内存占用而优化，适合稀疏数据的场景。比如，如果你的位数从1000000开始，EWAH可以优化set而不会为前面的0位分配内存。集合的操作如交集、并集和差也更快。但是随机访问却很慢。 而且hash的目标就是有一个均匀分布的hash值，越均匀越好。这两点就排除了使用压缩bitset的好处。我做了一点点测试来检查整个的内存分配，结果显示Twitter Bloom filter比我的实现还要分配更多的内存。 同样，在我看来，Twitter的实现也是相当有争议。</p>
<p>内存检查的结果很长我就不贴了。为包含100个字符的字符串的检查要分配<strong>1808</strong>字节，我哭!</p>
<p>同样，它是函数式functional, 不可变immutable, 使用持久化数据结构, monad, 但这些不足以让我们使用它。 大话说在前， 它的读性能要比我的实现慢10倍，写要慢100倍。</p>
<h4 id="ScalaNLP’s_Breeze">ScalaNLP’s Breeze</h4>
<blockquote>
<p>Breeze is a generic, clean and powerful Scala numerical processing library… Breeze is a part of ScalaNLP project, a scientific computing platform for Scala</p>
</blockquote>
<p>Breeze的介绍看起来很有吸引力，如清爽的新风，但是，有一个<a href="https://github.com/scalanlp/breeze/blob/c12763387cb0741e6d588435d7da92b505f12843/math/src/main/scala/breeze/util/BloomFilter.scala#L36" target="_blank" rel="external">花招在它的实现里</a>。它直接使用对象的hash值。 &quot;WTF,我钟爱的MurmurHash3哪去了&quot;，你可能会问。MurmurHash3仅仅用来计算最终的对象的hash值，没错，它可以和任意类型一起工作，但是你不会知道你的大数据集的细微差别(编者按:较难理解，需要配合代码一起理解。 英文原意为：It’s used only for “finalizing” the object’s hash. Yeah, it works with any type out-of-the-box but if you don’t know that little nuance you are done with large datasets.)</p>
<p>测试中它会分配544字节，看看代码你会发现通用的Scala的问题：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> {</div><div class="line">  i &lt;- <span class="number">0</span> to numHashFunctions</div><div class="line">} <span class="keyword">yield</span> {</div><div class="line">  <span class="keyword">val</span> h = hash1 + i * hash2</div><div class="line">  <span class="keyword">val</span> nextHash = <span class="keyword">if</span> (h &lt; <span class="number">0</span>) ~h <span class="keyword">else</span> h</div><div class="line">  nextHash % numBuckets</div><div class="line">}</div></pre></td></tr></table></figure>

<p>看起来很简洁：for语句，延迟计算,漂亮的DSL。但是当它编译成Java代码的时候就不那么好看了，它会分配很多对象: intWrapper(), RichInt, Range.Inclusive, VectorBuilder/Vector, boxing/unboxing 等等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> (IndexedSeq)RichInt$.MODULE$.to$extension0(Predef$.MODULE$.intWrapper(<span class="number">0</span>), numHashFunctions()).map(<span class="keyword">new</span> Serializable(hash1, hash2) {</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">apply</span>(<span class="keyword">int</span> i)</div><div class="line">    {</div><div class="line">        <span class="keyword">return</span> apply$mcII$sp(i);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> apply$mcII$<span class="title">sp</span>(<span class="keyword">int</span> i)</div><div class="line">    {</div><div class="line">        <span class="keyword">int</span> h = hash1$<span class="number">1</span> + i * hash2$<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> nextHash = h &gt;= <span class="number">0</span> ? h : ~h;</div><div class="line">        <span class="keyword">return</span> nextHash % $outer.numBuckets();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">volatile</span> Object <span class="title">apply</span>(Object v1)</div><div class="line">    {</div><div class="line">        <span class="keyword">return</span> BoxesRunTime.boxToInteger(apply(BoxesRunTime.unboxToInt(v1)));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">0</span>L;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BloomFilter $outer;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> hash1$1;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> hash2$1;</div><div class="line"></div><div class="line">    <span class="keyword">public</span></div><div class="line">    {</div><div class="line">        <span class="keyword">if</span>(BloomFilter.<span class="keyword">this</span> == <span class="keyword">null</span>)</div><div class="line">        {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">null</span>;</div><div class="line">        } <span class="keyword">else</span></div><div class="line">        {</div><div class="line">            <span class="keyword">this</span>.$outer = BloomFilter.<span class="keyword">this</span>;</div><div class="line">            <span class="keyword">this</span>.hash1$<span class="number">1</span> = hash1$<span class="number">1</span>;</div><div class="line">            <span class="keyword">this</span>.hash2$<span class="number">1</span> = hash2$<span class="number">1</span>;</div><div class="line">            <span class="keyword">super</span>();</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line">, IndexedSeq$.MODULE$.canBuildFrom());</div></pre></td></tr></table></figure>

<p>震撼吗？我想你被震惊了。接下来看看我的实现。</p>
<h3 id="我是如何实现的？">我是如何实现的？</h3>
<p>一句话，我重新实现了Bloom filter的数据结构。源代码在<a href="https://github.com/alexandrnikitin/bloom-filter-scala" target="_blank" rel="external">github</a>上，可以通过<a href="https://mvnrepository.com/artifact/com.github.alexandrnikitin/bloom-filter_2.11" target="_blank" rel="external">maven repository引用</a>:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">libraryDependencies += <span class="string">"com.github.alexandrnikitin"</span> %% <span class="string">"bloom-filter"</span> % <span class="string">"0.3.1"</span></div></pre></td></tr></table></figure>

<p>下面是使用的例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> bloomfilter.mutable.BloomFilter</div><div class="line"></div><div class="line"><span class="keyword">val</span> expectedElements = <span class="number">1000</span></div><div class="line"><span class="keyword">val</span> falsePositiveRate = <span class="number">0.1</span></div><div class="line"><span class="keyword">val</span> bf = BloomFilter[String](expectedElements, falsePositiveRate)</div><div class="line">bf.add(<span class="string">"some string"</span>)</div><div class="line">bf.mightContain(<span class="string">"some string"</span>)</div><div class="line">bf.dispose()</div></pre></td></tr></table></figure>

<h4 id="Unsafe">Unsafe</h4>
<p>一个重要的设计就是底层使用<code>sun.misc.unsafe</code>包。使用它分配一块内存来保存bit，所以你需要主动dispose Bloom filter 实例和不受管的内存释放。而且我的实现还使用 <code>usafe</code>做了一些花招以避免内存分配，比如直接访问字符串内部的char数组。</p>
<h4 id="type_class模式">type class模式</h4>
<p>我的实现是可扩展的，你可以为任意类型使用任意的hash算法。它通过<strong>type class模式</strong>实现。如果你不熟悉它，你可以阅读<a href="https://twitter.com/kaffeecoder" target="_blank" rel="external">@Daniel Westheide</a>的文章 <a href="http://danielwestheide.com/blog/2013/02/06/the-neophytes-guide-to-scala-part-12-type-classes.html" target="_blank" rel="external">“The Neophyte’s Guide to Scala”</a>。</p>
<p>基本上，你所需的就是实现<code>CanGenerateHashFrom[From]</code> trait,就像这样:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">CanGenerateHashFrom</span>[<span class="title">From</span>] </span>{</div><div class="line">  <span class="keyword">def</span> generateHash(from: From): Long</div><div class="line">}</div></pre></td></tr></table></figure>

<p>不幸的是，它是<code>invariant</code>不变类型。我想实现为逆变类型contravariant但是Scala编译器不能正确的解决contravariant implicits,将来在<a href="http://dotty.epfl.ch/#so-features" target="_blank" rel="external">Dotty</a>编译器中会支持。</p>
<p>缺省地提供了一个<code>MurmurHash3</code>的通用实现。我使用Scala实现了它，比Guava、Algebird、Cassandra的实现更快（希望我没有犯错）。为<code>Long</code>、<code>String</code>、<code>Array[Byte]</code>提供可开箱即用的库。作为一个福利，为无限唯一性(unlimited uniqueness)提供了128bit的版本。</p>
<h4 id="零分配Zero-allocation">零分配Zero-allocation</h4>
<p>我的Bloom filter实现没有分配任何对象，代码被高度优化。我计划写一篇独立的文章来描述这些优化，敬请关注。通过一系列的<code>unsafe</code>技巧来实现的。下面是为String类型实现的 <code>CanGenerateHashFrom</code> trait:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">implicit <span class="class"><span class="keyword">object</span> <span class="title">CanGenerateHashFromString</span> <span class="keyword">extends</span> <span class="title">CanGenerateHashFrom</span>[<span class="title">String</span>] </span>{</div><div class="line"></div><div class="line">  <span class="keyword">import</span> scala.concurrent.util.Unsafe.{instance =&gt; unsafe}</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">val</span> valueOffset = unsafe.objectFieldOffset(classOf[String].getDeclaredField(<span class="string">"value"</span>))</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> generateHash(from: String): Long = {</div><div class="line">    <span class="keyword">val</span> value = unsafe.getObject(from, valueOffset).asInstanceOf[Array[Char]]</div><div class="line">    MurmurHash3Generic.murmurhash3_x64_64(value, <span class="number">0</span>, from.length, <span class="number">0</span>)</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用<code>unsafe.objectFieldOffset()</code>方法获取String类型的value字段，它是字符串底层的char数组。然后使用<code>unsafe.getObject()</code>方法访问字符数组,用来计算hash值。</p>
<p>不幸的是，128-bit的实现会分配一个对象。我在<code>(Long, Long)</code> tuple和 <code>ThreadLocal</code>的字段选择上很犹豫，对于整体的性能，没有影响，有什么意见吗？在我的有生之年我希望能看到<a href="http://mail.openjdk.java.net/pipermail/valhalla-dev/2016-June/001981.html" target="_blank" rel="external">JVM的值类型</a>, <a href="https://twitter.com/giltene" target="_blank" rel="external">@Gil Tene</a>的<a href="http://objectlayout.github.io/ObjectLayout/" target="_blank" rel="external">ObjectLayout</a>尝试实现它。</p>
<h4 id="限制">限制</h4>
<p>你可能已经注意到了，当前实现有一些限制。<code>CanGenerateHashFrom[From]</code> trait是不可变的invariant,它不允许回退到对象的<code>hashCode()</code>方法。你需要为你的类型实现它的hash算法。但我相信，为了性能这也是值得的。</p>
<p>并不是所有的JVM都支持，因为底层使用了“unsafe” 包，而且这也没有退路(fallback )的实现。</p>
<blockquote>
<p><code>sun.misc.Unsafe</code>至少从2004年Java1.4开始就存在于Java中了。在Java9中，为了提高JVM的可维护性，Unsafe和许多其他的东西一起都被作为内部使用类隐藏起来了。但是究竟是什么取代Unsafe不得而知。 摘自: <a href="http://www.importnew.com/14511.html" target="_blank" rel="external">http://www.importnew.com/14511.html</a></p>
</blockquote>
<h4 id="可以在Java中用它吗？">可以在Java中用它吗？</h4>
<p>可以，但是代码不会和Scala一样漂亮，当然你已经习惯了这一切。Java中没有implicit，而且Java编译器也不会帮你调用它。在Java中使用它很丑但是能工作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> bloomfilter.CanGenerateHashFrom;</div><div class="line"><span class="keyword">import</span> bloomfilter.mutable.BloomFilter;</div><div class="line"></div><div class="line"><span class="keyword">long</span> expectedElements = <span class="number">10000000</span>;</div><div class="line"><span class="keyword">double</span> falsePositiveRate = <span class="number">0.1</span>;</div><div class="line">BloomFilter&lt;<span class="keyword">byte</span>[]&gt; bf = BloomFilter.apply(</div><div class="line">        expectedElements,</div><div class="line">        falsePositiveRate,</div><div class="line">        CanGenerateHashFrom.CanGenerateHashFromByteArray$.MODULE$);</div><div class="line"></div><div class="line"><span class="keyword">byte</span>[] element = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</div><div class="line">bf.add(element);</div><div class="line">bf.mightContain(element);</div><div class="line">bf.dispose();</div></pre></td></tr></table></figure>

<h3 id="性能benchmark">性能benchmark</h3>
<p>我们都喜欢性能基准数据，对不？令人兴奋的数字在空中游荡，是那么的迷人。如果你准备写性能基准的测试，请使用<a href="http://openjdk.java.net/projects/code-tools/jmh/" target="_blank" rel="external">JMH</a>。 它是Oracle的性能工程师 <a href="https://www.youtube.com/watch?v=dQw4w9WgXcQ" target="_blank" rel="external">@Aleksey Shipilev</a>创建的一个微性能基准库： “for building, running, and analyzing nano/micro/milli/macro benchmarks written in Java and other languages targeting the JVM.”， <a href="https://twitter.com/ktosopl" target="_blank" rel="external">@Konrad Malawski</a>写了一个<a href="https://github.com/ktoso/sbt-jmh" target="_blank" rel="external">SBT的插件</a>。</p>
<p>下面是一个<code>String</code>类型的基准测试，其它类型的测试结果和此类似：</p>
<pre class="highlight">
[info] Benchmark                                              (length)   Mode  Cnt          Score         Error  Units
[info] alternatives.algebird.StringItemBenchmark.algebirdGet      1024  thrpt   20    1181080.172 ▒    9867.840  ops/s
[info] alternatives.algebird.StringItemBenchmark.algebirdPut      1024  thrpt   20     157158.453 ▒     844.623  ops/s
[info] alternatives.breeze.StringItemBenchmark.breezeGet          1024  thrpt   20    5113222.168 ▒   47005.466  ops/s
[info] alternatives.breeze.StringItemBenchmark.breezePut          1024  thrpt   20    4482377.337 ▒   19971.209  ops/s
[info] alternatives.guava.StringItemBenchmark.guavaGet            1024  thrpt   20    5712237.339 ▒  115453.495  ops/s
[info] alternatives.guava.StringItemBenchmark.guavaPut            1024  thrpt   20    5621712.282 ▒  307133.297  ops/s

// My Bloom filter
[info] bloomfilter.mutable.StringItemBenchmark.myGet              1024  thrpt   20   11483828.730 ▒  342980.166  ops/s
[info] bloomfilter.mutable.StringItemBenchmark.myPut              1024  thrpt   20   11634399.272 ▒   45645.105  ops/s
[info] bloomfilter.mutable._128bit.StringItemBenchmark.myGet      1024  thrpt   20   11119086.965 ▒   43696.519  ops/s
[info] bloomfilter.mutable._128bit.StringItemBenchmark.myPut      1024  thrpt   20   11303765.075 ▒   52581.059  ops/s
</pre>

<p>我的实现大致要比Goole Guava的实现快2倍， 比Twitter Algebird快10 ~ 80倍，其它的benchmark你可以在<a href="https://github.com/alexandrnikitin/bloom-filter-scala/tree/0e9d0ba103c314ae2c071a107ff7fbc48af4c904/benchmarks/src/main/scala" target="_blank" rel="external">github上的“benchmarks’模块</a>找到。</p>
<p>警告：这是在独立环境中的综合测试。通常吞吐率和延迟的差别要比产品环境中要大，因为它会对GC有压力，导致分配很慢，更高的延迟，触发GC等。</p>
<h3 id="用在哪里？">用在哪里？</h3>
<p>高性能和低延迟系统。</p>
<p>大数据和机器学习系统，有巨量唯一的数据。</p>
<h4 id="什么时候不用它?">什么时候不用它?</h4>
<p>如果你当前的解决方案已满足需求，大部分软件都不需要这么快。</p>
<p>你只信任那些大公司如Google、Twitter出品的已被证明的、经受考验的库。</p>
<p>你想要开箱即用的库。</p>
<h3 id="下一步">下一步</h3>
<p>欢迎你的意见和建议。下一步我会实现一个稳定的<a href="https://webdocs.cs.ualberta.ca/~drafiei/papers/DupDet06Sigmod.pdf" target="_blank" rel="external">(Stable) Bloom filter 数据结构</a>，因为目前没有好的实现。我计划研究一下 <a href="https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf" target="_blank" rel="external">Cuckoo filer 数据结构</a>。对此有何经验吗？</p>
<p>谢谢</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>英文原始出处: <a href="https://alexandrnikitin.github.io/blog/bloom-filter-for-scala/" target="_blank" rel="external">Bloom filter for Scala, the fastest for JVM</a></p>
<p>本文介绍的是我用Scala实现的Bloom filter。 源代码在<a href="https://github.com/alexandrnikitin/bloom-filter-scala" target="_blank" rel="external">github</a>上。依照<a href="">性能测试结果</a>，它是JVM上的<strong>最快</strong>的Bloom filter实现。零分配(Zero-allocation)和高度优化的代码。 无内存限制，所以没有包含元素的数量限制和可控的误报率(false positive rate)。<br>扩展：可插拔的Hash算法，任意的元素类型。<br>没错，它使用<code>sun.misc.unsafe</code>。<br>]]>
    
    </summary>
    
      <category term="Scala" scheme="http://colobu.com/categories/Scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Go net/http 超时机制完全手册]]></title>
    <link href="http://colobu.com/2016/07/01/the-complete-guide-to-golang-net-http-timeouts/"/>
    <id>http://colobu.com/2016/07/01/the-complete-guide-to-golang-net-http-timeouts/</id>
    <published>2016-07-01T06:56:19.000Z</published>
    <updated>2016-07-04T02:02:06.000Z</updated>
    <content type="html"><![CDATA[<p>英文原始出处: <a href="https://blog.cloudflare.com/the-complete-guide-to-golang-net-http-timeouts/" target="_blank" rel="external">The complete guide to Go net/http timeouts</a>, 作者: <a href="https://blog.cloudflare.com/author/filippo/" target="_blank" rel="external">Filippo Valsorda</a></p>
<p>当用Go写HTTP的服务器和客户端的时候，超时处理总是最易犯错和最微妙的地方之一。错误可能来自很多地方，一个错误可能等待很长时间没有结果，直到网络故障或者进程挂起。</p>
<p>HTTP是一个复杂的、多阶段(multi-stage)协议，所以没有一个放之四海而皆准的超时解决方案，比如一个流服务、一个JSON API和一个Comet服务对超时的需求都不相同， 往往默认值不是你想要的。</p>
<p>本文我将拆解需要超时设置的各个阶段，看看用什么不同的方式去处理它， 包括服务器端和客户端。</p>
<a id="more"></a>
<h3 id="SetDeadline">SetDeadline</h3>
<p>首先，你需要了解Go实现超时的网络原语(primitive): <strong>Deadline</strong> (最后期限)。</p>
<p><code>net.Conn</code>为Deadline提供了多个方法<code>Set[Read|Write]Deadline(time.Time)</code>。Deadline是一个绝对时间值，当到达这个时间的时候，所有的 I/O 操作都会失败，返回超时(timeout)错误。</p>
<p><strong>Deadline不是超时</strong>(timeout)。一旦设置它们永久生效(或者直到下一次调用SetDeadline), 不管此时连接是否被使用和怎么用。所以如果想使用<code>SetDeadline</code>建立超时机制，你不得不每次在<code>Read/Write</code>操作之前调用它。</p>
<p>你可能不想自己调用<code>SetDeadline</code>, 而是让<code>net/http</code>代替你调用，所以你可以调用更高级的timeout方法。但是请记住，所有的超时的实现都是基于Deadline, 所以它们不必重置每次发送和接收的时间值(<strong>they do NOT reset every time data is sent or received</strong>)。</p>
<h3 id="服务器端超时设置">服务器端超时设置</h3>
<p><img src="server-timeout.png" alt=""></p>
<p>对于暴露在网上的服务器来说，为客户端连接设置超时至关重要，否则巨慢的或者隐失的客户端可能导致文件句柄无法释放，最终导致服务器出现下面的错误:</p>
<pre class="highlight">
http: Accept error: accept tcp [::]:80: accept4: too many open files; retrying in 5ms  
</pre>


<p><code>http.Server</code>有两个设置超时的方法: <code>ReadTimeout</code> 和 <code>and</code>WriteTimeout`。你可以显示地设置它们：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">srv := &http.Server{  </div><div class="line">    ReadTimeout:<span class="number"> 5</span> * time.Second,</div><div class="line">    WriteTimeout:<span class="number"> 10</span> * time.Second,</div><div class="line">}</div><div class="line">log.Println(srv.ListenAndServe())</div></pre></td></tr></table></figure>

<p><code>ReadTimeout</code>的时间计算是从连接被接受(accept)到request body完全被读取(如果你不读取body，那么时间截止到读完header为止)。它的内部实现是在<code>Accept</code>立即调用<code>SetReadDeadline</code>方法(<a href="https://github.com/golang/go/blob/3ba31558d1bca8ae6d2f03209b4cae55381175b3/src/net/http/server.go#L750" target="_blank" rel="external">代码行</a>)。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">  ……</div><div class="line">  <span class="keyword">if</span> d := c.server.ReadTimeout; d !=<span class="number"> 0</span> {</div><div class="line">	c.rwc.SetReadDeadline(time.Now().Add(d))</div><div class="line">}</div><div class="line"><span class="keyword">if</span> d := c.server.WriteTimeout; d !=<span class="number"> 0</span> {</div><div class="line">	c.rwc.SetWriteDeadline(time.Now().Add(d))</div><div class="line">}</div><div class="line">  ……</div></pre></td></tr></table></figure>

<p><code>WriteTimeout</code>的时间计算正常是从request header的读取结束开始，到 response write结束为止 (也就是 ServeHTTP 方法的声明周期), 它是通过在<code>readRequest</code>方法结束的时候调用<code>SetWriteDeadline</code>实现的(<a href="https://github.com/golang/go/blob/3ba31558d1bca8ae6d2f03209b4cae55381175b3/src/net/http/server.go#L753-L755" target="_blank" rel="external">代码行</a>)。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (c *conn) readRequest(ctx context.Context) (w *response, err error) {</div><div class="line">	<span class="keyword">if</span> c.hijacked() {</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span>, ErrHijacked</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">if</span> d := c.server.ReadTimeout; d !=<span class="number"> 0</span> {</div><div class="line">		c.rwc.SetReadDeadline(time.Now().Add(d))</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> d := c.server.WriteTimeout; d !=<span class="number"> 0</span> {</div><div class="line">		<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">			c.rwc.SetWriteDeadline(time.Now().Add(d))</div><div class="line">		}()</div><div class="line">	}</div><div class="line"></div><div class="line">  ……</div><div class="line">}</div></pre></td></tr></table></figure>

<p>但是，当连接是HTTPS的时候，<code>SetWriteDeadline</code>会在<code>Accept</code>之后立即调用(<a href="https://github.com/golang/go/blob/3ba31558d1bca8ae6d2f03209b4cae55381175b3/src/net/http/server.go#L1477-L1483" target="_blank" rel="external">代码</a>)，所以它的时间计算也包括 TLS握手时的写的时间。 讨厌的是， 这就意味着(也只有这种情况) <code>WriteTimeout</code>设置的时间也包含读取Headerd到读取body第一个字节这段时间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> tlsConn, ok := c.rwc.(*tls.Conn); ok {</div><div class="line">		<span class="keyword">if</span> d := c.server.ReadTimeout; d !=<span class="number"> 0</span> {</div><div class="line">			c.rwc.SetReadDeadline(time.Now().Add(d))</div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> d := c.server.WriteTimeout; d !=<span class="number"> 0</span> {</div><div class="line">			c.rwc.SetWriteDeadline(time.Now().Add(d))</div><div class="line">		}</div><div class="line">    ……</div></pre></td></tr></table></figure>

<p>当你处理不可信的客户端和网络的时候，你应该同时设置读写超时，这样客户端就不会因为读慢或者写慢长久的持有这个连接了。</p>
<p>最后，还有一个<code>http.TimeoutHandler</code>方法。 它并不是Server参数，而是一个Handler包装函数，可以限制 <code>ServeHTTP</code>调用。它缓存response, 如果deadline超过了则发送 <em>504 Gateway Timeout</em> 错误。 注意这个功能<a href="https://github.com/golang/go/issues/15327" target="_blank" rel="external">在 1.6 中有问题，在1.6.2中改正了</a>。</p>
<h4 id="http-ListenAndServe_的错误">http.ListenAndServe 的错误</h4>
<p>顺便提一句，<code>net/http</code>包下的封装的绕过<code>http.Server</code>的函数<code>http.ListenAndServe</code>, <code>http.ListenAndServeTLS</code> 和 <code>http.Serve</code>并不适合实现互联网的服务器。这些函数让超时设置默认不启用，并且你没有办法设置启用超时处理。所以如果你使用它们，你会很快发现连接泄漏，太多的文件句柄。我犯过这种错误至少五六次。</p>
<p>取而代之，你应该创建一个<code>http.Server</code>示例，设置<code>ReadTimeout</code>和<code>WriteTimeout</code>,像上面的例子中一样使用相应的方法。</p>
<h4 id="关于流">关于流</h4>
<p>令人心塞的是， 没有办法从<code>ServeHTTP</code>中访问底层的<code>net.Conn</code>，所以提供流服务强制不去设置<code>WriteTimeout</code>（这也可能是为什么这些值的默认值总为0）。如果无法访问<code>net.Conn</code>就不能在每次<code>Write</code>的时候调用<code>SetWriteDeadline</code>来实现一个正确的idle timeout。</p>
<p>而且，也没有办法取消一个阻塞的<code>ResponseWriter.Write</code>，因为<code>ResponseWriter.Close</code>没有文档指出它可以取消一个阻塞并发写。也没有办法使用Timer创建以俄国手工的timeout 杯具就是流服务器不能对于慢读的客户端进行防护。我提交的了一个［bug](<a href="https://github.com/golang/go/issues/16100)，欢迎大家反馈。" target="_blank" rel="external">https://github.com/golang/go/issues/16100)，欢迎大家反馈。</a></p>
<blockquote>
<p><em>编者按</em>: 作者此处的说法是有问题的，可以通过Hijack获取net.Conn,既然可以可以获取net.Conn,我们就可以调用它的SetWriteDeadline方法。代码例子如下：</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net/http"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	http.HandleFunc(<span class="string">"/hijack"</span>, <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request) {</div><div class="line">		hj, ok := w.(http.Hijacker)</div><div class="line">		<span class="keyword">if</span> !ok {</div><div class="line">			http.Error(w, <span class="string">"webserver doesn't support hijacking"</span>, http.StatusInternalServerError)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line">		conn, bufrw, err := hj.Hijack()</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			http.Error(w, err.Error(), http.StatusInternalServerError)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line">		<span class="comment">// Don't forget to close the connection:</span></div><div class="line">		<span class="keyword">defer</span> conn.Close()</div><div class="line"></div><div class="line">		conn.SetWriteDeadline(time.Now().Add<span class="number">(10</span> * time.Second))</div><div class="line"></div><div class="line">		bufrw.WriteString(<span class="string">"Now we're speaking raw TCP. Say hi: "</span>)</div><div class="line">		bufrw.Flush()</div><div class="line">		s, err := bufrw.ReadString(<span class="string">'\n'</span>)</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Printf(<span class="string">"error reading string: %v"</span>, err)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line">		fmt.Fprintf(bufrw, <span class="string">"You said: %q\nBye.\n"</span>, s)</div><div class="line">		bufrw.Flush()</div><div class="line">	})</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="客户端超时设置">客户端超时设置</h3>
<p><img src="client-timeout.png" alt=""></p>
<p>Client端的超时设置说复杂也复杂，说简单也简单，看你怎么用了，最重要的就是不要有资源泄漏的情况或者程序被卡住。</p>
<p>最简单的方式就是使用<code>http.Client</code>的 <code>Timeout</code>字段。 它的时间计算包括从连接(Dial)到读完response body。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">c := &http.Client{  </div><div class="line">    Timeout:<span class="number"> 15</span> * time.Second,</div><div class="line">}</div><div class="line">resp, err := c.Get(<span class="string">"https://blog.filippo.io/"</span>)</div></pre></td></tr></table></figure>

<p>就像服务器端一样，<code>http.GET</code>使用Client的时候也<a href="https://golang.org/pkg/net/http/#DefaultClient" target="_blank" rel="external">没有超时设置</a>,所以在互联网上使用也很危险。</p>
<p>有一些更细粒度的超时控制：</p>
<ul>
<li><code>net.Dialer.Timeout</code> 限制建立TCP连接的时间</li>
<li><code>http.Transport.TLSHandshakeTimeout</code> 限制 TLS握手的时间</li>
<li><code>http.Transport.ResponseHeaderTimeout</code> 限制读取response header的时间</li>
<li><code>http.Transport.ExpectContinueTimeout</code> 限制client在发送包含 <code>Expect: 100-continue</code>的header到收到继续发送body的response之间的时间等待。注意在1.6中设置这个值会<a href="https://github.com/golang/go/issues/14391" target="_blank" rel="external">禁用HTTP/2</a>(<code>DefaultTransport</code>自1.6.2起是个特例)</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">c := &http.Client{  </div><div class="line">    Transport: &Transport{</div><div class="line">        Dial: (&net.Dialer{</div><div class="line">                Timeout:  <span class="number"> 30</span> * time.Second,</div><div class="line">                KeepAlive:<span class="number"> 30</span> * time.Second,</div><div class="line">        }).Dial,</div><div class="line">        TLSHandshakeTimeout:  <span class="number"> 10</span> * time.Second,</div><div class="line">        ResponseHeaderTimeout:<span class="number"> 10</span> * time.Second,</div><div class="line">        ExpectContinueTimeout:<span class="number"> 1</span> * time.Second,</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如我所讲，没有办法限制发送request的时间。读取response body (原文是读取request body，按照理解应该是读取response可以手工控制)的时间花费可以手工的通过一个<code>time.Timer</code>来实现, 读取发生在调用Client.Do之后（详见下一节）。</p>
<p>最后将一点，在Go 1.7中，增加了一个<code>http.Transport.IdleConnTimeout</code>， 它不控制client request的阻塞阶段，但是可以控制连接池中一个连接可以idle多长时间。</p>
<p>注意一个Client缺省的可以执行 <em>redirect</em>。<code>http.Client.Timeout</code>包含所有的<code>redirect</code>，而细粒度的超时控制参数只针对单次请求有效， 因为<code>http.Transport</code>是一个底层的类型，没有<code>redirect</code>的概念。</p>
<h3 id="Cancel_和_Context">Cancel 和 Context</h3>
<p><code>net/http</code>提供了两种方式取消一个client的请求: <code>Request.Cancel</code>以及Go 1.7新加的<code>Context</code>。</p>
<p><code>Request.Cancel</code>是一个可选的channel, 当设置这个值并且close它的时候，request就会终止，就好像超时了一样(实际它们的实现是一样的，在写本文的时候我还发现一个1.7 的 一个<a href="https://github.com/golang/go/issues/16094" target="_blank" rel="external">bug</a>, 所有的cancel操作返回的错误还是timeout error )。</p>
<p>我们可以使用<code>Request.Cancel</code>和<code>time.Timer</code>来构建一个细粒度的超时控制，允许读取流数据的时候推迟deadline:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"io"</span></div><div class="line">    <span class="string">"io/ioutil"</span></div><div class="line">    <span class="string">"log"</span></div><div class="line">    <span class="string">"net/http"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{})</div><div class="line">    timer := time.AfterFunc<span class="number">(5</span>*time.Second, <span class="keyword">func</span>() {</div><div class="line">        <span class="built_in">close</span>(c)</div><div class="line">    })</div><div class="line"></div><div class="line">        <span class="comment">// Serve 256 bytes every second.</span></div><div class="line">    req, err := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"http://httpbin.org/range/2048?duration=8&chunk_size=256"</span>, <span class="constant">nil</span>)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        log.Fatal(err)</div><div class="line">    }</div><div class="line">    req.Cancel = c</div><div class="line"></div><div class="line">    log.Println(<span class="string">"Sending request..."</span>)</div><div class="line">    resp, err := http.DefaultClient.Do(req)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        log.Fatal(err)</div><div class="line">    }</div><div class="line">    <span class="keyword">defer</span> resp.Body.Close()</div><div class="line"></div><div class="line">    log.Println(<span class="string">"Reading body..."</span>)</div><div class="line">    <span class="keyword">for</span> {</div><div class="line">        timer.Reset<span class="number">(2</span> * time.Second)</div><div class="line">                <span class="comment">// Try instead: timer.Reset(50 * time.Millisecond)</span></div><div class="line">        _, err = io.CopyN(ioutil.Discard, resp.Body,<span class="number"> 256</span>)</div><div class="line">        <span class="keyword">if</span> err == io.EOF {</div><div class="line">            <span class="keyword">break</span></div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">            log.Fatal(err)</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的例子中我们为Do方法执行阶段设置5秒的超时，但是我们至少花费8秒执行8次才能读完所欲的body，每一次设置2秒的超时。我们可以为流 API这样处理避免程序死在那里。 如果超过两秒我们没有从服务器读取到数据， io.CopyN会返回<code>net/http: request canceled</code>错误。</p>
<p>在1.7中， context包升级了，进入到标准库中。Context有很多<a href="https://blog.golang.org/context" target="_blank" rel="external">值得学习的功能</a>，但是对于本文介绍的内容来讲，你只需直到它可以用来替换和扔掉<code>Request.Cancel</code>。</p>
<p>用Context取消请求很简单，我们只需得到一个新的Context和它的cancel()函数，这是通过context.WithCancel方法得到的，然后创建一个request并使用<code>Request.WithContext</code>绑定它。当我们想取消这个请求是，我们调用<code>cancel()</code>取消这个Context:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ctx, cancel := context.WithCancel(context.TODO())  </div><div class="line">timer := time.AfterFunc<span class="number">(5</span>*time.Second, <span class="keyword">func</span>() {  </div><div class="line">    cancel()</div><div class="line">})</div><div class="line"></div><div class="line">req, err := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"http://httpbin.org/range/2048?duration=8&chunk_size=256"</span>, <span class="constant">nil</span>)  </div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {  </div><div class="line">    log.Fatal(err)</div><div class="line">}</div><div class="line">req = req.WithContext(ctx)</div></pre></td></tr></table></figure>

<p>Context好处还在于如果parent context被取消的时候(在<code>context.WithCancel</code>调用的时候传递进来的)，子context也会取消， 命令会进行传递。</p>
<p>好了，这就是本文要讲的全部，希望我没有超过你的阅读deadline。</p>
<p><a href="https://www.cloudflare.com/join-our-team/" target="_blank" rel="external">作者的公司cloudflare在英国、美国和新加坡招人</a>。云初创公司，挺知名。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>英文原始出处: <a href="https://blog.cloudflare.com/the-complete-guide-to-golang-net-http-timeouts/" target="_blank" rel="external">The complete guide to Go net/http timeouts</a>, 作者: <a href="https://blog.cloudflare.com/author/filippo/" target="_blank" rel="external">Filippo Valsorda</a></p>
<p>当用Go写HTTP的服务器和客户端的时候，超时处理总是最易犯错和最微妙的地方之一。错误可能来自很多地方，一个错误可能等待很长时间没有结果，直到网络故障或者进程挂起。</p>
<p>HTTP是一个复杂的、多阶段(multi-stage)协议，所以没有一个放之四海而皆准的超时解决方案，比如一个流服务、一个JSON API和一个Comet服务对超时的需求都不相同， 往往默认值不是你想要的。</p>
<p>本文我将拆解需要超时设置的各个阶段，看看用什么不同的方式去处理它， 包括服务器端和客户端。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go语言 - 10]]></title>
    <link href="http://colobu.com/2016/06/30/dive-into-go-10/"/>
    <id>http://colobu.com/2016/06/30/dive-into-go-10/</id>
    <published>2016-06-30T02:57:02.000Z</published>
    <updated>2016-06-30T10:31:21.000Z</updated>
    <content type="html"><![CDATA[<p>本章介绍Go如何调用C代码，以及如何调用动态链接库。</p>
<p>如果你正准备使用Go开发你的程序，或者你正将一个C构建的项目转换成Go项目，请尽量使用Go构建你的项目，而不是偷巧的导入C代码，尽量保持Go项目的纯粹，原因可以查看<a href="http://www.oschina.net/translate/cgo-is-not-go" target="_blank" rel="external">cgo 和 Go 语言是两码事</a>,文末的参考文档中也有这篇文章的原始英文。</p>
<p>但是，有些情况下，我们不得不使用C代码构建，那么我们就可以使用cgo技术。</p>
<a id="more"></a>
<h3 id="Go代码调用C函数">Go代码调用C函数</h3>
<p>cgo可以让Go代码调用C代码。</p>
<p>C代码被封装进“package C”中，你可以访问C实现的类型<code>C.size_t</code>、 变量<code>C.stdout</code> 和 方法<code>C.putchar</code>,即使它们的首字母是小写的。</p>
<p>在代码<code>import &quot;C&quot;</code>之前有注释(紧接着这个import),那么这个注释称之为<code>preamble</code>(序言、开场白)。它可以包含编译C package的头文件:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">*/</div><div class="line"><span class="keyword">import</span> <span class="string">"C"</span></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	C.srandom(C.<span class="typename">uint</span>(time.Now().UTC().UnixNano()))</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		fmt.Printf(<span class="string">"%d "</span>, <span class="typename">int</span>(C.random()))</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>preamble还可以包含C代码，你可以在C代码中定义变量和函数，它们可以在Go代码中通过包C来引用。C代码中的静态变量不能在G中使用，但是静态函数可以。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cgoexample</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">void myprint(char* s) {</div><div class="line">    printf("%s\n", s);</div><div class="line">}</div><div class="line">*/</div><div class="line"><span class="keyword">import</span> <span class="string">"C"</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"unsafe"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> Example() {</div><div class="line">    cs := C.CString(<span class="string">"Hello from stdio\n"</span>)</div><div class="line">    C.myprint(cs)</div><div class="line">    C.free(unsafe.Pointer(cs))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>你可以在Go官方代码库中看到这样的例子， 比如<a href="https://github.com/golang/go/tree/master/misc/cgo/stdio" target="_blank" rel="external">misc/cgo/stdio</a>。</p>
<p>工具<a href="https://golang.org/cmd/cgo/" target="_blank" rel="external">cmd/tool</a>将包含导入包C的Go文件转换成几个Go文件和C文件。如果你运行<code>go tool cgo main1.go</code>转换上面的例子，你会发现在本地文件夹下生成了一个_obj的文件夹：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">smallnestMBP:ch9 smallnest$ ls _obj/</div><div class="line">_cgo_.o         _cgo_export.h   _cgo_gotypes.go main1.cgo1.go</div><div class="line">_cgo_export.<span class="built_in">c</span>   _cgo_flags      _cgo_main.<span class="built_in">c</span>     main1.cgo2.<span class="built_in">c</span></div></pre></td></tr></table></figure>

<p>它会包含一个编译器在编译这些C文件后生成的目标文件<em>cgo</em>.o。</p>
<p>在实际开发中，我们不会直接调用cgo工具，因为<code>go build</code>会自动完成这一切，让我们编译这个程序<code>go build main1.go</code>或者直接运行<code>go run main1.go</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">smallnestMBP:ch9 smallnest$ <span class="keyword">go</span> run main1.<span class="keyword">go</span><span class="number"></span></div><div class="line">991076780<span class="number"> 1985136578</span><span class="number"> 1492569085</span><span class="number"> 555504684</span><span class="number"> 104261718</span><span class="number"> 1646436258</span><span class="number"> 1683793209</span><span class="number"> 1521143308</span><span class="number"> 547922631</span><span class="number"> 1875795366</span></div></pre></td></tr></table></figure>

<p>这是引用C的标准库,我们不需要额外的编译参数设置，要引入特定的库，我们还需要设置一些额外的参数。</p>
<p>我们可以使用<code>#cgo</code>指令符(directive)为C/C++编译器提供 <strong>CFLAGS</strong>、 <strong>CPPFLAGS</strong>、<strong>CXXFLAGS</strong> 和 <strong>LDFLAGS</strong> 设置,同时也可以提供一些编译的<a href="https://golang.org/pkg/go/build/#hdr-Build_Constraints" target="_blank" rel="external">约束</a>，比如为特定的平台的参数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// #cgo CFLAGS: -DPNG_DEBUG=1</span></div><div class="line"><span class="comment">// #cgo amd64 386 CFLAGS: -DX86=1</span></div><div class="line"><span class="comment">// #cgo LDFLAGS: -lpng</span></div><div class="line"><span class="comment">// #include &lt;png.h&gt;</span></div><div class="line"><span class="keyword">import</span> <span class="string">"C"</span></div></pre></td></tr></table></figure>

<p>开发C/C++程序的程序员和经常使用make工具链的开发者应该对这些参数很熟悉了， flags给编译器提供开关，比如指定头文件的位置等， ldflags提供链接选项，比如提供库的位置。</p>
<p><code>CFLAGS</code> 用来给 <strong>C</strong> 编译器提供开关。<br><code>CXXFLAGS</code> 用来给 <strong>C++</strong> 编译器提供开关。<br><code>CPPFLAGS</code> 用来给C预处理提供开关，对 <strong>C</strong> / <strong>C++</strong> 都有效。<br><code>LDFLAGS</code> 用来指定链接选项,比如链接库的位置，以及使用哪些链接库。</p>
<p>我们在编译C文件的时候，一般会经过四个步骤： 预处理、编译、汇编和链接，你可以看到这些开发参数的用处:</p>
<figure class="highlight make"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 预处理</span></div><div class="line">$(CC) $(CPPFLAGS) $(CFLAGS) -E main.c  -o main.i</div><div class="line"></div><div class="line"><span class="comment">// 编译</span></div><div class="line">$(CC) $(CPPFLAGS) $(CFLAGS) -S main.i  -o main.s</div><div class="line"></div><div class="line"><span class="comment">// 汇编， "-c"选项表示不执行链接步骤</span></div><div class="line">$(CC) $(CPPFLAGS) $(CFLAGS) -c main.s  -o main.o</div><div class="line"></div><div class="line"><span class="comment">// 也可以将前面的三个步骤合起来(预处理,编译,汇编)</span></div><div class="line">$(CC) $(CPPFLAGS) $(CFLAGS) -c main.c -o main.o</div><div class="line"></div><div class="line"><span class="comment">// 然后将目标文件链接为最终的结果</span></div><div class="line">$(CC) $(LDFLAGS) main.o   -o main</div><div class="line"></div><div class="line"><span class="comment">// 也可以一次完成上面的步骤。</span></div><div class="line">$(CC) $(CPPFLAGS) $(CFLAGS) $(LDFLAGS) main.c   -o main</div></pre></td></tr></table></figure>

<p>gcc可用的开关可以查看它的文档: <a href="https://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC" target="_blank" rel="external">Invoking-GCC</a>。</p>
<p><code>CPPFLAGS</code>、<code>LDFLAGS</code>可以通过 <strong>pkg-config</strong> 工具获得：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// #cgo pkg-config: png cairo</span></div><div class="line"><span class="comment">// #include &lt;png.h&gt;</span></div><div class="line"><span class="keyword">import</span> <span class="string">"C"</span></div></pre></td></tr></table></figure>

<p>编译的时候，四个环境变量会增加它们的flag到编译参数中，这适合设置通用的，包无关的编译参数。</p>
<p>还有一个变量 ${SRCDIR} 用来指代原文件所在的文件夹的绝对路径，这允许你将预先编译好的静态库放在本地文件夹中，让编译器可以找到这些库以便正确的链接。比如包foo在文件夹/go/src/foo下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// #cgo LDFLAGS: -L${SRCDIR}/libs -lfoo</span></div></pre></td></tr></table></figure>

<p>上面的指令等价于:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// #cgo LDFLAGS: -L/go/src/foo/libs -lfoo</span></div></pre></td></tr></table></figure>

<p>可以看一个使用libsqlite3库的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">#cgo pkg-config: sqlite3</div><div class="line"></div><div class="line">#include &lt;sqlite3.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">*/</div><div class="line"><span class="keyword">import</span> <span class="string">"C"</span></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Conn <span class="keyword">struct</span> {</div><div class="line">	db *C.sqlite3</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> c Conn</div><div class="line">	fmt.Println(c.db)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>实际上，你不使用<code>#cgo pkg-config: sqlite3</code>也可以，因为在我们的机器上(Mac OS X)，libsqlite3被安装在标准的路径中，库在/usr/lib中，头文件安装在/usr/include文件下，如果你为PKG_CONFIG_PATH指定了特殊的文件夹，你可以使用这个指令:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">smallnestMBP:ch9 smallnest$ pkg-config --libs --cflags protobuf</div><div class="line">-D_THREAD_SAFE -I<span class="regexp">/usr/</span>local<span class="regexp">/Cellar/</span>protobuf<span class="regexp">/2.6.1/i</span>nclude -L<span class="regexp">/usr/</span>local<span class="regexp">/Cellar/</span>protobuf<span class="regexp">/2.6.1/</span>lib -lprotobuf -D_THREAD_SAFE</div></pre></td></tr></table></figure>

<p>当Go工具访问一个或者多个Go文件导入包C的时候， 它也会查找其它的非Go的文件并把它们编译到Go包中 以 <code>.c</code>, <code>.s</code>, <code>.S</code>结尾的C文件或者汇编文件使用C编译器编译，以<code>.cc</code>, <code>.cpp</code>, <code>.cxx</code>结尾的文件以C++编译器编译以<code>.h</code>, <code>.hh</code>, <code>.hpp</code>, <code>.hxx</code>文件不会独立编译，但是这些头文件如果有改动，相应的C和C++文件会重新被编译。默认的C和C++编译器可以通过CC 和 CXX 环境变量改变。</p>
<p>所以文件夹下的汇编语言也可以被编译。</p>
<p>交叉编译的时候cgo被禁止，如果想启用，设置CGO_ENABLED＝1。还需要额外的设置，比如C交叉编译器。</p>
<p>下面以一个计算圆周率的前1000位的例子看看我们自己实现的C库如何被我们的 Go代码实现 (假定所有的文件都在同一个文件夹下，这样编译和使用动态库时比较方便)：<br>首先是计算Pi的C代码 <code>pi.c</code>，函数calc用来计算Pi的值，返回结果是一个C的字符串：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> a=<span class="number">10000</span>, b, c=<span class="number">2800</span>, d, e, f[<span class="number">2801</span>], g,i;</div><div class="line"><span class="keyword">char</span> r[<span class="number">1000</span>];</div><div class="line"><span class="keyword">char</span>* pr = r;</div><div class="line"></div><div class="line"><span class="keyword">char</span>* calc() {</div><div class="line">	<span class="keyword">for</span>(;b-c;)</div><div class="line">	f[b++]=a/<span class="number">5</span>;</div><div class="line">	<span class="comment">//for(;d=0,g=c*2;c-=14,printf("%.4d",e+d/a),e=d%a)</span></div><div class="line">	<span class="keyword">for</span>(;d=<span class="number">0</span>,g=c*<span class="number">2</span>;c-=<span class="number">14</span>,<span class="built_in">sprintf</span>(pr,<span class="string">"%.4d"</span>,e+d/a),pr +=<span class="number">4</span>,e=d%a)</div><div class="line">	<span class="keyword">for</span>(b=c;d+=f[b]*a,f[b]=d%--g,d/=g--,--b;d*=b);</div><div class="line">	<span class="keyword">return</span> r;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>编译成动态库:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -shared <span class="operator">-f</span>PIC -olibpi.dylib pi.c</div></pre></td></tr></table></figure>

<p>定义一个头文件<code>pi.h</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span>* calc();</div></pre></td></tr></table></figure>

<p>我们可以写一个C程序 <code>test.c</code> 调用这个动态库，测试一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "pi.h"</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, calc());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>编译执行一下，确保动态库没有问题:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -L. -I. -lpi <span class="keyword">test</span>.c  -o <span class="keyword">test</span></div></pre></td></tr></table></figure>

<p>现在就可以在Go代码中使用这个库了。写一个Go文件 <code>main3.go</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">#cgo CFLAGS: -I${SRCDIR}</div><div class="line">#cgo LDFLAGS: -L${SRCDIR} -lpi</div><div class="line"></div><div class="line">#include "pi.h"</div><div class="line">*/</div><div class="line"><span class="keyword">import</span> <span class="string">"C"</span></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	fmt.Println(<span class="string">"计算PI值:"</span>)</div><div class="line">	v := C.GoString(C.calc())</div><div class="line">	fmt.Println(v)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>编译：<code>go build main3.go</code>,因为动态库和生成的可执行文件<code>main3</code>在同一个目录下，没有问题，执行main3:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">smallnestMBP:</span>ch9 smallnest<span class="variable">$ </span>./main3</div><div class="line">计算<span class="constant">PI</span>值<span class="symbol">:</span></div><div class="line"><span class="number">31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185</span></div></pre></td></tr></table></figure>

<p>上面这个计算Pi的例子我们将C的字符串转换成Go的字符串。 cgo定义了Go和C之间的类型对应关系。</p>
<ul>
<li>如果C的struct的字段类型是Go的关键字,如<code>type</code>, 那么在Go代码中可以在字段前加关键字如<code>x._type</code></li>
<li>C中的整数类型已经在包C中定义，如<code>C.char</code>、<code>C.short</code>、<code>C.ushort</code>、<code>C.int</code>、<code>C.uint</code>、<code>C.longlong</code>、<code>C.float</code>,不一一列举，请看参考文档1</li>
<li>访问C的<code>struct</code>、<code>union</code>、<code>enum</code>类型需要加类型前缀<code>struct_</code>、<code>union_</code>、<code>enum_</code>，如C.struct_stat</li>
<li>访问C中的类型T的size用 C.sizeof_T，如C.sizeof_struct_stat</li>
<li>Go不支持C的union的概念，只是把它作为相同长度的字节数组</li>
<li>Go的Struct不能嵌入C的类型</li>
<li>Go的API不应该再暴露C的类型给外部</li>
<li>调用C的函数可以进行多值赋值，一个值作为返回值，一个作为errno</li>
<li>当前不支持C的函数指针</li>
<li>C中参数是固定长度的数组，可以把数组名传递给函数，但是Go代码调用中必须显示地将指针指向数组的第一个元素,如C.f(&amp;C.x[0])</li>
</ul>
<p>对应的类型转换：</p>
<pre class="highlight">
char -->  C.char -->  byte
signed char -->  C.schar -->  int8
unsigned char -->  C.uchar -->  uint8
short int -->  C.short -->  int16
short unsigned int -->  C.ushort -->  uint16
int -->  C.int -->  int
unsigned int -->  C.uint -->  uint32
long int -->  C.long -->  int32 or int64
long unsigned int -->  C.ulong -->  uint32 or uint64
long long int -->  C.longlong -->  int64
long long unsigned int -->  C.ulonglong -->  uint64
float -->  C.float -->  float32
double -->  C.double -->  float64
wchar_t -->  C.wchar_t  -->  
void * -> unsafe.Pointer
</pre>

<p>项目<a href="https://github.com/giorgisio/cgo" target="_blank" rel="external">giorgisio/cgo</a>提供了一些Go调用C代码各种类型的例子。</p>
<h3 id="调用动态链接库">调用动态链接库</h3>
<p>对于Windows环境，Go提供了直接加载动态链接库的方法。 首先syscall包下实现了<code>LoadDLL</code>、<code>FindProc</code>、<code>Release</code>方法，可以加载动态链接库以及得到相应的函数。</p>
<p>另外包<code>golang.org/x/sys/windows</code>提供了更多的方法，如<code>LoadLibrary</code>、<code>LoadLibraryEx</code>、 <code>DLL</code>、 <code>LazyDLL</code>等方法和类型。</p>
<p>举个栗子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">h, err := windows.LoadLibrary(<span class="string">"kernel32.dll"</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    abort(<span class="string">"LoadLibrary"</span>, err)</div><div class="line">}</div><div class="line"><span class="keyword">defer</span> windows.FreeLibrary(h)</div><div class="line">proc, err := windows.GetProcAddress(h, <span class="string">"GetVersion"</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    abort(<span class="string">"GetProcAddress"</span>, err)</div><div class="line">}</div><div class="line">r, _, _ := syscall.Syscall(<span class="typename">uintptr</span>(proc),<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>)</div><div class="line">major := <span class="typename">byte</span>(r)</div><div class="line">minor := <span class="typename">uint8</span>(r &gt;&gt;<span class="number"> 8</span>)</div><div class="line">build := <span class="typename">uint16</span>(r &gt;&gt;<span class="number"> 16</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"windows version "</span>, major, <span class="string">"."</span>, minor, <span class="string">" (Build "</span>, build, <span class="string">")\n"</span>)</div></pre></td></tr></table></figure>

<p>其它平台我还没有发现官方的调用.so或者.dylib的方法， 但是我看到有第三方的作者写了相应的库，提供类似C中的dlopen和dlsym方法：<br><a href="https://github.com/rainycape/dl" target="_blank" rel="external">Runtime dynamic library loader</a></p>
<p>还有<a href="https://bitbucket.org/binet/go-ffi" target="_blank" rel="external">go-ffi</a>,也提供了dlopen和dlsym的功能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// dl-open a library: here, libm on macosx</span></div><div class="line">lib, err := ffi.NewLibrary(<span class="string">"libm.dylib"</span>)</div><div class="line">handle_err(err)</div><div class="line"></div><div class="line"><span class="comment">// get a handle to 'cos', with the correct signature</span></div><div class="line">cos, err := lib.Fct(<span class="string">"cos"</span>, ffi.Double, []Type{ffi.Double})</div><div class="line">handle_err(err)</div><div class="line"></div><div class="line"><span class="comment">// call it</span></div><div class="line">out := cos<span class="number">(0</span>.).Float()</div><div class="line"><span class="built_in">println</span>(<span class="string">"cos(0.)="</span>, out)</div><div class="line"></div><div class="line">err = lib.Close()</div><div class="line">handle_err(err)</div></pre></td></tr></table></figure>

<p>参考</p>
<ul>
<li><a href="https://golang.org/cmd/cgo/" target="_blank" rel="external">https://golang.org/cmd/cgo/</a></li>
<li><a href="https://github.com/golang/go/wiki/cgo" target="_blank" rel="external">https://github.com/golang/go/wiki/cgo</a></li>
<li><a href="http://akrennmair.github.io/golang-cgo-slides/#1" target="_blank" rel="external">http://akrennmair.github.io/golang-cgo-slides/#1</a></li>
<li><a href="http://dave.cheney.net/2016/01/18/cgo-is-not-go" target="_blank" rel="external">http://dave.cheney.net/2016/01/18/cgo-is-not-go</a></li>
<li><a href="http://dominik.honnef.co/posts/2015/06/statically_compiled_go_programs__always__even_with_cgo__using_musl/" target="_blank" rel="external">http://dominik.honnef.co/posts/2015/06/statically_compiled_go_programs__always__even_with_cgo__using_musl/</a></li>
<li><a href="http://blog.giorgis.io/cgo-examples" target="_blank" rel="external">http://blog.giorgis.io/cgo-examples</a></li>
<li><a href="http://blog.madewithdrew.com/post/statically-linking-c-to-go/" target="_blank" rel="external">http://blog.madewithdrew.com/post/statically-linking-c-to-go/</a></li>
<li><a href="https://github.com/hyper-carrot/go_command_tutorial/blob/master/0.13.md" target="_blank" rel="external">https://github.com/hyper-carrot/go_command_tutorial/blob/master/0.13.md</a></li>
<li><a href="https://www.goinggo.net/2013/08/using-c-dynamic-libraries-in-go-programs.html" target="_blank" rel="external">https://www.goinggo.net/2013/08/using-c-dynamic-libraries-in-go-programs.html</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>本章介绍Go如何调用C代码，以及如何调用动态链接库。</p>
<p>如果你正准备使用Go开发你的程序，或者你正将一个C构建的项目转换成Go项目，请尽量使用Go构建你的项目，而不是偷巧的导入C代码，尽量保持Go项目的纯粹，原因可以查看<a href="http://www.oschina.net/translate/cgo-is-not-go" target="_blank" rel="external">cgo 和 Go 语言是两码事</a>,文末的参考文档中也有这篇文章的原始英文。</p>
<p>但是，有些情况下，我们不得不使用C代码构建，那么我们就可以使用cgo技术。</p>
]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go语言 - 9]]></title>
    <link href="http://colobu.com/2016/06/29/dive-into-go-9/"/>
    <id>http://colobu.com/2016/06/29/dive-into-go-9/</id>
    <published>2016-06-29T08:03:25.000Z</published>
    <updated>2016-06-30T02:36:27.000Z</updated>
    <content type="html"><![CDATA[<p>本章介绍Go语言的其它部分，算是Go语言规范的深入学习的收尾工作。</p>
<a id="more"></a>
<h3 id="内建函数">内建函数</h3>
<p>前面几章我们已经认识了几个内建的函数，这里我们将所有的内建函数罗列一下。</p>
<p>如果你查看它们的定义的话，你可以访问<a href="https://golang.org/src/builtin/builtin.go" target="_blank" rel="external">builtin/builtin.go</a>,但这些内建的函数只有声明，没有方法体，它们不是标准的Go类型，你不能把它们作为函数值进行参数传递，只能出现在调用表达式中。事实上这些内建类型并不真的在builtin包中，只是为了生成文档的需要。</p>
<p>你可以在任意的包中调用这些内建函数，不必引入特定的包如&quot;builtin&quot;。</p>
<p>1、<strong>close</strong>: 关闭channel<br>2、<strong>len(s)</strong>:得到字符串、数组、数值指针、slice、map、chan的长度<br>3、<strong>cap(s)</strong>:得到数组、数组指针的长度，得到slice、channel的容量<br>4、<strong>new(T)</strong>: 生成类型T的零值指针,注意它返回的是指针 *T<br>5、<strong>make</strong>: 生成slice、map、channel对象</p>
<pre class="highlight">
调用              类型 T     结果

make(T, n)       slice      slice of type T with length n and capacity n
make(T, n, m)    slice      slice of type T with length n and capacity m

make(T)          map        map of type T
make(T, n)       map        map of type T,初始可以容纳 n 元素的空间

make(T)          channel    不带缓存的channel of type T,比如我们在声明信号channel的时候
make(T, n)       channel    带缓存的 channel of type T, 缓存大小为 n
</pre>

<p>6、<strong>append(s S, x ...T) S</strong>: 增加0到n个元素到slice中，返回新的slice<br>7、<strong>copy(dst, src []T) int</strong>: 复制源src slice的元素到目标dst slice中,返回复制的元素的数量n, n是src和dst长度的最小值。字符串也可以作为src,但是T的类型必须是byte<br>8、<strong>delete(m,k)</strong>: 删除map中的一个映射， m为nil或者m[k]不存在也不会panic,而是一个空操作<br>9、<strong>complex</strong>、<strong>real</strong>、<strong>imag</strong>: 复数操作<br>10、<strong>panic</strong>、<strong>recover</strong>: 报告panic和处理panic,后面讲<br>11、<strong>print</strong>、<strong>println</strong>: 尽量不用这两个函数，因为保证将来它们还会留在Go语言中，使用fmt.Print、fmt.Println</p>
<h3 id="包">包</h3>
<p>Go的代码文件中都会有包(package)的定义，在import声明的前面。</p>
<p>同一个文件夹下的所有的文件都要使用同一个包名(当然，你如果单独编译每一个文件的话，可以不遵守，但是要编译整个项目，必须遵守)。</p>
<p>但是测试文件可以叫另外的包名，比如正常代码的包名为&quot;package abc&quot;,测试代码和示例代码的包名为&quot;package abc_test&quot;. Go标准库中混用了这两种风格。</p>
<p><code>main</code>包是一个特殊的包，必须声明一个main函数，main函数无参数，无返回值，它用来创建可执行程序。</p>
<p>包名不一定和文件夹的名字保持一致，经常我们的项目的名称很长，不太适合做包名，所以包名可以用一个简短的名称，但是如果可能，尽量用一样的名字，这样在下载库的时候就能直到包的名字了。</p>
<h3 id="import">import</h3>
<p>import用来引入所需要的类型，允许你访问另外的包中的导出类型。</p>
<p>以下四种形式都是可以接受的mport:</p>
<pre class="highlight">
Import declaration          Local name of Sin

import   "lib/math"         math.Sin
import m "lib/math"         m.Sin
import . "lib/math"         Sin
import _ "lib/math"
</pre>

<p>为了避免同名的包名冲突，你可以为导入的包名起一个名字，比如上例中的&quot;m&quot;。<br>你也可以使用<code>.</code>,这样无需包名标识符，可以直接使用这个包下的导出类型。<br>最后一个情况是使用空标识符，主要是想利用包的初始化，而不是使用它的导出类型。</p>
<p>import不能导入包自己，不管是直接的还是间接的(循环引用)。你也不能直接导入一个包而不使用它的导出类型，所幸一些工具可以自动帮我们修正import的错误，或者自动帮我们导入，比如<a href="https://github.com/bradfitz/goimports" target="_blank" rel="external">goimports</a>。</p>
<p>import可以导入相对路径，如&quot;import \&quot;../foo/bar\&quot;&quot;,但是强烈你不要这么做，这不是常用的导入风格。</p>
<p>import可以用小括号括起来导入多个包。</p>
<h3 id="包的初始化">包的初始化</h3>
<p>包变量的初始化顺序和它们声明的顺序一致，但是也得考虑它们的依赖。<br>循环依赖初始化也不可以：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> abc</div><div class="line"></div><div class="line"><span class="keyword">var</span> i <span class="typename">int</span> = j</div><div class="line"><span class="keyword">var</span> j <span class="typename">int</span> = k</div><div class="line"><span class="keyword">var</span> k <span class="typename">int</span> = i</div></pre></td></tr></table></figure>

<p>包变量的初始化之后可以调用一个init函数实现其它的初始化过程，你可以显示地定义这个函数，它可以出现在同一个包下的多个文件中，执行的顺序由编译器决定。<br>如果包导入了其它包，则导入的包会先初始化。如果多个包都导入同一个包，则导入的包只被初始化一次。</p>
<h3 id="error、panic和recover">error、panic和recover</h3>
<p>Go预定义了<code>error</code>类型，虽然它的首字母不是大写的，但是确可以在任何包下使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> {</div><div class="line">	Error() <span class="typename">string</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>而errors包定义了生成简单Error的方法<code>errors.New(text String) error</code>。如果你想自定义Error类型，你可以实现error接口。</p>
<p>运行时Error，比如数组索引越界会触发一个运行时的panic，它等价调用panic函数，panic的值是一个runtime.Error:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> runtime</div><div class="line"></div><div class="line"><span class="keyword">type</span> Error <span class="keyword">interface</span> {</div><div class="line">	error</div><div class="line">	<span class="comment">// and perhaps other methods</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>而panic的处理是在一个defer函数中执行的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">		fmt.Println(<span class="string">"foo"</span>)</div><div class="line">	}()</div><div class="line">	<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="constant">nil</span> {</div><div class="line">			fmt.Println(x)</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">		fmt.Println(<span class="string">"bar"</span>)</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="built_in">panic</span>(<span class="string">"trigger panic"</span>)</div><div class="line">  fmt.Println(<span class="string">"end"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意defer的执行顺序，前面已经讲过，和它们声明的顺序相反，所以输出结果为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">bar</span></div><div class="line">trigger panic</div><div class="line">foo</div></pre></td></tr></table></figure>

<p>最后一句没有机会继续执行，因为recover执行完后函数就终止了。<br>这带来一个问题，如果函数有返回值，recover后函数的返回值是什么？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	i := z()</div><div class="line">	fmt.Println(i)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> z() <span class="typename">int</span> {</div><div class="line">	<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">		fmt.Println(<span class="string">"foo"</span>)</div><div class="line">	}()</div><div class="line">	<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="constant">nil</span> {</div><div class="line">			fmt.Println(x)</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">		fmt.Println(<span class="string">"bar"</span>)</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="built_in">panic</span>(<span class="string">"trigger panic"</span>)</div><div class="line">	fmt.Println(<span class="string">"end"</span>)</div><div class="line">	<span class="keyword">return</span><span class="number"> 100</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出结果是:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bar</div><div class="line">trigger <span class="built_in">panic</span></div><div class="line">foo<span class="number"></span></div><div class="line">0</div></pre></td></tr></table></figure>

<p>可以函数的返回是返回类型的零值。</p>
<p>当然说零值也不完全正确，如果函数有命名的返回参数，并且命名的返回参数在panic之前赋值了的话，返回的结果还是最后的赋值结果,下面的代码中函数的返回结果为50:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	i := z()</div><div class="line">	fmt.Println(i)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> z() (r <span class="typename">int</span>) {</div><div class="line">	<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">		fmt.Println(<span class="string">"foo"</span>)</div><div class="line">	}()</div><div class="line">	<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="constant">nil</span> {</div><div class="line">			fmt.Println(x)</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">		fmt.Println(<span class="string">"bar"</span>)</div><div class="line">	}()</div><div class="line"></div><div class="line">	r =<span class="number"> 50</span></div><div class="line">	<span class="built_in">panic</span>(<span class="string">"trigger panic"</span>)</div><div class="line">	fmt.Println(<span class="string">"end"</span>)</div><div class="line">	<span class="keyword">return</span><span class="number"> 100</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>panic如果没有处理，会传递给它的调用者，这就是panic的bubble。当然如果可以预见panic,最好的处理方式就是在本函数内进行处理，因为你不能控制外部调用者的行为，而且外部调用者不一定知道会有panic发生：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="constant">nil</span> {</div><div class="line">			fmt.Println(<span class="string">"recover from main:"</span>, x)</div><div class="line">		}</div><div class="line">	}()</div><div class="line"></div><div class="line">	f1()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> f1() {</div><div class="line">	fmt.Println(<span class="string">"start f1"</span>)</div><div class="line">	f2()</div><div class="line">	fmt.Println(<span class="string">"end f1"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> f2() {</div><div class="line">	fmt.Println(<span class="string">"start f2"</span>)</div><div class="line">	f3()</div><div class="line">	fmt.Println(<span class="string">"end f2"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> f3() {</div><div class="line">	fmt.Println(<span class="string">"start f3"</span>)</div><div class="line">	<span class="built_in">panic</span>(<span class="string">"triggered from f3"</span>)</div><div class="line">	fmt.Println(<span class="string">"end f3"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的代码输出:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">start</span> f1</span></div><div class="line"><span class="keyword">start</span> f2</div><div class="line"><span class="keyword">start</span> f3</div><div class="line">recover <span class="keyword">from</span> main: triggered <span class="keyword">from</span> f3</div></pre></td></tr></table></figure>

<p>如果连main都没有 recover，则程序异常退出。</p>
<p>还有一个不太引人注意的地方就是如果在recover中产生panic会怎么样？还是看例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="constant">nil</span> {</div><div class="line">			fmt.Println(<span class="string">"recover from main:"</span>, x)</div><div class="line">		}</div><div class="line">	}()</div><div class="line"></div><div class="line">	f1()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> f1() {</div><div class="line">	<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="constant">nil</span> {</div><div class="line">			fmt.Println(<span class="string">"recover from f1:"</span>, x)</div><div class="line">			<span class="built_in">panic</span>(<span class="string">"triggered from f1"</span>)</div><div class="line">		}</div><div class="line">	}()</div><div class="line"></div><div class="line">	f2()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> f2() {</div><div class="line">	<span class="built_in">panic</span>(<span class="string">"triggered from f2"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>函数f2产生的panic会被函数f1处理， f1在recover的过程中产生一个新的panic,这个panic会把它的调用者main捕获。<br>所以recover产生的panic会往上传递。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本章介绍Go语言的其它部分，算是Go语言规范的深入学习的收尾工作。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go语言 - 8]]></title>
    <link href="http://colobu.com/2016/06/27/dive-into-go-8/"/>
    <id>http://colobu.com/2016/06/27/dive-into-go-8/</id>
    <published>2016-06-27T08:21:43.000Z</published>
    <updated>2016-06-29T09:32:42.000Z</updated>
    <content type="html"><![CDATA[<p>本章介绍 go语句、goroutine调度。</p>
<a id="more"></a>
<h3 id="go_语句">go 语句</h3>
<p>go语句用来产生一个新的goroutine，并执行一个函数，它的使用非常简单，就是在函数调用或者方法调用的前面加上go关键字即可。</p>
<p>函数可以是已有函数、匿名函数、方法等,注意匿名方法(方法字面量)不要忘记调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> foo(i <span class="typename">int</span>) <span class="typename">int</span> {</div><div class="line">	<span class="keyword">return</span> i * i</div><div class="line">}</div><div class="line"></div><div class="line">……</div><div class="line"></div><div class="line"><span class="keyword">go</span> foo<span class="number">(10</span>)</div><div class="line"><span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line"></div><div class="line">}()</div><div class="line"></div><div class="line"><span class="keyword">go</span> os.Open(<span class="string">"./test.txt"</span>)</div><div class="line"></div><div class="line">buf := bytes.NewBufferString(<span class="string">"hello world"</span>)</div><div class="line"><span class="keyword">go</span> buf.ReadString<span class="number">(0</span>)</div></pre></td></tr></table></figure>

<h3 id="深入go语句">深入go语句</h3>
<p>看下面一段代码,你觉得会输出什么:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 3</span>; i++ {</div><div class="line">		<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">			fmt.Println(i)</div><div class="line">		}()</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>有的人说输出&quot;0 1 2&quot;,有的人说输出&quot;2 2 2&quot;。</p>
<p>但实际上什么都没有输出。这是因为main goroutine马上就执行完了，它不会等待生成的goroutine的执行。</p>
<blockquote>
<p>Program execution begins by initializing the main package and then invoking the function main. When that function invocation returns, the program exits. It does not wait for other (non-main) goroutines to complete.</p>
</blockquote>
<p>你可以增加下面一行，等待所有的<code>goroutine</code>执行完：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> {}</div></pre></td></tr></table></figure>

<p>因为select语句会被阻塞，所以前面生成的所有的goroutine会被执行。</p>
<p>你可能会发现程序最后会出下面一个错误信息：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">fatal</span> <span class="built_in">error</span>: all goroutines are asleep - deadlock!</div></pre></td></tr></table></figure>

<p>它的意思是所有的goroutine都已经执行完了，你的select还在那里阻塞着，不会有case等你执行的，所以有死锁的可能。Go强制杀死了这个等待，并抛出了一个错误。因此你可以忽略这个错误，它对我们前面的程序执行没有影响。</p>
<p>如果你不想看到这个错误，你可以使用<code>sync.WaitGroup</code>，或者像其它语言中的处理方法一样，从命令行读取一个值造成main goroutine阻塞，抑或加一行time.Sleep让main goroutine休眠较长的一个时间也可以：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">os.Stdin.Read(<span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 1</span>))</div></pre></td></tr></table></figure>

<p>那么，加上上面一行，会输出什么?</p>
<p>答案是 &quot;2 2 2&quot;,为什么呢？</p>
<p>这是因为对于closure的情况(闭包closure的概念在很多语言中都有使用。在Go中，可以简单的认为匿名函数保持对外部变量的引用)，for循环的每次迭代都会使用相同的变量i,这样每个goroutine都持有对相同的变量的引用，因为main gororutine 很快就执行了， 三个goroutine还没来得及执行，等它们执行的时候，i已经等于 2了，所以它们都打印出2来。</p>
<p>我们可以稍微修改一下，让main goroutine不要执行那么快，每次迭代暂停1秒:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 3</span>; i++ {</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		fmt.Println(i)</div><div class="line">	}()</div><div class="line"></div><div class="line">	time.Sleep<span class="number">(1</span> * time.Second)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这段代码输出的结果为&quot;0 1 2&quot;。因为在main goroutine 暂停的时候， 生成的go routine有机会执行。</p>
<p>但是我们无法精确控制goroutine的执行，如果期望输出结果总是使用当前的迭代的值，可以改造成下面的样子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 3</span>; i++ {</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>(v <span class="typename">int</span>) {</div><div class="line">		fmt.Println(v)</div><div class="line">	}(i)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出结果为&quot;2 0 1&quot; (goroutine的执行顺序有可能不同,但是如果你看到最后一节的分析，这个执行顺序也能讲得通，最后一个输出2的goroutine作为runnext优先级最高，输出1的goroutine本来在runnext的位置，不幸被挤掉了，放在了本地队列的队尾)。</p>
<p>如果你不想对匿名函数进行改造的话，也可以像下面的这样，生成一个局部变量:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 3</span>; i++ {</div><div class="line">	i := i</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		fmt.Println(i)</div><div class="line">	}()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出 &quot;2 0 1&quot;, 注意我们使用一个同名的局部变量shadow了迭代的变量i。</p>
<p>参考:</p>
<ul>
<li><a href="https://golang.org/doc/faq#closures_and_goroutines" target="_blank" rel="external">https://golang.org/doc/faq#closures_and_goroutines</a></li>
</ul>
<h3 id="goroutine是什么">goroutine是什么</h3>
<p>goroutine是Go语言独有的概念。</p>
<p>并发和多线程编程总是被认为很困难，多少是由于它们的实现，对于线程和并发访问的控制很复杂。 Go语言并发的基础是goroutine和channel。<br>这些概念来源于著名计算机科学家C.A.R.Hoare的Communication Sequential Process （简称<a href="http://baike.baidu.com/subview/93641/8244751.htm" target="_blank" rel="external">CSP</a>)。<br>在该语言中，一个并发系统由若干并行运行的顺序进程组成，每个进程不能对其他进程的变量赋值。进程之间只能通过 一对通信原语实现协作：Q-&gt;x表示从进程Q输入一个值到变量x中；P&lt;-e表示把表达式e的值发送给进程P。当P进程执行Q-&gt;x， 同时Q进程执行P&lt;-e时，发生通信，e的值从Q进程传送给P进程的变量x。<br>Occam和Erlang基于CSP的理论实现的并发模型。</p>
<p>Go也借鉴了CSP的理论，但又有所不同，最大的不同是Go显示地使用channel, channel在Go中是第一类的对象，goroutine通信完全通过通过channel实现的。<br>CSP模型中消息的分发是即时和同步的，Go的Channel则不同，消息会缓存在Channel中。</p>
<p>我看到的一个有趣的项目是使用Go语言实现Hoare论文中的例子，有兴趣的朋友可以仔细观看，<a href="https://github.com/thomas11/csp" target="_blank" rel="external">csp</a>。</p>
<p>幸运地是，这些实现的细节对于Go语言的学习和应用来说不是必须的，对于语言的设计者来说，倒是值得比较和研究和出论文。</p>
<p>但是，对于开发者来说，至少应该明白goroutine和线程的不同，为什么一个Go应用可以存在成千上万个goroutine为线程确不行。</p>
<p><strong>goroutine vs thread</strong><br>对于线程来讲，Java的线程是最有名了。我们从三个方面进行比较：<br>1、内存占用<br>goroutine并不需要太多太多的内存占用，初始只需2kB的栈空间即可(自Go 1.4起)，按照需要可以增长。</p>
<p>线程初始1MB，并且会分配一个防护页(guard page)。</p>
<p>在使用Java开发服务器的过程中经常会遇到request per thread的问题，如果为每个请求都分配一个线程的话，大并发的情况下服务器很快就死掉，因为内存不够了，所以很多Java框架比如Netty都会使用线程池来处理请求，而不会让线程任意增长。</p>
<p>而使用goroutine则没有这个问题，你页可以看到官方的net/http库就是使用request per goroutine这种模式进行处理的，内存占用不会是问题。</p>
<p>2、对象的创建和销毁<br>线程的创建和销毁肯定有花费，因为需要从OS中请求／返还资源。</p>
<p>而goroutine的创建和销毁花费很少，因为它是用户态的操作。并且Go语言也不提供goroutine的手工管理。</p>
<p>3、切换时间<br>当线程阻塞时，其它的线程进可能被执行，这叫做线程的切换。切换的时候，调度器需要保存当前阻塞的线程的状态，恢复要执行的线程状态，包括所有的寄存器，16个通用寄存器、程序计数器、栈指针、段寄存器、16个XMM寄存器、FP协处理器、16个 AVX寄存器、所有的MSR等等。</p>
<p>goroutine的保存和恢复只需要三个寄存器：程序计数器、栈指针和DX寄存器。因为goroutine之间共享堆空间，也共享栈空间，所以只需把goroutine的栈指针和程序执行到那里的信息保存和恢复即可，花费很低。</p>
<p>通过上面三个方面的分析，可以看到goroutine比线程有更多的优势。实际上Go使用少量线程来执行这些goroutine,通过GOMAXPROCS环境变量可以控制有多少线程可以并发执行用户态的代码。由于系统调用而被阻塞的线程不受这个变量的限制。以前版本的Go中这个变量为1,自Go 1.5后它的默认值为CPU的核数。</p>
<blockquote>
<p><strong>进程</strong>拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。<br><strong>线程</strong>拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。<br><strong>协程</strong>和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。</p>
</blockquote>
<p><strong>goroutine vs coroutine</strong><br>两个类似，都是共享堆，不共享栈，切换的时候需要保存和恢复栈信息。</p>
<p>但是coroutine(协程)需要显示地控制goroutine的转换，程序员需要在切换的地方调用<code>yield</code>让度当前的coroutine的执行，这样其它coroutine才有可能在这个线程中执行,等暂停的coroutine恢复执行的时候，它会接着上次暂停的地方继续执行，而不像普通的函数从头开始执行。 看一段lua的coroutine代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">(a)</span></span></div><div class="line">    <span class="built_in">print</span>(<span class="string">"foo"</span>, a)</div><div class="line">    <span class="keyword">return</span> <span class="built_in">coroutine</span>.yield(<span class="number">2</span>*a)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  co = <span class="built_in">coroutine</span>.create(<span class="function"><span class="keyword">function</span> <span class="params">(a,b)</span></span></div><div class="line">        <span class="built_in">print</span>(<span class="string">"co-body"</span>, a, b)</div><div class="line">        <span class="keyword">local</span> r = foo(a+<span class="number">1</span>)</div><div class="line">        <span class="built_in">print</span>(<span class="string">"co-body"</span>, r)</div><div class="line">        <span class="keyword">local</span> r, s = <span class="built_in">coroutine</span>.yield(a+b, a-b)</div><div class="line">        <span class="built_in">print</span>(<span class="string">"co-body"</span>, r, s)</div><div class="line">        <span class="keyword">return</span> b, <span class="string">"end"</span></div><div class="line">  <span class="keyword">end</span>)</div><div class="line"></div><div class="line">  <span class="built_in">print</span>(<span class="string">"main"</span>, <span class="built_in">coroutine</span>.resume(co, <span class="number">1</span>, <span class="number">10</span>))</div><div class="line">  <span class="built_in">print</span>(<span class="string">"main"</span>, <span class="built_in">coroutine</span>.resume(co, <span class="string">"r"</span>))</div><div class="line">  <span class="built_in">print</span>(<span class="string">"main"</span>, <span class="built_in">coroutine</span>.resume(co, <span class="string">"x"</span>, <span class="string">"y"</span>))</div><div class="line">  <span class="built_in">print</span>(<span class="string">"main"</span>, <span class="built_in">coroutine</span>.resume(co, <span class="string">"x"</span>, <span class="string">"y"</span>))</div></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">co-<span class="keyword">body</span> <span class="number">1</span>       <span class="number">10</span></div><div class="line">foo     <span class="number">2</span></div><div class="line"></div><div class="line">main    <span class="literal">true</span>    <span class="number">4</span></div><div class="line">co-<span class="keyword">body</span> r</div><div class="line">main    <span class="literal">true</span>    <span class="number">11</span>      -<span class="number">9</span></div><div class="line">co-<span class="keyword">body</span> x       y</div><div class="line">main    <span class="literal">true</span>    <span class="number">10</span>      end</div><div class="line">main    <span class="literal">false</span>   cannot resume dead coroutine</div></pre></td></tr></table></figure>

<p>可以看到coroutine切换都是通过代码中的yield触发的。</p>
<p>goroutine也是由一组线程执行，也会暂停，也会继续执行，但是这个控制不是程序员实现安排好的，它是由go运行时后台控制的。goroutine的调度不能手工的执行，这是和coroutine最大的区别。当goroutine阻塞的时候，就有可能让度出线程以便其它goroutine执行，以下几种情况goroutine可能暂停自己的运行：</p>
<ul>
<li>调用runtime.Gosched()将当前goroutine放入到全局队列</li>
<li>调用runtime.Goexit，终止G任务</li>
<li>网络读取</li>
<li>sleep</li>
<li>channel操作</li>
<li>调用sync包中的对象进行阻塞</li>
<li>其它gouroutine被阻塞的情况,比如io读取,空无限循环，长时间占用线程执行的goroutine</li>
</ul>
<p>利用goroutine和channel也可以实现cororutine,比如下面的<a href="https://github.com/Jxck/goroutine-sample/blob/master/coroutine.go" target="_blank" rel="external">代码</a>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> f(yield <span class="keyword">chan</span> <span class="typename">string</span>) {</div><div class="line">	yield &lt;- <span class="string">"one"</span></div><div class="line">	yield &lt;- <span class="string">"two"</span></div><div class="line">	yield &lt;- <span class="string">"three"</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	co := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">string</span>)</div><div class="line">	<span class="keyword">go</span> f(co)</div><div class="line">	log.Println(&lt;-co) <span class="comment">// one</span></div><div class="line">	log.Println(&lt;-co) <span class="comment">// two</span></div><div class="line">	log.Println(&lt;-co) <span class="comment">// three</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>参考</p>
<ul>
<li><a href="https://talks.golang.org/2012/concurrency.slide" target="_blank" rel="external">https://talks.golang.org/2012/concurrency.slide</a></li>
<li><a href="https://talks.golang.org/2012/waza.slide" target="_blank" rel="external">https://talks.golang.org/2012/waza.slide</a></li>
<li><a href="http://blog.nindalf.com/how-goroutines-work/" target="_blank" rel="external">http://blog.nindalf.com/how-goroutines-work/</a></li>
<li><a href="http://stackoverflow.com/questions/18058164/is-a-go-goroutine-a-coroutine" target="_blank" rel="external">http://stackoverflow.com/questions/18058164/is-a-go-goroutine-a-coroutine</a></li>
<li><a href="http://www.golangpatterns.info/concurrency/coroutines" target="_blank" rel="external">http://www.golangpatterns.info/concurrency/coroutines</a></li>
<li><a href="https://golang.org/doc/faq#goroutines" target="_blank" rel="external">https://golang.org/doc/faq#goroutines</a></li>
<li><a href="https://blog.golang.org/share-memory-by-communicating" target="_blank" rel="external">https://blog.golang.org/share-memory-by-communicating</a></li>
<li><a href="http://stackoverflow.com/questions/32651557/golang-main-difference-from-csp-language-by-hoare" target="_blank" rel="external">http://stackoverflow.com/questions/32651557/golang-main-difference-from-csp-language-by-hoare</a></li>
<li><a href="http://www.informit.com/articles/printerfriendly/1768317" target="_blank" rel="external">http://www.informit.com/articles/printerfriendly/1768317</a></li>
<li><a href="https://en.wikipedia.org/wiki/Coroutine" target="_blank" rel="external">https://en.wikipedia.org/wiki/Coroutine</a></li>
<li><a href="http://www.jianshu.com/p/36e246c6153d" target="_blank" rel="external">http://www.jianshu.com/p/36e246c6153d</a></li>
<li><a href="https://github.com/golang/go/issues/4056" target="_blank" rel="external">https://github.com/golang/go/issues/4056</a></li>
<li><a href="http://stackoverflow.com/questions/28354141/c-code-and-goroutine-scheduling" target="_blank" rel="external">http://stackoverflow.com/questions/28354141/c-code-and-goroutine-scheduling</a></li>
</ul>
<h3 id="goroutine的调度">goroutine的调度</h3>
<p>goroutine调度(Scheduling)的文章网上非常多了，而且分析的都很深入。本文重点的介绍其中的一些细节。</p>
<p>goroutine调度器有三个重要的数据结构，都是以单字母命名: G、P、M,因为Golang以及实现了自举，所以绝大部分的代码都是由Go本身实现的，少部分的以汇编实现，因为你已经由Go的基础知识了，所以你可以查看这些实现的代码不会感到特别困难。</p>
<p><img src="models.jpg" alt=""></p>
<ul>
<li>M代表系统线程(Machine)，由操作系统管理。</li>
<li>G代表goroutine,包括栈／指令指针以及其它对调度goroutine有用的信息。</li>
<li>P代表处理器(processor),注意不是CPU处理器，而是调度处理器，包含调度的上下文。</li>
</ul>
<p>这三个个对象的数据结构定义在Go源代码的<a href="https://golang.org/src/runtime/runtime2.go" target="_blank" rel="external">src/runtime/runtime2.go</a>中定义，另外还包括一个很重要的数据结构schedt。</p>
<p>P必须和M组合起来执行G，但是两者也并不是完全1:1对应，通常情况下P的数量固定和CPU的核数一样(GOMAXPROCS参数)，M则是按需创建，比如当M因为陷入系统调用而长时间阻塞的时候，P就会被监控线程抢回，去新建或者唤醒另一个M去执行，因此M的数量会增加，系统中可能存在一些阻塞的M。</p>
<p>当一个G被创建的时候，它可能被放入到一个P的本地队列或者全局队列中：<br><img src="p.jpg" alt=""></p>
<p>由于goroutine的执行的时间不会一样，goroutine不可能均匀地分布在所有的P的本地队列中，如果其中的一个P执行地很快，它的队列中没有其它的gouroutine需要执行了，它就会从全局队列中拿一批goroutine过来。</p>
<p>如果全局队列中也没有要执行的goroutine，那么这个P可能要从其它的P中“偷”一些goroutine过来。</p>
<p>这样设计的目的就是不要让一部分P忙的要死，另外一部分P确很清闲，这是一个balance的过程。<br><img src="steal.jpg" alt=""></p>
<p>编译器会将&quot;go func(……){}(……)&quot;翻译成&quot;newproc&quot;调用,这个方法在runtime/proc.go中定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Create a new g running fn with siz bytes of arguments.</span></div><div class="line"><span class="comment">// Put it on the queue of g's waiting to run.</span></div><div class="line"><span class="comment">// The compiler turns a go statement into a call to this.</span></div><div class="line"><span class="comment">// Cannot split the stack because it assumes that the arguments</span></div><div class="line"><span class="comment">// are available sequentially after &fn; they would not be</span></div><div class="line"><span class="comment">// copied if a stack split occurred.</span></div><div class="line"><span class="comment">//go:nosplit</span></div><div class="line"><span class="keyword">func</span> newproc(siz <span class="typename">int32</span>, fn *funcval) {</div><div class="line">	argp := add(unsafe.Pointer(&fn), sys.PtrSize)</div><div class="line">	pc := getcallerpc(unsafe.Pointer(&siz))</div><div class="line">	systemstack(<span class="keyword">func</span>() {</div><div class="line">		newproc1(fn, (*<span class="typename">uint8</span>)(argp), siz,<span class="number"> 0</span>, pc)</div><div class="line">	})</div><div class="line">}</div></pre></td></tr></table></figure>

<p>它的创建G的主要逻辑在newproc1中实现，并调用<code>runqput</code>将创建的G放入到队列中。注意G是可以重用的，如果有重用的G，则选择一个，否则创建一个新的，而且它也有本地复用链表和全局复用链表。</p>
<p><code>runqput</code>首先尝试将G放入到P本地队列的本地队列中，而且在不设置&quot;-race&quot;的情况下,可能会尝试将这个G放在p.runnext中，作为下一个优先处理的G，而原先的runnext放回队尾。如果本地队列已满，则放入到全局队列中，而且还会将本地队列的一部分放入到全局队列中。</p>
<p>任务队列的优先级分三种：P.runnext、P.runq和全局的Schedt.runq。</p>
<p><code>schedule</code>方法用来实现goroutine的调用，你可以在proc.go文件中搜索对它的调用。</p>
<p>如果你浏览schedule()方法的实现，可以看到每隔一定时间，会先尝试从全局队列中获取g去执行，这样就避免全局队列中的g没机会执行。</p>
<p>然后尝试本地队列中获取g, 依照优先级选择g,先是P.runnext,然后从队列的头部依次获取。</p>
<p>如果本地队列没有g,则调用<code>findrunnable</code>方法从其它地方获取,这是一个block方法，直到有g获取到。<br>findrunnable首先从本地队列获取(runqget方法)，然后从全局队列获取(globrunqget),然后检查netpoll的goroutine,<br>如果还没有，随机选择一个P,偷一些任务过来(runqsteal方法，如果“饿”的厉害，连别人的runnext都偷过来)。<br>具体的获取过程你可以查看每个选择的方法。</p>
<p>你可以通过schedtrace调试参数查看Go调度的细节：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GOMAXPROCS<span class="number">=1</span> GODEBUG=schedtrace<span class="number">=1000</span> ./example</div></pre></td></tr></table></figure>

<p>详细的文章可以查看我翻译的William Kennedy的<a href="http://colobu.com/2016/04/19/Scheduler-Tracing-In-Go/" target="_blank" rel="external">Scheduler Tracing In Go</a></p>
<p>参考</p>
<ul>
<li><a href="https://golang.org/pkg/runtime/" target="_blank" rel="external">https://golang.org/pkg/runtime/</a></li>
<li><a href="http://www.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf" target="_blank" rel="external">http://www.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf</a></li>
<li><a href="https://morsmachine.dk/go-scheduler" target="_blank" rel="external">https://morsmachine.dk/go-scheduler</a></li>
<li><a href="http://studygolang.com/articles/6070" target="_blank" rel="external">http://studygolang.com/articles/6070</a></li>
<li><a href="http://www.slideshare.net/matthewrdale/demystifying-the-go-scheduler" target="_blank" rel="external">http://www.slideshare.net/matthewrdale/demystifying-the-go-scheduler</a></li>
<li><a href="https://github.com/qyuhen/book/blob/master/Go%201.5%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.pdf" target="_blank" rel="external">https://github.com/qyuhen/book/blob/master/Go%201.5%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.pdf</a></li>
<li><a href="https://www.goinggo.net/2015/02/scheduler-tracing-in-go.html" target="_blank" rel="external">https://www.goinggo.net/2015/02/scheduler-tracing-in-go.html</a></li>
<li><a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/05.1.html" target="_blank" rel="external">https://tiancaiamao.gitbooks.io/go-internals/content/zh/05.1.html</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>本章介绍 go语句、goroutine调度。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go语言 - 7]]></title>
    <link href="http://colobu.com/2016/06/22/dive-into-go-7/"/>
    <id>http://colobu.com/2016/06/22/dive-into-go-7/</id>
    <published>2016-06-22T08:26:47.000Z</published>
    <updated>2016-06-28T05:27:37.000Z</updated>
    <content type="html"><![CDATA[<p>本章介绍Go语言的各种语句。</p>
<a id="more"></a>
<p>Go语言的语法定义罗列了所有的语句类型:</p>
<pre class="highlight">
Statement =
    Declaration | LabeledStmt | SimpleStmt |
    GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |
    FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |
    DeferStmt .

SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .
</pre>


<p>语句控制程序逻辑的运行。终止语句(terminating statement)代表结束当前程序逻辑单元的运行。<br>1、 A &quot;return&quot; or &quot;goto&quot; statement.<br>2、A call to the built-in function panic.<br>3、A block in which the statement list ends in a terminating statement.<br>4、 An &quot;if&quot; statement in which:</p>
<ul>
<li>the &quot;else&quot; branch is present, and</li>
<li>both branches are terminating statements.</li>
</ul>
<p>5、A &quot;for&quot; statement in which:</p>
<ul>
<li>there are no &quot;break&quot; statements referring to the &quot;for&quot; statement, and</li>
<li>the loop condition is absent.</li>
</ul>
<p>6、A &quot;switch&quot; statement in which:</p>
<ul>
<li>there are no &quot;break&quot; statements referring to the &quot;switch&quot; statement,</li>
<li>there is a default case, and</li>
<li>the statement lists in each case, including the default, end in a terminating statement, or a possibly labeled &quot;fallthrough&quot; statement.</li>
</ul>
<p>7、A &quot;select&quot; statement in which:</p>
<ul>
<li>there are no &quot;break&quot; statements referring to the &quot;select&quot; statement, and</li>
<li>the statement lists in each case, including the default if present, end in a terminating statement.</li>
</ul>
<p>8、A labeled statement labeling a terminating statement.</p>
<p>其它的语句都不会终止程序单元的执行。</p>
<p>参考</p>
<ul>
<li><a href="https://github.com/golang/go/issues/14422" target="_blank" rel="external">https://github.com/golang/go/issues/14422</a></li>
<li><a href="https://github.com/golang/go/issues/14537" target="_blank" rel="external">https://github.com/golang/go/issues/14537</a></li>
</ul>
<h3 id="空语句">空语句</h3>
<p>空语句不错任何事</p>
<h3 id="标签语句">标签语句</h3>
<p>增加一个标签， 为 goto、break、continue 使用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error: log.Panic(<span class="string">"error encountered"</span>)</div></pre></td></tr></table></figure>

<h3 id="表达式语句">表达式语句</h3>
<p>除了特别的内置函数， 一般函数和方法调用、receive 操作都可以出现在语句的上下文中，<br>这样的语句可以用括号括起来。</p>
<p>下面的内置的函数不能在语句中：</p>
<pre class="highlight">
append cap complex imag len make new real
unsafe.Alignof unsafe.Offsetof unsafe.Sizeof
</pre>

<p>下面的操作都可以作为语句：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">h(x+y)</div><div class="line">f.Close()</div><div class="line">&lt;-ch</div><div class="line">(&lt;-ch)</div></pre></td></tr></table></figure>

<p>但是下面的内置函数调用就不可以:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">len</span>(<span class="string">"foo"</span>) <span class="comment">//错误</span></div></pre></td></tr></table></figure>

<h3 id="send语句">send语句</h3>
<p>可以通过send的语句往channel发送一个值。</p>
<h3 id="自增和自减语句">自增和自减语句</h3>
<p>注意，Go语言中&quot;++&quot;和&quot;--&quot;是语句(statement)，而不是表达式(expression)，并且只能放在操作数的后面(postfix)。操作数必须是可寻址的或者是map索引表达式。</p>
<p><code>x++</code> 等价于 <code>x += 1</code>，<code>x--</code> 等价于 <code>x -= 1</code>。</p>
<p>因为它们不是表达式，所以不能以表达式的方式给其它变量赋值，下面的代码是错误的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span>{<span class="string">"1"</span>:<span class="number"> 1</span>, <span class="string">"2"</span>:<span class="number"> 2</span>}</div><div class="line">m[<span class="string">"1"</span>]++</div><div class="line"></div><div class="line">i :=<span class="number"> 0</span></div><div class="line">i++</div><div class="line"></div><div class="line"><span class="keyword">var</span> j = i++ <span class="comment">//错误</span></div></pre></td></tr></table></figure>

<h3 id="赋值语句">赋值语句</h3>
<p>赋值语句左边的操作数必须是可寻址的、或者是map索引表达式、抑或是空标识符_。</p>
<p>操作数可以用括号括起来，不管是左边的操作数还是右边的操作数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i, j <span class="typename">int</span></div><div class="line">(i), (j) = <span class="number">(3</span>),<span class="number"> 4</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> k <span class="typename">int</span></div><div class="line">(k) = i</div><div class="line">_, _, _ = i, j, k</div></pre></td></tr></table></figure>

<p>复合的赋值操作 <code>x op= y</code>等价于<code>x = x op (y)</code>,但是x只会被计算一次。运算符的左右两边只能是单值的表达式，而且左边的操作符不能是空标识符。</p>
<p>前面也有代码举例，Go支持多值赋值(tuple)，左边的操作数的数量必须和右边的值的数量相同。</p>
<p>赋值过程分为两阶段：</p>
<ol>
<li>计算左边的索引表达式的操作数和指针， 右边的表达式</li>
<li>从左到右赋值</li>
</ol>
<p>下面是赋值语句的一些例子，你可以琢磨琢磨。</p>
<pre class="highlight">
a, b = b, a  // exchange a and b

x := []int{1, 2, 3}
i := 0
i, x[i] = 1, 2  // set i = 1, x[0] = 2

i = 0
x[i], i = 2, 1  // set x[0] = 2, i = 1

x[0], x[0] = 1, 2  // set x[0] = 1, then x[0] = 2 (so x[0] == 2 at end)

x[1], x[3] = 4, 5  // set x[1] = 4, then panic setting x[3] = 5.

type Point struct { x, y int }
var p *Point
x[2], p.x = 6, 7  // set x[2] = 6, then panic setting p.x = 7

i = 2
x = []int{3, 5, 7}
for i, x[i] = range x {  // set i, x[2] = 0, x[0]
    break
}
// after this loop, i == 0 and x == []int{3, 5, 3}
</pre>

<h3 id="if_语句">if 语句</h3>
<p>if语句类似其它语言中比如Java、C的if语句，但是也有不同：<br>1、if语句中的条件表达式可以有简单的语句:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> x := f(); x &lt; y {</div><div class="line">	<span class="keyword">return</span> x</div><div class="line">} <span class="keyword">else</span> <span class="keyword">if</span> x &gt; z {</div><div class="line">	<span class="keyword">return</span> z</div><div class="line">} <span class="keyword">else</span> {</div><div class="line">	<span class="keyword">return</span> y</div><div class="line">}</div></pre></td></tr></table></figure>

<p>2、代码块必须以大括号括起来，即使是单行代码块不能省略大括号</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> x &gt; max</div><div class="line">  x = max  <span class="comment">//错误</span></div></pre></td></tr></table></figure>

<p>3、if 中的条件表达式可以省略括号，而且一般都省略括号</p>
<h3 id="switch_语句">switch 语句</h3>
<p>switch提供了多路处理的机制。switch有两种：表达式switch和type switch。 类型switch在前一章中已经介绍了，本节只介绍表达式switch。</p>
<p>表达式switch(以下直接叫switch)中的表达式会被计算，然后和case clause进行比较。case clause中的表达式不一定是常数。表达式的计算都是从左到右，从上而下的计算的。</p>
<p>如果遇到第一个满足的case，其它的case就不会执行，如果没有满足条件的case,并且有一个default的case的话，会执行default代码块，相当于default用来兜底。最多有一个default，而且一般都将它放在底部，尽管它的位置和其它case cluase没有顺序限制。</p>
<p>在case表达式中，对于未声明类型的bool常量，它首先会被转换成bool类型，对于其它常量，会被转换成缺省类型进行比较。</p>
<p>编译器可能不允许有重复的 case 常量 clause,但是非常量的表达式可以：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	i :=<span class="number"> 4</span></div><div class="line"></div><div class="line">	<span class="keyword">switch</span> i {</div><div class="line">	<span class="keyword">case</span><span class="number"> 1</span>:</div><div class="line">		fmt.Println<span class="number">(1</span>)</div><div class="line">	<span class="keyword">case</span><span class="number"> 2</span>:</div><div class="line">		fmt.Println<span class="number">(2</span>)</div><div class="line">	<span class="keyword">case</span> f():</div><div class="line">		fmt.Println(<span class="string">"f"</span>)</div><div class="line">	<span class="keyword">case</span><span class="number"> 4</span>:</div><div class="line">		fmt.Println<span class="number">(4</span>)</div><div class="line"></div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		fmt.Println(<span class="string">"unknown"</span>)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> f() <span class="typename">int</span> {</div><div class="line">	<span class="keyword">return</span><span class="number"> 4</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>fallthrough</code>语句可以是case语句或者default的代码块的最后一个语句，只要当前的case语句或者default语句不是最后一个case语句。 但是<code>fallthrough</code>不能出现在代码块的中间(非最后一个语句)。</p>
<p><code>fallthrough</code>将直接跳到下一个case clause的代码块的第一个语句中，不会和那个case 表达式再进行比较。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">i :=<span class="number"> 1</span></div><div class="line"></div><div class="line"><span class="keyword">switch</span> i {</div><div class="line"><span class="keyword">case</span><span class="number"> 1</span>:</div><div class="line">	fmt.Println<span class="number">(1</span>)</div><div class="line">	<span class="keyword">fallthrough</span></div><div class="line">	<span class="comment">//fmt.Println("after fallthrough") //错误</span></div><div class="line"><span class="keyword">case</span><span class="number"> 2</span>:</div><div class="line">	fmt.Println<span class="number">(2</span>)</div><div class="line"><span class="keyword">case</span><span class="number"> 3</span>:</div><div class="line">	fmt.Println<span class="number">(3</span>)</div><div class="line"><span class="keyword">default</span>:</div><div class="line">	fmt.Println(<span class="string">"unknown"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的代码输出 1 和 2。</p>
<p>switch 表达式的前面可以有简单的表达式，它在switch表达式计算之前执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> x := f(); x<span class="number">&gt;0</span> {</div><div class="line">	<span class="keyword">case</span> <span class="constant">true</span>:</div><div class="line">}</div></pre></td></tr></table></figure>

<p>switch表达式也可以省略，省略的时候意味着表达式为 true，所以会进入case 表达式为true的代码块：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> {</div><div class="line"><span class="keyword">case</span> x &lt; y: f1()</div><div class="line"><span class="keyword">case</span> x &lt; z: f2()</div><div class="line"><span class="keyword">case</span> x ==<span class="number"> 4</span>: f3()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>switch表达式也一般省略括号。</p>
<h3 id="for_语句">for 语句</h3>
<p>for 语句也不用括号,而且在三段式的for语句中，加上括号反而报错。</p>
<p>Go扩展了其它语言中的for语句饿功能，它有以下的形式：</p>
<p>1、普通的三段式的for语句 <code>for init; condition; post {……}</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">	fmt.Println(i)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>其中的三段中的任意部分都可以省略，但是分号不能省略。</p>
<p>2、只包含条件表达式的for语句 <code>for condition {}</code><br>Go语言中没有while语句，所以for的这种形式类似while语句。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">i :=<span class="number"> 0</span></div><div class="line"><span class="keyword">for</span> i &lt;<span class="number"> 10</span> {</div><div class="line">	i++</div><div class="line">}</div></pre></td></tr></table></figure>

<p>3、for ... range语句<br>对于数组、slice、字符串、map对象以及 从channel中接收的值，可以使用这种语句进行遍历。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = []<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 4</span>,<span class="number"> 5</span>}</div><div class="line"></div><div class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> s {</div><div class="line">	fmt.Printf(<span class="string">"index: %d, value: %d\n"</span>, i, v)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>对于不同的类型， range迭代的结果可能是一个值，也可能是两个值。具体如下：</p>
<table>
<thead>
<tr>
<th>Range 表达式</th>
<th>第一个值</th>
<th>第二个值</th>
</tr>
</thead>
<tbody>
<tr>
<td>array or slice  a  [n]E, *[n]E, or []E</td>
<td>index    i  int</td>
<td>a[i]       E</td>
</tr>
<tr>
<td>string          s  string type</td>
<td>index    i  int</td>
<td>see below  rune</td>
</tr>
<tr>
<td>map             m  map[K]V</td>
<td>key      k  K</td>
<td>m[k]       V</td>
</tr>
<tr>
<td>channel         c  chan E, &lt;-chan E</td>
<td>element  e  E</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>4、 无任何条件和语句的 for</p>
<figure class="highlight for"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="constant">i</span> := 10</div><div class="line">for {</div><div class="line">	i++</div><div class="line">	if i &gt; 20 {</div><div class="line">		break</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>对于数组，数组指针、slice，索引从0开始，止于 len(a) -1</li>
<li>对于字符串， range将迭代unicode code point，而不是字节byte, 因此索引值为当前unicode字符的起始位置，值为rune。如果不是unicode字符，第二个值为0xFFFD</li>
<li>对于map的迭代每次迭代可能不同。入股迭代的过程中还没有被访问的对象被移除了，后续的迭代中不会出现这些删除的值。如果迭代的过程中往map中增加值，则增加的值可能出现后续的迭代中，也可能不出现。</li>
<li>对于channel,迭代一直会执行，直到channel被关闭。如果channel为nil,则range表达式永远被阻塞，一定要注意。</li>
</ul>
<h3 id="select_语句">select 语句</h3>
<p>select语句从一组<a href="https://golang.org/ref/spec#Send_statements" target="_blank" rel="external">send</a>操作和<a href="https://golang.org/ref/spec#Receive_operator" target="_blank" rel="external">receive</a>操作中选择一个执行。</p>
<p>它类似switch但是只用来对channel进行操作。</p>
<ul>
<li>channel操作数如果是一个表达式，那么表达式只会被计算一次</li>
<li>如果有多个case可以被执行，只有一个case会被选择执行。选择算法是伪随机算法。如果没有case可以执行，并且有一个default case,则这个default会被选择执行， 如果没有default, select会被阻塞直到有一个case可以被执行。</li>
</ul>
<p>select一次只有一个case会执行，所以很多情况下我们把它放入到一个 for循环中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a []<span class="typename">int</span></div><div class="line"><span class="keyword">var</span> c, c1, c2, c3, c4 <span class="keyword">chan</span> <span class="typename">int</span></div><div class="line"><span class="keyword">var</span> i1, i2 <span class="typename">int</span></div><div class="line"><span class="keyword">select</span> {</div><div class="line"><span class="keyword">case</span> i1 = &lt;-c1:</div><div class="line"> <span class="built_in">print</span>(<span class="string">"received "</span>, i1, <span class="string">" from c1\n"</span>)</div><div class="line"><span class="keyword">case</span> c2 &lt;- i2:</div><div class="line"> <span class="built_in">print</span>(<span class="string">"sent "</span>, i2, <span class="string">" to c2\n"</span>)</div><div class="line"><span class="keyword">case</span> i3, ok := (&lt;-c3):  <span class="comment">// same as: i3, ok := &lt;-c3</span></div><div class="line"> <span class="keyword">if</span> ok {</div><div class="line">	 <span class="built_in">print</span>(<span class="string">"received "</span>, i3, <span class="string">" from c3\n"</span>)</div><div class="line"> } <span class="keyword">else</span> {</div><div class="line">	 <span class="built_in">print</span>(<span class="string">"c3 is closed\n"</span>)</div><div class="line"> }</div><div class="line"><span class="keyword">case</span> a[f()] = &lt;-c4:</div><div class="line"> <span class="comment">// same as:</span></div><div class="line"> <span class="comment">// case t := &lt;-c4</span></div><div class="line"> <span class="comment">//	a[f()] = t</span></div><div class="line"><span class="keyword">default</span>:</div><div class="line"> <span class="built_in">print</span>(<span class="string">"no communication\n"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span> {  <span class="comment">// send random sequence of bits to c</span></div><div class="line"> <span class="keyword">select</span> {</div><div class="line"> <span class="keyword">case</span> c &lt;-<span class="number"> 0</span>:  <span class="comment">// note: no statement, no fallthrough, no folding of cases</span></div><div class="line"> <span class="keyword">case</span> c &lt;-<span class="number"> 1</span>:</div><div class="line"> }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">select</span> {}  <span class="comment">// block forever</span></div></pre></td></tr></table></figure>

<p>select 语句也经常加入超时的case:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">  c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">string</span>,<span class="number"> 1</span>)</div><div class="line">  <span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">      time.Sleep(time.Second *<span class="number"> 2</span>)</div><div class="line">      c1 &lt;- <span class="string">"result 1"</span></div><div class="line">  }()</div><div class="line"></div><div class="line"><span class="comment">//执行超时case</span></div><div class="line">  <span class="keyword">select</span> {</div><div class="line">  <span class="keyword">case</span> res := &lt;-c1:</div><div class="line">      fmt.Println(res)</div><div class="line">  <span class="keyword">case</span> &lt;-time.After(time.Second *<span class="number"> 1</span>):</div><div class="line">      fmt.Println(<span class="string">"timeout 1"</span>)</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="comment">//执行C2</span></div><div class="line">  c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">string</span>,<span class="number"> 1</span>)</div><div class="line">  <span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">      time.Sleep(time.Second *<span class="number"> 2</span>)</div><div class="line">      c2 &lt;- <span class="string">"result 2"</span></div><div class="line">  }()</div><div class="line">  <span class="keyword">select</span> {</div><div class="line">  <span class="keyword">case</span> res := &lt;-c2:</div><div class="line">      fmt.Println(res)</div><div class="line">  <span class="keyword">case</span> &lt;-time.After(time.Second *<span class="number"> 3</span>):</div><div class="line">      fmt.Println(<span class="string">"timeout 2"</span>)</div><div class="line">  }</div></pre></td></tr></table></figure>

<h3 id="return_语句">return 语句</h3>
<p>return语句从函数中返回。</p>
<p>如果函数没有返回类型， return语句不能返回任何值。</p>
<p>如果函数有返回类型，那么有几种情况<br>1、返回值可以显示地写在return的后面,每个表达式必须是单值的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> simpleF() <span class="typename">int</span> {</div><div class="line">	<span class="keyword">return</span><span class="number"> 2</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> complexF1() (re <span class="typename">float64</span>, im <span class="typename">float64</span>) {</div><div class="line">	<span class="keyword">return</span><span class="number"> -7.0</span>,<span class="number"> -4.0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>2、return语句中的表达式列表可以是对返回多只函数的调用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> complexF2() (re <span class="typename">float64</span>, im <span class="typename">float64</span>) {</div><div class="line">	<span class="keyword">return</span> complexF1()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>3、如果函数的返回类型参数指定了名字，则return 可以返回空。这些返回类型参数就像本地变量一样。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> complexF3() (re <span class="typename">float64</span>, im <span class="typename">float64</span>) {</div><div class="line">	re =<span class="number"> 7.0</span></div><div class="line">	im =<span class="number"> 4.0</span></div><div class="line">	<span class="keyword">return</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (devnull) Write(p []<span class="typename">byte</span>) (n <span class="typename">int</span>, _ error) {</div><div class="line">	n = <span class="built_in">len</span>(p)</div><div class="line">	<span class="keyword">return</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>所有的结果值在函数的开始时都被初始化为它们的零值。</p>
<p>编译器可能不允许下面的scope中的return返回空：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> f(n <span class="typename">int</span>) (res <span class="typename">int</span>, err error) {</div><div class="line">	<span class="keyword">if</span> _, err := f(n<span class="number">-1</span>); err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span>  <span class="comment">// invalid return statement: err is shadowed</span></div><div class="line">	}</div><div class="line">	<span class="keyword">return</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="break_语句">break 语句</h3>
<p>break用来终止执行最内层的 for、 switch 或者 select语句。</p>
<p>如果break后面跟着一个标签，则标签应该紧贴着要终止的for、switch或者selector语句，下面的代码中 break label2就是错的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">label2:</div><div class="line">	i :=<span class="number"> 10</span></div><div class="line"></div><div class="line">label1:</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		i++</div><div class="line">		<span class="keyword">if</span> i &gt;<span class="number"> 20</span> {</div><div class="line">			<span class="keyword">break</span> label1</div><div class="line">		}</div><div class="line">		fmt.Println(i)</div><div class="line">		<span class="keyword">if</span> i &lt;<span class="number"> 10</span> {</div><div class="line">			<span class="keyword">break</span> label2</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<p>为什么要用标签呢？因为不带标签的break只能终止最内层(innermost)的循环，如果像终止外部的循环，就得用标签了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">label1:</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		fmt.Println(<span class="string">"hello"</span>)</div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			fmt.Println(<span class="string">"world"</span>)</div><div class="line">			<span class="keyword">break</span> label1</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<h3 id="continue_语句">continue 语句</h3>
<p>continue语句开始最内层的 for循环的下一次迭代，终止本次迭代。</p>
<p>同样，如果后面跟着标签，将开始外层的标签指定的for循环的下一次迭代。</p>
<h3 id="goto语句">goto语句</h3>
<p>goto跳转太强大，在很多语言中虽然都提供但是不推荐使用，Go也一样。</p>
<p>下面的goto是不允许的，因为标签L跳过了变量v等声明和赋值，如果后面的代码访问v会有问题。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">goto</span> L  <span class="comment">// BAD</span></div><div class="line">	v :=<span class="number"> 3</span></div><div class="line">L:</div></pre></td></tr></table></figure>

<p>代码块外部的goto不能跳到一个代码块内部的标签上:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> n<span class="number">%2</span> ==<span class="number"> 1</span> {</div><div class="line">	<span class="keyword">goto</span> L1</div><div class="line">}</div><div class="line"><span class="keyword">for</span> n &gt;<span class="number"> 0</span> {</div><div class="line">	f()</div><div class="line">	n--</div><div class="line">L1:</div><div class="line">	f()</div><div class="line">	n--</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="defer_语句">defer 语句</h3>
<p>defer语句调用一个函数，这个函数将会在当前函数返回的时候才被调用，货站当前函数执行了一个return语句，或者发生panic。</p>
<p>无论是否有panic， defer函数都会调用。</p>
<p>函数可以是普通函数或者方法。调用内置函数有限制，限制条件和上面的表达式语句一样。</p>
<p>当defer语句执行时，函数的参数就会被计算一次，但是函数还没有被调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">i :=<span class="number"> 0</span></div><div class="line"></div><div class="line"><span class="keyword">defer</span> <span class="keyword">func</span>(i <span class="typename">int</span>) {</div><div class="line">	fmt.Printf(<span class="string">"defer: %d\n"</span>, i)</div><div class="line">}(i)</div><div class="line"></div><div class="line">i =<span class="number"> 50</span></div><div class="line"></div><div class="line"><span class="keyword">defer</span> <span class="keyword">func</span>(i <span class="typename">int</span>) {</div><div class="line">	fmt.Printf(<span class="string">"defer: %d\n"</span>, i) <span class="comment">//50</span></div><div class="line">}(i)</div><div class="line"></div><div class="line">i =<span class="number"> 100</span></div></pre></td></tr></table></figure>

<p>当一个函数中有多个defer语句时，最后的defer语句中函数最先被执行，也就是defer函数的执行是和它的定义成反序。比如上面的代码先输出50,再输出0.</p>
<p>defer语句中函数也可以有返回值，但是返回值会被忽略。</p>
<p>defer语句中如果定义了一个函数字面量(匿名函数)，而且函数中对外部的函数返回参数有所修改的话，修改结果会生效，比如下面的结果，虽然函数最后一个语句返回0,但是defer函数又修改了result的结果，所以f的最终结果为1。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// f 返回 1</span></div><div class="line"><span class="keyword">func</span> f() (result <span class="typename">int</span>) {</div><div class="line">	<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">		result++</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span><span class="number"> 0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>defer语句虽然挺有用处，但是也需要注意它的函数会被推迟到函数返回的时候才会执行。如果defer函数中有对共享资源的占用的释放，比如锁、文件、连接等，等到函数返回才释放会影响程序的性能，所以对资源能今早释放则今早释放，未必非得放在defer函数中释放。</p>
<h3 id="go_语句">go 语句</h3>
<p>go语句将一个函数调用在一个新的goroutine中独立执行。</p>
<p>goroutine是值得仔细介绍的内容，而且goroutine 调度也非常的有趣，这会在下一章中独立介绍。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本章介绍Go语言的各种语句。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go语言 - 6]]></title>
    <link href="http://colobu.com/2016/06/21/dive-into-go-6/"/>
    <id>http://colobu.com/2016/06/21/dive-into-go-6/</id>
    <published>2016-06-21T09:25:44.000Z</published>
    <updated>2016-06-23T10:11:32.000Z</updated>
    <content type="html"><![CDATA[<p>本文介绍 类型转换(Conversion)、类型断言(type assertion) 和类型切换（type switch)。</p>
<p>这三个概念类似但是又完全不同。</p>
<a id="more"></a>
<h3 id="类型转换_Conversion">类型转换 Conversion</h3>
<p>将一个值x转换成特定类型T,格式为 <code>T(x)</code>,非常的简单，类型加小括号即可。</p>
<p>如果类型T以 *、&lt;-、func(不带结果列表)，未避免造成歧义，需要将类型括号包裹起来： <code>(T)(x)</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">*Point(p)        <span class="comment">// same as *(Point(p))</span></div><div class="line">(*Point)(p)      <span class="comment">// p is converted to *Point</span></div><div class="line">&lt;-<span class="keyword">chan</span> <span class="typename">int</span>(c)    <span class="comment">// same as &lt;-(chan int(c))</span></div><div class="line">(&lt;-<span class="keyword">chan</span> <span class="typename">int</span>)(c)  <span class="comment">// c is converted to &lt;-chan int</span></div><div class="line"><span class="keyword">func</span>()(x)        <span class="comment">// function signature func() x</span></div><div class="line">(<span class="keyword">func</span>())(x)      <span class="comment">// x is converted to func()</span></div><div class="line">(<span class="keyword">func</span>() <span class="typename">int</span>)(x)  <span class="comment">// x is converted to func() int</span></div><div class="line"><span class="keyword">func</span>() <span class="typename">int</span>(x)    <span class="comment">// x is converted to func() int (unambiguous)</span></div></pre></td></tr></table></figure>

<p>并不是任意的值都可以转换成类型T, 它需要遵循一定的规则，下面一一道来。</p>
<p>对于一个常量值x, 如果能转换成T类型的值，它需要满足下面的条件之一:</p>
<h4 id="转换常量值">转换常量值</h4>
<ul>
<li>x 可以表达为T的值</li>
<li>x 是浮点数值， T是浮点类型。 x 使用 IEEE 754 round-to-even 规则 且 IEEE -0.0 会进一步舍入到无符号的 0.0， 经过舍入后的x可以表示为T。这一条主要约束浮点数取整的规则，并不是完全按照四舍五入规则计算的。</li>
<li>x是一个整数而T是字符串类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="typename">uint</span>(<span class="constant">iota</span>)               <span class="comment">// iota value of type uint</span></div><div class="line"><span class="typename">float32</span><span class="number">(2.718281828</span>)     <span class="comment">// 2.718281828 of type float32</span></div><div class="line"><span class="typename">complex128</span><span class="number">(1</span>)            <span class="comment">// 1.0 + 0.0i of type complex128</span></div><div class="line"><span class="typename">float32</span><span class="number">(0.49999999</span>)      <span class="comment">// 0.5 of type float32</span></div><div class="line"><span class="typename">float64</span><span class="number">(-1e-1000</span>)        <span class="comment">// 0.0 of type float64</span></div><div class="line"><span class="typename">string</span>(<span class="string">'x'</span>)              <span class="comment">// "x" of type string</span></div><div class="line"><span class="typename">string</span><span class="number">(0</span>x266c)           <span class="comment">// "♬" of type string</span></div><div class="line">MyString(<span class="string">"foo"</span> + <span class="string">"bar"</span>)  <span class="comment">// "foobar" of type MyString</span></div><div class="line"><span class="typename">string</span>([]<span class="typename">byte</span>{<span class="string">'a'</span>})      <span class="comment">// not a constant: []byte{'a'} is not a constant</span></div><div class="line">(*<span class="typename">int</span>)(<span class="constant">nil</span>)              <span class="comment">// not a constant: nil is not a constant, *int is not a boolean, numeric, or string type</span></div><div class="line"><span class="typename">int</span><span class="number">(1.2</span>)                 <span class="comment">// illegal: 1.2 cannot be represented as an int</span></div><div class="line"><span class="typename">string</span><span class="number">(65.0</span>)             <span class="comment">// illegal: 65.0 is not an integer constant</span></div></pre></td></tr></table></figure>

<h4 id="转换变量值">转换变量值</h4>
<p>对于一个常量值x, 如果能转换成T类型的值，它需要满足下面的条件之一:</p>
<ul>
<li>x可以<a href="https://golang.org/ref/spec#Assignability" target="_blank" rel="external">赋值</a>给 T</li>
<li>x的类型和T的底层类型 类型一致</li>
<li>x类型和T 都是未命名的指针类型，它们的指针指向的对象类型 类型一致</li>
<li>x的类型和T都是整数或者浮点数</li>
<li>x的类型和T都是复数</li>
<li>x是整数、slice of byte、slice of rune, T是字符串类型</li>
<li>x是字符串， T是slice of byte 或者slice of rune</li>
</ul>
<p>数值类型和字符串之间的转换可能会改变x的呈现并且会带来运行时的花费。<br>其它的转换只是改变x的类型，不会改变x的呈现。</p>
<p>并没有直接整数和指针之间的转换。但是在前面的章节中也举例了，指针可以通过曲折的方式转换成整数，<br>它是通过包<code>unsafe</code>实现的， 甚至于你通过这种方式还可以访问struct未导出的字段。</p>
<p>类型不一致的两个变量不能赋值, 并且也没有什么强制类型转换的概念：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i1 <span class="typename">int8</span> =<span class="number"> 10</span></div><div class="line"><span class="keyword">var</span> i2 <span class="typename">uint8</span> = i1 <span class="comment">//错误</span></div><div class="line"><span class="keyword">var</span> i3 <span class="typename">uint8</span> = (<span class="typename">uint8</span>)i1 <span class="comment">//错误</span></div></pre></td></tr></table></figure>

<p>比如在类型那一章讲的例子，也是通过这种类型转换实现的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">x := [...]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 4</span>,<span class="number"> 5</span>}</div><div class="line">p := &x<span class="number">[0</span>]</div><div class="line"><span class="comment">//p = p + 1</span></div><div class="line">index2Pointer := unsafe.Pointer(<span class="typename">uintptr</span>(unsafe.Pointer(p)) + unsafe.Sizeof(x<span class="number">[0</span>]))</div><div class="line">p = (*<span class="typename">int</span>)(index2Pointer) <span class="comment">//x[1]</span></div><div class="line">fmt.Printf(<span class="string">"%d\n"</span>, *p)    <span class="comment">//2</span></div></pre></td></tr></table></figure>

<h3 id="类型转换实践">类型转换实践</h3>
<p>这一节介绍常见类型一致的转换。</p>
<h4 id="数值类型之间的转换">数值类型之间的转换</h4>
<p>非常量的数值之间的转换遵循下面三条原则:<br>1、整数之间的转换时，如果值是有符号的整数，它的符号位会扩展无限大，否则零扩展，然后它会被删减以适合结果类型。怎么理解，看例子。<br>对于无符号数v: <code>v := uint16(0x10F0)</code>,如果进行转换<code>uint32(int8(v))</code>,可以看到它的结果是<code>0xFFFFFFF0</code>，不会有溢出指示或者错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">v1 := <span class="typename">uint16</span><span class="number">(0</span>x10F0)</div><div class="line">fmt.Printf(<span class="string">"%d=%b\n"</span>, v1, v1) <span class="comment">//4336=1000011110000</span></div><div class="line"></div><div class="line">v2 := <span class="typename">int8</span>(v1)</div><div class="line">fmt.Printf(<span class="string">"%d=%b\n"</span>, v2, v2) <span class="comment">//-16=-10000</span></div><div class="line"></div><div class="line">v3 := <span class="typename">uint16</span>(v2)</div><div class="line">fmt.Printf(<span class="string">"%d=%b\n"</span>, v3, v3) <span class="comment">//65520=1111111111110000</span></div><div class="line"></div><div class="line">v4 := <span class="typename">int16</span>(v2)</div><div class="line">fmt.Printf(<span class="string">"%d=%b\n"</span>, v4, v4) <span class="comment">//-16=-10000</span></div></pre></td></tr></table></figure>

<p>介绍一下。 对于v1,它是一个无符号的整数， 要把它转为有符号的int8，那么我们只看v1的后8位:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1111 0000</div></pre></td></tr></table></figure>

<p>不幸的是，这个8位的最高位是1,我们会把它作为符号位，所以v2是个负数，那么<code>11110000</code>就是这个负数的补码，<br>那么它的原码是多少呢，计算补码的补码就是负数的原码:<code>1001 0000</code>,所以它是-16。如果最高位是0，简单了，本身就是它的原码。</p>
<p>再看v2转v3， 也就是有符号整数转无符号整数。v2是负数，内部表示为<code>11110000</code>,因为要扩展为16位，将符号位1扩展到最高位<code>1111 1111 1111 0000</code>,因为它是无符号整数，所以这个值整数的值65520。</p>
<p>你可以把v1值的值改为0xff60看看输出是什么？此时转换不会符号位为负数的情况。</p>
<blockquote>
<p>补码（two&#39;s complement) 指的是正数=原码，负数=反码加一<br>反码（ones&#39; complement) 指的就是通常所指的反码。<br>对一个整数的补码再求补码，等于该整数自身。<br>补码的正零与负零表示方法相同。</p>
</blockquote>
<p>2、浮点数转换成整数时，小数部分被丢弃,也就是朝0方向舍入。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> v1 <span class="typename">float32</span> =<span class="number"> 0.999999</span></div><div class="line">fmt.Println(<span class="typename">int</span>(v1))</div><div class="line">v1 =<span class="number"> -0.999999</span></div><div class="line">fmt.Println(<span class="typename">int</span>(v1))</div></pre></td></tr></table></figure>

<p>3、当转换整数或者浮点数到浮点数的时候，或者一个复数到另一个复数， 结果值会被舍入到目标类型的精度。例如类型为float32的变量x可以通过附加的精度超过标准的IEEE-754 32-bit数， 但是float32(x)代表x的值舍入到 IEEE-754 32 bit的精度。类似地， x + 0.1 可以使用超过32 bit的精度，但是float32(x + 0.1) 肯定是32 bit的精度。</p>
<blockquote>
<p>the value of a variable x of type float32 may be stored using additional precision beyond that of an IEEE-754 32-bit number, but float32(x) represents the result of rounding x&#39;s value to 32-bit precision. Similarly, x + 0.1 may use more than 32 bits of precision, but float32(x + 0.1) does not.</p>
</blockquote>
<p>关于浮点数格式IEEE-754, 随便一本计算机原理的教材中都会介绍，网上也有无数的文章介绍，它由三个域组成，float32中分别占1位、8位、和 23位,本文中就不详细介绍了。<br><img src="float32.png" alt="float32"></p>
<h4 id="整数和bool之间的转换">整数和bool之间的转换</h4>
<p>虽然有人提议实现快速的整数和bool之间的转换，但是目前看起来还没有实现，所以下面的语句是不对的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">i1 :=<span class="number"> 1</span></div><div class="line">i2 :=<span class="number"> 0</span></div><div class="line">fmt.Printf(<span class="string">"%t %t\n"</span>, <span class="typename">bool</span>(i1), <span class="typename">bool</span>(i2))</div></pre></td></tr></table></figure>

<p>但是你完全可以通过其它方式实现， 比如判断语句 <code>n &gt; 0</code>, 或者利用一个定义好的表(map,数组等)进行查表转换。</p>
<p>参考</p>
<ul>
<li><a href="https://github.com/golang/go/issues/6011" target="_blank" rel="external">https://github.com/golang/go/issues/6011</a></li>
<li><a href="https://github.com/golang/go/issues/7657" target="_blank" rel="external">https://github.com/golang/go/issues/7657</a></li>
</ul>
<h4 id="基于字节的字符串的转换">基于字节的字符串的转换</h4>
<p>字符串代表一串字节流，所以很容易的和slice of byte, slice of rune进行转换。<br>1、无符号整数或者有符号整数通过它对应的UTF-8编码转换成字符串。合法的Unicode code之外的值都被转换成<code>\uFFFD</code>。这里的整数也包含rune.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="typename">string</span>(<span class="string">'a'</span>)       <span class="comment">// "a"</span></div><div class="line"><span class="typename">string</span><span class="number">(-1</span>)        <span class="comment">// "\ufffd" == "\xef\xbf\xbd"</span></div><div class="line"><span class="typename">string</span><span class="number">(0</span>xf8)      <span class="comment">// "\u00f8" == "ø" == "\xc3\xb8"</span></div><div class="line"><span class="keyword">type</span> MyString <span class="typename">string</span></div><div class="line">MyString<span class="number">(0</span>x65e5)  <span class="comment">// "\u65e5" == "日" == "\xe6\x97\xa5"</span></div></pre></td></tr></table></figure>

<p>2、字节slice根据UTF-8编码产生字符串</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="typename">string</span>([]<span class="typename">byte</span>{<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'\xc3'</span>, <span class="string">'\xb8'</span>})   <span class="comment">// "hellø"</span></div><div class="line"><span class="typename">string</span>([]<span class="typename">byte</span>{})                                     <span class="comment">// ""</span></div><div class="line"><span class="typename">string</span>([]<span class="typename">byte</span>(<span class="constant">nil</span>))                                  <span class="comment">// ""</span></div></pre></td></tr></table></figure>

<p>3、将rune slice转换成字符串相当于将rune连接起来</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="typename">string</span>([]<span class="typename">rune</span><span class="number">{0</span>x9E1F,<span class="number"> 0</span>x7A9D})   <span class="comment">// "\u9e1f\u7a9d" == "鸟窝"</span></div><div class="line"><span class="typename">string</span>([]<span class="typename">rune</span>{})                         <span class="comment">// ""</span></div><div class="line"><span class="typename">string</span>([]<span class="typename">rune</span>(<span class="constant">nil</span>))                      <span class="comment">// ""</span></div></pre></td></tr></table></figure>

<p>4、将字符串转为byte slice会将字符串的字节流复制到一个byte slice</p>
<p>5、将一个字符串转为rune slice会将产生一个新的rune slice,包含字符串中每个rune</p>
<h4 id="字符串和基本类型之间的转换">字符串和基本类型之间的转换</h4>
<p>包strconv提供了字符串和基本数据类型的转换。上面我们提到了字符串和整数之间的转换，但是有时候我们需要的是将 12转换成字符串 &quot;12&quot;，或者从字符串中解析处一个整数，这个时候就可以使用这个包。</p>
<p>首先它提供了一组往byte slice增加基本类型元素的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> AppendBool(dst []<span class="typename">byte</span>, b <span class="typename">bool</span>) []<span class="typename">byte</span></div><div class="line"><span class="keyword">func</span> AppendFloat(dst []<span class="typename">byte</span>, f <span class="typename">float64</span>, fmt <span class="typename">byte</span>, prec, bitSize <span class="typename">int</span>) []<span class="typename">byte</span></div><div class="line"><span class="keyword">func</span> AppendInt(dst []<span class="typename">byte</span>, i <span class="typename">int64</span>, base <span class="typename">int</span>) []<span class="typename">byte</span></div><div class="line"><span class="keyword">func</span> AppendQuote(dst []<span class="typename">byte</span>, s <span class="typename">string</span>) []<span class="typename">byte</span></div><div class="line"><span class="keyword">func</span> AppendQuoteRune(dst []<span class="typename">byte</span>, r <span class="typename">rune</span>) []<span class="typename">byte</span></div><div class="line"><span class="keyword">func</span> AppendQuoteRuneToASCII(dst []<span class="typename">byte</span>, r <span class="typename">rune</span>) []<span class="typename">byte</span></div><div class="line"><span class="keyword">func</span> AppendQuoteRuneToGraphic(dst []<span class="typename">byte</span>, r <span class="typename">rune</span>) []<span class="typename">byte</span></div><div class="line"><span class="keyword">func</span> AppendQuoteToASCII(dst []<span class="typename">byte</span>, s <span class="typename">string</span>) []<span class="typename">byte</span></div><div class="line"><span class="keyword">func</span> AppendQuoteToGraphic(dst []<span class="typename">byte</span>, s <span class="typename">string</span>) []<span class="typename">byte</span></div><div class="line"><span class="keyword">func</span> AppendUint(dst []<span class="typename">byte</span>, i <span class="typename">uint64</span>, base <span class="typename">int</span>) []<span class="typename">byte</span></div></pre></td></tr></table></figure>

<p>一组从字符串中解析出基本类型的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> ParseBool(str <span class="typename">string</span>) (value <span class="typename">bool</span>, err error)</div><div class="line"><span class="keyword">func</span> ParseFloat(s <span class="typename">string</span>, bitSize <span class="typename">int</span>) (f <span class="typename">float64</span>, err error)</div><div class="line"><span class="keyword">func</span> ParseInt(s <span class="typename">string</span>, base <span class="typename">int</span>, bitSize <span class="typename">int</span>) (i <span class="typename">int64</span>, err error)</div><div class="line"><span class="keyword">func</span> ParseUint(s <span class="typename">string</span>, base <span class="typename">int</span>, bitSize <span class="typename">int</span>) (n <span class="typename">uint64</span>, err error)</div></pre></td></tr></table></figure>

<p>一组为字符串或者rune加引号和剥离引号的方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Quote(s <span class="typename">string</span>) <span class="typename">string</span></div><div class="line"><span class="keyword">func</span> QuoteRune(r <span class="typename">rune</span>) <span class="typename">string</span></div><div class="line"><span class="keyword">func</span> QuoteRuneToASCII(r <span class="typename">rune</span>) <span class="typename">string</span></div><div class="line"><span class="keyword">func</span> QuoteRuneToGraphic(r <span class="typename">rune</span>) <span class="typename">string</span></div><div class="line"><span class="keyword">func</span> QuoteToASCII(s <span class="typename">string</span>) <span class="typename">string</span></div><div class="line"><span class="keyword">func</span> QuoteToGraphic(s <span class="typename">string</span>) <span class="typename">string</span></div><div class="line"><span class="keyword">func</span> Unquote(s <span class="typename">string</span>) (t <span class="typename">string</span>, err error)</div><div class="line"><span class="keyword">func</span> UnquoteChar(s <span class="typename">string</span>, quote <span class="typename">byte</span>) (value <span class="typename">rune</span>, multibyte <span class="typename">bool</span>, tail <span class="typename">string</span>, err error)</div></pre></td></tr></table></figure>

<p>一组检查字符串或者rune为特定类型的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> CanBackquote(s <span class="typename">string</span>) <span class="typename">bool</span></div><div class="line"><span class="keyword">func</span> IsGraphic(r <span class="typename">rune</span>) <span class="typename">bool</span></div><div class="line"><span class="keyword">func</span> IsPrint(r <span class="typename">rune</span>) <span class="typename">bool</span></div></pre></td></tr></table></figure>

<p>一组格式化基本类型为字符串的方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> FormatBool(b <span class="typename">bool</span>) <span class="typename">string</span></div><div class="line"><span class="keyword">func</span> FormatFloat(f <span class="typename">float64</span>, fmt <span class="typename">byte</span>, prec, bitSize <span class="typename">int</span>) <span class="typename">string</span></div><div class="line"><span class="keyword">func</span> FormatInt(i <span class="typename">int64</span>, base <span class="typename">int</span>) <span class="typename">string</span></div><div class="line"><span class="keyword">func</span> FormatUint(i <span class="typename">uint64</span>, base <span class="typename">int</span>) <span class="typename">string</span></div></pre></td></tr></table></figure>

<p>重要的放在最后说，我们在编程中更多的用到的两个方法, 整数字面值和字符串之间的转换:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Atoi(s <span class="typename">string</span>) (i <span class="typename">int</span>, err error)</div><div class="line"><span class="keyword">func</span> Itoa(i <span class="typename">int</span>) <span class="typename">string</span></div></pre></td></tr></table></figure>

<p>参考</p>
<ul>
<li><a href="https://golang.org/pkg/strconv/" target="_blank" rel="external">https://golang.org/pkg/strconv/</a></li>
</ul>
<h4 id="字节slice和整数之间的转换">字节slice和整数之间的转换</h4>
<p>包 encoding/binary实现了数值和字节序列之间的转换，包含变长int的各种编解码。</p>
<p>Go中的数值类型都是固定长度的位数(int8, uint8, int16, float32, complex64)，所以组成这些数组的bit可以转换成各种字节slice。</p>
<p>变长int (varint)经常用于节省空间，比如一个， Go实现的varint规范可以参考<a href="https://developers.google.com/protocol-buffers/docs/encoding" target="_blank" rel="external">proto-buff的实现</a>。很多编解码库中都使用了变长的int，这样对于大量的小数字我们可以用更少的字节来表示，对于网络传输来说很有好处。</p>
<p>这个包经常用在网络传输的序列化和反序列中。</p>
<p>另外一个值得注意的是数值是由多个字节组成的，这就涉及到字节序的问题，你必须指定使用小端序或大端序。</p>
<p>首先看一下定长的数值的转换，主要是<code>Read</code>和<code>Write</code>两个方法，底层还是通过移位操作实现的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Read(r io.Reader, order ByteOrder, data <span class="keyword">interface</span>{}) error</div><div class="line"><span class="keyword">func</span> Write(w io.Writer, order ByteOrder, data <span class="keyword">interface</span>{}) error</div></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"bytes"</span></div><div class="line">	<span class="string">"encoding/binary"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	b := write()</div><div class="line">	read(b)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> write() []<span class="typename">byte</span> {</div><div class="line">	buf := <span class="built_in">new</span>(bytes.Buffer)</div><div class="line">	<span class="keyword">var</span> data = []<span class="keyword">interface</span>{}{</div><div class="line">		<span class="typename">uint16</span><span class="number">(61374</span>), <span class="comment">//efbe</span></div><div class="line">		<span class="typename">int8</span><span class="number">(-54</span>),     <span class="comment">//-36</span></div><div class="line">		<span class="typename">uint8</span><span class="number">(254</span>),    <span class="comment">//fe</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> data {</div><div class="line">		err := binary.Write(buf, binary.BigEndian, v)</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			fmt.Println(<span class="string">"binary.Write failed:"</span>, err)</div><div class="line">		}</div><div class="line">	}</div><div class="line">	fmt.Printf(<span class="string">"%x\n"</span>, buf.Bytes()) <span class="comment">//efbecafe</span></div><div class="line">	<span class="keyword">return</span> buf.Bytes()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> read(b []<span class="typename">byte</span>) {</div><div class="line">	<span class="keyword">var</span> i1 <span class="typename">uint16</span></div><div class="line">	<span class="keyword">var</span> i2 <span class="typename">int8</span></div><div class="line">	<span class="keyword">var</span> i3 <span class="typename">uint8</span></div><div class="line"></div><div class="line">	buf := bytes.NewReader(b)</div><div class="line">	err := binary.Read(buf, binary.BigEndian, &i1)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Println(<span class="string">"binary.Read failed:"</span>, err)</div><div class="line">	}</div><div class="line">	err = binary.Read(buf, binary.BigEndian, &i2)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Println(<span class="string">"binary.Read failed:"</span>, err)</div><div class="line">	}</div><div class="line">	err = binary.Read(buf, binary.BigEndian, &i3)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Println(<span class="string">"binary.Read failed:"</span>, err)</div><div class="line">	}</div><div class="line"></div><div class="line">	fmt.Println(i1, i2, i3) <span class="comment">//61374 -54 254</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>一种不通用的适合特定类型的转换也可以使用下面的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> readInt32(b []<span class="typename">byte</span>) <span class="typename">int32</span> {</div><div class="line">    <span class="comment">// equivalnt of return int32(binary.LittleEndian.Uint32(b))</span></div><div class="line">    <span class="keyword">return</span> <span class="typename">int32</span>(<span class="typename">uint32</span>(b<span class="number">[0</span>]) | <span class="typename">uint32</span>(b<span class="number">[1</span>])&lt;<span class="number">&lt;8</span> | <span class="typename">uint32</span>(b<span class="number">[2</span>])&lt;<span class="number">&lt;16</span> | <span class="typename">uint32</span>(b<span class="number">[3</span>])&lt;<span class="number">&lt;24</span>)</div><div class="line">}</div><div class="line"><span class="comment">//或者</span></div><div class="line"><span class="keyword">func</span> ReadInt32Unsafe(b []<span class="typename">byte</span>) <span class="typename">int32</span> {</div><div class="line">    <span class="keyword">return</span> *(*<span class="typename">int32</span>)(unsafe.Pointer(&b<span class="number">[0</span>]))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>变长int的操作函数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> PutUvarint(buf []<span class="typename">byte</span>, x <span class="typename">uint64</span>) <span class="typename">int</span></div><div class="line"><span class="keyword">func</span> PutVarint(buf []<span class="typename">byte</span>, x <span class="typename">int64</span>) <span class="typename">int</span></div><div class="line"><span class="keyword">func</span> Uvarint(buf []<span class="typename">byte</span>) (<span class="typename">uint64</span>, <span class="typename">int</span>)</div><div class="line"><span class="keyword">func</span> Varint(buf []<span class="typename">byte</span>) (<span class="typename">int64</span>, <span class="typename">int</span>)</div><div class="line"><span class="keyword">func</span> ReadUvarint(r io.ByteReader) (<span class="typename">uint64</span>, error)</div><div class="line"><span class="keyword">func</span> ReadVarint(r io.ByteReader) (<span class="typename">int64</span>, error)</div></pre></td></tr></table></figure>

<p>以及一个对象被转换成多少字节的方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Size(v <span class="keyword">interface</span>{}) <span class="typename">int</span></div></pre></td></tr></table></figure>

<p>参考</p>
<ul>
<li><a href="https://golang.org/pkg/encoding/binary/" target="_blank" rel="external">https://golang.org/pkg/encoding/binary/</a></li>
<li><a href="https://zh.wikipedia.org/wiki/字节序#.E5.AD.97.E8.8A.82.E9.A1.BA.E5.BA.8F" target="_blank" rel="external">https://zh.wikipedia.org/wiki/字节序#.E5.AD.97.E8.8A.82.E9.A1.BA.E5.BA.8F</a></li>
<li><a href="http://codereview.stackexchange.com/questions/15945/effectively-convert-little-endian-byte-slice-to-int32" target="_blank" rel="external">http://codereview.stackexchange.com/questions/15945/effectively-convert-little-endian-byte-slice-to-int32</a></li>
</ul>
<h4 id="数组和slice之间的转换">数组和slice之间的转换</h4>
<p>数组转换成slice很简单，前面讲到了，利用索引运算：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a[low:high]</div><div class="line">a[low:high:max]</div></pre></td></tr></table></figure>

<p>而slice转数组，我们可以好好分析一下。</p>
<p>slice的底层实现是数组，所以有一个&quot;hack&quot;方法，将slice的底层数组返回:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"reflect"</span></div><div class="line">    <span class="string">"unsafe"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> SIZEOF_INT32 =<span class="number"> 4</span> <span class="comment">// bytes</span></div><div class="line"></div><div class="line"><span class="comment">// Get the slice header</span></div><div class="line">header := *(*reflect.SliceHeader)(unsafe.Pointer(&raw))</div><div class="line"></div><div class="line"><span class="comment">// The length and capacity of the slice are different.</span></div><div class="line">header.Len /= SIZEOF_INT32</div><div class="line">header.Cap /= SIZEOF_INT32</div><div class="line"></div><div class="line"><span class="comment">// Convert slice header to an []int32</span></div><div class="line">data := *(*[]<span class="typename">int32</span>)(unsafe.Pointer(&header))</div></pre></td></tr></table></figure>

<p>安全的方式是生成数组然后依次赋值，注意copy是不行的，因为copy的参数必须都是slice:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"encoding/binary"</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> SIZEOF_INT32 =<span class="number"> 4</span> <span class="comment">// bytes</span></div><div class="line"></div><div class="line">data := <span class="built_in">make</span>([]<span class="typename">int32</span>, <span class="built_in">len</span>(raw)/SIZEOF_INT32)</div><div class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> data {</div><div class="line">    <span class="comment">// assuming little endian</span></div><div class="line">    data[i] = <span class="typename">int32</span>(binary.LittleEndian.Uint32(raw[i*SIZEOF_INT32:(i<span class="number">+1</span>)*SIZEOF_INT32]))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>参考</p>
<ul>
<li><a href="http://stackoverflow.com/questions/19073769/in-golang-how-do-you-convert-a-slice-into-an-array" target="_blank" rel="external">http://stackoverflow.com/questions/19073769/in-golang-how-do-you-convert-a-slice-into-an-array</a></li>
<li><a href="http://stackoverflow.com/questions/11924196/convert-between-slices-of-different-types" target="_blank" rel="external">http://stackoverflow.com/questions/11924196/convert-between-slices-of-different-types</a></li>
<li><a href="https://groups.google.com/forum/#!topic/golang-nuts/yNis7bQG_rY" target="_blank" rel="external">https://groups.google.com/forum/#!topic/golang-nuts/yNis7bQG_rY</a></li>
</ul>
<h4 id="struct和字符串之间的转换">struct和字符串之间的转换</h4>
<p>struct类型的值和字符串之间的转换我们称之为marshal和unmarshal。<br>有非常多的库可以做这个事情，比如gob, encoding/json等。</p>
<p>Go序列化框架的性能比较可以参照我的一个开源项目: <a href="https://github.com/smallnest/gosercomp" target="_blank" rel="external">gosercomp</a>。</p>
<h3 id="类型断言_type_assertion">类型断言 type assertion</h3>
<p>和上节的类型转换不同，类型断言是将接口类型的值x，转换成类型T。</p>
<p>格式为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x.(T)</div><div class="line">v := x.(T)</div><div class="line">v, ok := x.(T)</div></pre></td></tr></table></figure>

<p>类型断言的必要条件是x是接口类型,非接口类型的x不能做类型断言:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i <span class="typename">int</span> =<span class="number"> 10</span></div><div class="line">v := i.(<span class="typename">int</span>) <span class="comment">//错误</span></div></pre></td></tr></table></figure>

<p>T可以是非接口类型，如果想断言合法，则T应该实现x的接口。</p>
<p>T也可以是接口，则x的动态类型也应该实现接口T。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>{} =<span class="number"> 7</span>  <span class="comment">// x 的动态类型为int， 值为 7</span></div><div class="line">i := x.(<span class="typename">int</span>)           <span class="comment">// i 的类型为 int， 值为 7</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> { m() }</div><div class="line"><span class="keyword">var</span> y I</div><div class="line">s := y.(<span class="typename">string</span>)        <span class="comment">// 非法: string 没有实现接口 I (missing method m)</span></div><div class="line">r := y.(io.Reader)     <span class="comment">// y如果实现了接口io.Reader和I的情况下，  r的类型则为io.Reader</span></div></pre></td></tr></table></figure>

<p>类型断言如果非法，运行时时候就会出现 impossible type assertion panic，为了避免这种情况，可以使用下面的语法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">v, ok = x.(T)</div><div class="line">v, ok := x.(T)</div><div class="line"><span class="keyword">var</span> v, ok = x.(T)</div></pre></td></tr></table></figure>

<p>ok代表类型断言是否合法，如果非法ok =false,v为T的零值，这样就不会出现运行时panic了。</p>
<p>希望你能记住，类型转换和类型断言完全是两个概念。</p>
<h3 id="类型切换_type_switch">类型切换 type switch</h3>
<p>类型切换(暂且这么翻译吧，英语更准确)用来比较类型而不是对值进行比较。</p>
<p>switch语句虽然在下一章中去讲，但是对于读者来说，多少会一种或者几种常用的编程语言，switch是一个条件语句，它可以判断某个值是否匹配某个case clause。但是对于type switch，它检查的是值x的类型T是否匹配某个类型。</p>
<p>格式如下，类型类型断言，但是括号内的不是某个具体的类型，而是单词<code>type</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> x.(<span class="keyword">type</span>) {</div><div class="line"><span class="comment">// cases</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>type switch语句中可以有一个简写的变量声明，这种情况下，等价于这个变量声明在每个case clause隐式代码块的开始位置。如果case clause只列出了一个类型，则变量的类型就是这个类型，否则就是原始值的类型。</p>
<p>假设下面的例子中x的类型为x interface{}</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> i := x.(<span class="keyword">type</span>) {</div><div class="line"><span class="keyword">case</span> <span class="constant">nil</span>:</div><div class="line">  printString(<span class="string">"x is nil"</span>) <span class="comment">// i的类型是 x的类型 (interface{})</span></div><div class="line"><span class="keyword">case</span> <span class="typename">int</span>:</div><div class="line">  printInt(i) <span class="comment">// i的类型 int</span></div><div class="line"><span class="keyword">case</span> <span class="typename">float64</span>:</div><div class="line">  printFloat64(i) <span class="comment">// i的类型是 float64</span></div><div class="line"><span class="keyword">case</span> <span class="keyword">func</span>(<span class="typename">int</span>) <span class="typename">float64</span>:</div><div class="line">  printFunction(i) <span class="comment">// i的类型是 func(int) float64</span></div><div class="line"><span class="keyword">case</span> <span class="typename">bool</span>, <span class="typename">string</span>:</div><div class="line">  printString(<span class="string">"type is bool or string"</span>) <span class="comment">// i的类型是 x (interface{})</span></div><div class="line"><span class="keyword">default</span>:</div><div class="line">  printString(<span class="string">"don't know the type"</span>) <span class="comment">// i的类型是 x的类型 (interface{})</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>也许你已经看到上面的例子中有一个case clause中的类型是nil,它用来匹配x为nil的interface{}的情况。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文介绍 类型转换(Conversion)、类型断言(type assertion) 和类型切换（type switch)。</p>
<p>这三个概念类似但是又完全不同。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go语言 - 5]]></title>
    <link href="http://colobu.com/2016/06/20/dive-into-go-5/"/>
    <id>http://colobu.com/2016/06/20/dive-into-go-5/</id>
    <published>2016-06-20T08:00:41.000Z</published>
    <updated>2016-06-21T08:57:05.000Z</updated>
    <content type="html"><![CDATA[<p>本文介绍Go语言的表达式。</p>
<p>表达式代表一个值的计算， 计算通过运算符和函数应用在操作数上(operand)。<br><a id="more"></a></p>
<p>操作数代表表达式中的基本值。它可以字面量，标识符。 标识符表示常量、变量、函数、方法表达式、或者一个括号表达式。</p>
<p>空标识符“_”只能出现在赋值语句的左边。</p>
<p>包代码块中定义的标识符通过 <code>package.identifier</code>访问。</p>
<p>表达式的形式有多种，可以参看官方文档: <a href="https://golang.org/ref/spec#Primary_expressions" target="_blank" rel="external">Primary expressions</a>。</p>
<p>以下都是合法的表达式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">x<span class="number"></span></div><div class="line">2</div><div class="line">(s + <span class="string">".txt"</span>)</div><div class="line">f<span class="number">(3.1415</span>, <span class="constant">true</span>)</div><div class="line">Point<span class="number">{1</span>,<span class="number"> 2</span>}</div><div class="line">m[<span class="string">"foo"</span>]</div><div class="line">s[i : j +<span class="number"> 1</span>]</div><div class="line">obj.color</div><div class="line">f.p[i].x()</div><div class="line">i.(<span class="typename">int</span>)</div></pre></td></tr></table></figure>

<p>重点介绍Go语言规范中的以下表达式。</p>
<h3 id="Selector">Selector</h3>
<p>假定x不是包名，selector表达式表示如下: <code>x.f</code>。<br>它表示f是x (或者*x)的字段或者方法。其中标识符f称为selector。</p>
<p>selector f可以是类型T的字段或者方法，也可以是T的匿名嵌套字段的字段和方法。 可以递归地通过匿名字段进行查找，匿名字段递归查找f的数量称之为它在T中的深度。T中声明的字段和方法的深度为0。</p>
<p>selector有以下特性：<br>1、对于类型为 <code>T</code> 或 <code>*T</code>的值x, 当 T 不是指针类型或者接口类型时，x.f 代表 T 的 最小深度的字段或者方法 f。 如果同一深度有多个f， 那么selector表达式就是错误的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> S1 <span class="keyword">struct</span> {</div><div class="line">}</div><div class="line"><span class="keyword">func</span> (s S1) Say() {</div><div class="line"></div><div class="line">}</div><div class="line"><span class="keyword">type</span> S2 <span class="keyword">struct</span> {</div><div class="line">}</div><div class="line"><span class="keyword">func</span> (s S2) Say() {</div><div class="line"></div><div class="line">}</div><div class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> {</div><div class="line">	S1</div><div class="line">	S2</div><div class="line">}</div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> s S</div><div class="line">	s.Say()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>2、对于类型为I的值x, 如果I是接口类型，那么 x.f 代表 x的动态类型的实际方法 f。 如果 I 接口的方法集中没有方法f, 则selector表达式非法。<br>3、一个特例。如果x的类型是一个命名的指针类型，并且(*x).f代表字段f(不是方法),可以简写为 x.f。<br>4、其它情况 x.f 都是非法的。<br>5、如果 x是一个指针类型，它的值是 nil。则 x.f 会导致运行时panic。<br>6、如果x的类型I是接口类型，并且值为 nil， 则x.f会导致运行时panic。</p>
<p>我们首先定义两个类型<code>T0</code>、<code>T1</code>,分别包含一个方法<code>M0</code>和<code>M1</code>，类型参数分别为<code>*T0</code>、<code>T1</code>。</p>
<p>然后定义一个类型<code>T2</code>，嵌入<code>T1</code>和<code>*T0</code>，还包含一个方法<code>M2</code>，类型参数为<code>*T2</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> T0 <span class="keyword">struct</span> {</div><div class="line">	x <span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (*T0) M0() {}</div><div class="line"></div><div class="line"><span class="keyword">type</span> T1 <span class="keyword">struct</span> {</div><div class="line">	y <span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (T1) M1() {}</div><div class="line"></div><div class="line"><span class="keyword">type</span> T2 <span class="keyword">struct</span> {</div><div class="line">	z <span class="typename">int</span></div><div class="line">	T1</div><div class="line">	*T0</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (*T2) M2() {}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Q *T2</div><div class="line"></div><div class="line"><span class="keyword">var</span> t T2 = T2{T1: T1{}, T0: &T0{}}</div><div class="line"><span class="keyword">var</span> p *T2 = &T2{T1: T1{}, T0: &T0{}}</div><div class="line"><span class="keyword">var</span> q Q = p</div></pre></td></tr></table></figure>

<p>则下面的表达式都是合法的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	_ = t.z <span class="comment">// t.z</span></div><div class="line">	_ = t.y <span class="comment">// t.T1.y</span></div><div class="line">	_ = t.x <span class="comment">// (*t.T0).x</span></div><div class="line"></div><div class="line">	_ = p.z <span class="comment">// (*p).z</span></div><div class="line">	_ = p.y <span class="comment">// (*p).T1.y</span></div><div class="line">	_ = p.x <span class="comment">// (*(*p).T0).x</span></div><div class="line"></div><div class="line">	_ = q.x <span class="comment">// (*(*q).T0).x        (*q).x is a valid field selector</span></div><div class="line"></div><div class="line">	p.M0() <span class="comment">// ((*p).T0).M0()      M0 expects *T0 receiver</span></div><div class="line">	p.M1() <span class="comment">// ((*p).T1).M1()      M1 expects T1 receiver</span></div><div class="line">	p.M2() <span class="comment">// p.M2()              M2 expects *T2 receiver</span></div><div class="line">	t.M2() <span class="comment">// (&t).M2()           M2 expects *T2 receiver, see section on Calls</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>但是下面的表达式非法(违反规则3)：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">q.M0()       <span class="comment">// (*q).M0 is valid but not a field selector</span></div></pre></td></tr></table></figure>

<h3 id="方法表达式">方法表达式</h3>
<p>如果M在类型T的方法集中，T.M可以当作一个普通的函数调用，它的第一个参数需要传入receiver的值。</p>
<p>考虑到下面的结构体S:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> {</div><div class="line">	Name <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s S) M1(i <span class="typename">int</span>) {</div><div class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, s)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s *S) M2(f <span class="typename">float32</span>) {</div><div class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, s)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>和变量 <code>var s = S{&quot;bird&quot;}</code>,下面的6组表达式都是等价的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">s.M1<span class="number">(1</span>)</div><div class="line">S.M1(s<span class="number">,1</span>)</div><div class="line">(S).M1(s<span class="number">,1</span>)</div><div class="line">f1 := S.M1;f1(s<span class="number">,1</span>)</div><div class="line">f2 := (S).M1;f2(s<span class="number">,1</span>)</div><div class="line">f3 := s.M1;f3<span class="number">(1</span>)</div></pre></td></tr></table></figure>

<p>类似地，<code>(*S).M2</code>也会产生下面的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span>(t *T, <span class="typename">float32</span>)</div></pre></td></tr></table></figure>

<p>对于receiver为value receiver的方法, <code>(*S).M1</code>还会产生下面的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span>(s *S, i <span class="typename">int</span>)</div></pre></td></tr></table></figure>

<p>注意这个方法会为传入的receiver创建一个值，这个方法不会覆盖传入的指针指向的值。</p>
<p>如果x的静态类型为T, M是T的方法集里面的一个方法。 则x.M称之为方法值(method value)。方法值是一个函数，参数和x.M的参数一样。T可以是接口类型或者非接口类型。</p>
<p>Go语言规定，一个指针可以调用value receiver的非接口方法：<code>pt.M1</code>等价于<code>(*pt).M1</code>。<br>而一个值可以调用pointer receiver的非接口方法:<code>s.M2</code>等价于<code>(&amp;s).M2</code>,它会把这个值的地址作为参数。</p>
<p>因此，对于非接口方法，不管它的reeiver是poiter还是value，值对象和指针对象都可以调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> {</div><div class="line">	Name <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s S) M1() {</div><div class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, s)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s *S) M2() {</div><div class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, s)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> s1 = S{<span class="string">"bird"</span>}</div><div class="line">	<span class="keyword">var</span> s2 = &s1</div><div class="line"></div><div class="line">	s1.M1()</div><div class="line">	s1.M2()</div><div class="line">	s2.M1()</div><div class="line">	s2.M2()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意，前面已经讲到，通过指针调用value receiver的方法不会改变指针指向的对象的值，因为它会复制一份value,而不是把自己的value值传入方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> {</div><div class="line">	Name <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s S) M1() {</div><div class="line">	s.Name = <span class="string">"bird1"</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s *S) M2() {</div><div class="line">	s.Name = <span class="string">"bird2"</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> s1 = S{<span class="string">"bird"</span>}</div><div class="line">	<span class="keyword">var</span> s2 = &s1</div><div class="line">	s1.M2()</div><div class="line">	fmt.Printf(<span class="string">"%+v, %+v\n"</span>, s1, s2) <span class="comment">//{Name:bird2}, &{Name:bird2}</span></div><div class="line"></div><div class="line">	s1 = S{<span class="string">"bird"</span>}</div><div class="line">	s2 = &s1</div><div class="line">	s2.M1()</div><div class="line">	fmt.Printf(<span class="string">"%+v, %+v\n"</span>, s1, s2)<span class="comment">//{Name:bird}, &{Name:bird}</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>甚至，函数也可以有方法,比如常见的官方库中的<code>HandlerFunc</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> HandlerFunc <span class="keyword">func</span>(ResponseWriter, *Request)</div><div class="line"></div><div class="line"><span class="keyword">func</span> (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {</div><div class="line">	f(w, r)</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="索引表达式">索引表达式</h3>
<p>索引表达式<code>a[x]</code>可以用于数组、数组指针、slice、字符串和map。</p>
<p>对于非map的对象：</p>
<ul>
<li>索引值x必须是integer类型或者未声明类型的类型，并且 <code>0 &lt;= x &lt; len(a)</code></li>
<li>常数索引值必须非负，而且可以表现为int类型的值</li>
</ul>
<p>索引的以下内容你应该都很熟悉了，可以选择跳过去。</p>
<p>对于数组：</p>
<ul>
<li>索引不能越界</li>
<li>越界的话会发生运行时panic</li>
<li>a[x]是索引在x处的元素，索引值以0开始</li>
</ul>
<p>对于数组指针</p>
<ul>
<li>a[x] 是 (*a)[x]的简写</li>
</ul>
<p>对于slice类型S:</p>
<ul>
<li>x越界，运行时panic</li>
<li>a[x]是索引在x处的元素，索引值以0开始</li>
</ul>
<p>对于字符串类型：</p>
<ul>
<li>x不能越界</li>
<li>x越界，运行时panic</li>
<li>a[x]是索引在x处的非常量 byte值</li>
<li>不能给 a[x]赋值</li>
</ul>
<p>对于map类型：</p>
<ul>
<li>x必须可以赋值map的键类型，参照上一章的类型赋值规则</li>
<li>如果map包含键为x的entry,那么a[x]就是值对象</li>
<li>如果map是nil或者map不包含这个entry, a[x]是值类型的零值</li>
</ul>
<p>当然map类型还有一个特殊格式，就是可以同时返回x是否存在于map中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">v, ok = a[x]</div><div class="line">v, ok := a[x]</div><div class="line"><span class="keyword">var</span> v, ok = a[x]</div></pre></td></tr></table></figure>

<p>如果x存在于map中，则v返回它的值，ok 为 true,否则 ok 为 false。</p>
<h3 id="slice表达式">slice表达式</h3>
<p>字符串、数组、数组指针、slice可以通过下面的方式得到一个子字符串或者slice:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[low:high]</div></pre></td></tr></table></figure>

<p>当然其中<code>low</code>、<code>high</code>都可以忽略。默认low = 0, high = 操作数的最大长度。注意结果的范围是左闭右开的： a[low] &lt;= …… &lt; a[high],</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a<span class="number">[2</span>:]  <span class="comment">// same as a[2 : len(a)]</span></div><div class="line">a[<span class="number">:3</span>]  <span class="comment">// same as a[0 : 3]</span></div><div class="line">a[:]   <span class="comment">// same as a[0 : len(a)]</span></div></pre></td></tr></table></figure>

<p>对于数组、数组指针和slice (不包含字符串)，索引表达式还有下面的形式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[low : high : max]</div></pre></td></tr></table></figure>

<p>它和<code>a[low:high]</code>一样，产生同样的元素类型，同样长度和元素的slice,但是它会设置容量capacity,<br>产生的slice的容量为 <code>max-low</code>。在这个格式下，只有第一个索引low可以省略，默认为0。<br>索引的范围符合 <code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code>。</p>
<h3 id="变参">变参</h3>
<p>对于函数和方法中的最后一个参数是变参p，类型是...T的情况，p的类型f等价于[]T。</p>
<p>如果没有实际参数传给变参，它的值是nil。</p>
<p>你可以讲一个slice传递给变参，如果想将slice的元素作为变参的各个值传递的话，可以在slice后面加...:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Greeting(prefix <span class="typename">string</span>, who ...<span class="typename">string</span>)</div><div class="line">Greeting(<span class="string">"nobody"</span>)</div><div class="line">Greeting(<span class="string">"hello:"</span>, <span class="string">"Joe"</span>, <span class="string">"Anna"</span>, <span class="string">"Eileen"</span>)</div><div class="line"></div><div class="line">s := []<span class="typename">string</span>{<span class="string">"James"</span>, <span class="string">"Jasmine"</span>}</div><div class="line">Greeting(<span class="string">"goodbye:"</span>, s...)</div></pre></td></tr></table></figure>

<p>加不加...是不一样的，比如下面的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> foo(p ...<span class="keyword">interface</span>{}) {</div><div class="line">	fmt.Println(<span class="built_in">len</span>(p))</div><div class="line">}</div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	s := []<span class="keyword">interface</span>{}<span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 4</span>,<span class="number"> 5</span>}</div><div class="line"></div><div class="line">	foo(s)    <span class="comment">//1</span></div><div class="line">	foo(s...) <span class="comment">//5</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="运算符">运算符</h3>
<p>本节重要用于总结。</p>
<p>除了为移位运算符， 如果一个操作数是有类型的，另一个不是，则另一个会被转换成相同的类型。</p>
<p>移位操作的右边的运算符是无符号整数，或者可以转换成无符合整数的未声明的常量。</p>
<h4 id="运算符优先级">运算符优先级</h4>
<p><code>++</code>、<code>--</code>是语句，不是表达式， *p++等同于(*p)++。</p>
<p>运算符有5层优先级：</p>
<pre class="highlight">
Precedence    Operator
    5             *  /  %  <<  >>  &  &^
    4             +  -  |  ^
    3             ==  !=  <  <=>  >=
    2             &&
    1             ||
</=></pre>


<h4 id="算术运算符">算术运算符</h4>
<p>算术运算符应用于整数、浮点数、复数， + 也可以应用于字符串。</p>
<p>位运算和移位运算只适用于整数。</p>
<pre class="highlight">
+    sum                    integers, floats, complex values, strings
-    difference             integers, floats, complex values
*    product                integers, floats, complex values
/    quotient               integers, floats, complex values
%    remainder              integers

&    bitwise AND            integers
|    bitwise OR             integers
^    bitwise XOR            integers
&^   bit clear (AND NOT)    integers

<<   left shift             integer << unsigned integer
\>>   right shift            integer >> unsigned integer
</pre>

<p><code>^</code>是异或操作。<code>&amp;^</code>位清零操作，如果第二个操作数的二进制的某个位的值为1,那么对应的第一个操作数的位的值则设为0，也就是将第一个操作数上的相应的位清零。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">i1 :=<span class="number"> 0</span>x0F</div><div class="line">i2 := i1 &lt;&lt;<span class="number"> 2</span></div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"0000%b\n00%b\n"</span>, i1, i2) <span class="comment">//00001111 00111100</span></div><div class="line">fmt.Printf(<span class="string">"%b\n"</span>, i1&i2) <span class="comment">//00001100</span></div><div class="line">fmt.Printf(<span class="string">"%b\n"</span>, i1|i2) <span class="comment">//00111111</span></div><div class="line">fmt.Printf(<span class="string">"%b\n"</span>, i1^i2) <span class="comment">//00110011</span></div><div class="line">fmt.Printf(<span class="string">"%b\n"</span>, i1&^i2) <span class="comment">//00000011</span></div></pre></td></tr></table></figure>

<p>对于移位操作，如果左边的操作符是无符号整数，则进行逻辑移位，如果左边的操作符是有符号整数，则进行的是算术移位。略记移位不考虑符号位，而算术移位要考虑符号位，这样能保证 移位操作 和 乘除的操作 一致。</p>
<p><img src="left_logically.png" alt="算术左移"></p>
<p><img src="right_arithmetically.png" alt="算术右移"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i <span class="typename">uint8</span> =<span class="number"> 1</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, i&lt;<span class="number">&lt;1</span>, i&lt;<span class="number">&lt;1</span>) <span class="comment">//2: 10</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, i&lt;<span class="number">&lt;7</span>, i&lt;<span class="number">&lt;7</span>) <span class="comment">//128: 10000000</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, i&lt;<span class="number">&lt;8</span>, i&lt;<span class="number">&lt;8</span>) <span class="comment">//0: 0</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> i2 <span class="typename">int8</span> =<span class="number"> 1</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, i2&lt;<span class="number">&lt;1</span>, i2&lt;<span class="number">&lt;1</span>) <span class="comment">//2: 10</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, i2&lt;<span class="number">&lt;7</span>, i2&lt;<span class="number">&lt;7</span>) <span class="comment">//-128: -10000000</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, i2&lt;<span class="number">&lt;8</span>, i2&lt;<span class="number">&lt;8</span>) <span class="comment">//0: 0</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> i3 <span class="typename">int8</span> =<span class="number"> -1</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, -i3&lt;<span class="number">&lt;1</span>, -i3&lt;<span class="number">&lt;1</span>) <span class="comment">//2: 10</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, -i3&lt;<span class="number">&lt;7</span>, -i3&lt;<span class="number">&lt;7</span>) <span class="comment">//-128: -10000000</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, -i3&lt;<span class="number">&lt;8</span>, -i3&lt;<span class="number">&lt;8</span>) <span class="comment">//0: 0</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> i4 <span class="typename">int8</span> =<span class="number"> -128</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, -i4&gt;<span class="number">&gt;0</span>, -i4&gt;<span class="number">&gt;0</span>) <span class="comment">//-64: -10000000</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, -i4&gt;<span class="number">&gt;1</span>, -i4&gt;<span class="number">&gt;1</span>) <span class="comment">//-64: -1000000</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, -i4&gt;<span class="number">&gt;2</span>, -i4&gt;<span class="number">&gt;2</span>) <span class="comment">//-32: -100000</span></div></pre></td></tr></table></figure>

<p>参考:</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/位操作#.E7.A7.BB.E4.BD.8D" target="_blank" rel="external">https://zh.wikipedia.org/wiki/位操作#.E7.A7.BB.E4.BD.8D</a></li>
</ul>
<p>一元操作符:</p>
<pre class="highlight">
+x                          is 0 + x
-x    negation              is 0 - x
^x    bitwise complement    is m ^ x  with m = "all bits set to 1" for unsigned x
                                      and  m = -1 for signed x
</pre>

<p><code>^x</code> 在C、C#、Java语言中中符号 <code>~</code>,在Go语言中用 <code>^</code>。对于无符号整数来说就是按位取反，对于有符号的整数来说,<br>是按照补码进行取反操作的。<code>-1</code>的补码为<code>11111111</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i1 <span class="typename">uint8</span> =<span class="number"> 3</span></div><div class="line"><span class="keyword">var</span> i2 <span class="typename">int8</span> =<span class="number"> 3</span></div><div class="line"><span class="keyword">var</span> i3 <span class="typename">int8</span> =<span class="number"> -3</span></div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"^%b=%b %d\n"</span>, i1, ^i1, ^i1) <span class="comment">// ^11=11111100 252</span></div><div class="line">fmt.Printf(<span class="string">"^%b=%b %d\n"</span>, i2, ^i2, ^i2) <span class="comment">// ^11=-100 -4</span></div><div class="line">fmt.Printf(<span class="string">"^%b=%b %d\n"</span>, i3, ^i3, ^i3) <span class="comment">// ^-11=10 2</span></div></pre></td></tr></table></figure>

<p>无符号整数的+、-、*、&lt;&lt;的操作的结果会取模2^n， 也就是溢出的位会被丢掉， 比如uint8类型的数 &quot;255 + 2&quot; 会等于 1。</p>
<p>有符号整数的+、-、*、&lt;&lt;的操作的结果的溢出也不会导致异常，但是结果可能不是你想要的，比如x &lt; x+1并不总是成立。比如int8的两个值 &quot;127 + 2 = -127&quot;。</p>
<p>字符串也可以应用<code>+</code>、<code>+=</code>运算符：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s := <span class="string">"hi"</span> + <span class="typename">string</span>(c)</div><div class="line">s += <span class="string">" and good bye"</span></div></pre></td></tr></table></figure>

<h4 id="比较运算符">比较运算符</h4>
<pre class="highlight">
==    等于
!=    不等于
&lt     小于
&lt=    小于等于
&gt     大于
&gt=    大于等于
</pre>

<p><code>==</code>、<code>!=</code>比较相等性， 可比较comparable，<code>&lt;, &lt;=, &gt;, &gt;=</code>是有序运算符, ordered。</p>
<ul>
<li>布尔值: comparable</li>
<li>整数: comparable, ordered</li>
<li>浮点数: comparable, ordered</li>
<li>负数: comparable</li>
<li>字符串： comparable, ordered，根据字节比较</li>
<li>指针: comparable</li>
<li>Channel:  comparable</li>
<li>接口: comparable</li>
<li>一个非接口类型X的值x 可以和 一个接口类型T的值t进行比较: comparable</li>
<li>struct:  comparable 如果它的所有的字段都是comparable的话。<br>＊ 数组：comparable</li>
</ul>
<p>两个接口比较的时候可能导致运行时panic， 如果接口的动态类型的值不可比较的话。</p>
<p>slice、map和函数值都不可以比较，但是它们可以和预定义的零值nil进行比较。</p>
<h3 id="逻辑运算符">逻辑运算符</h3>
<pre class="highlight">
&&    conditional AND    p && q  is  "if p then q else false"
||    conditional OR     p || q  is  "if p then true else q"
!     NOT                !p      is  "not p"
</pre>

<h3 id="地址运算符">地址运算符</h3>
<p><code>&amp;x</code>取址</p>
<p><code>*x</code>取得指针指向的值</p>
<h3 id="receive运算符">receive运算符</h3>
<p>对于Channel类型的值ch, receive操作 <code>&lt;-ch</code>的值代表从ch中取出的一个值。<br>ch的声明时应该允许receive操作。</p>
<p>这个操作会阻塞，直到有值收到。</p>
<p>从一个nil channel中receive会一直阻塞。</p>
<p>从closed channel中的receive会以及处理，返回零值。</p>
<p>从ch中receive也可以用下面的格式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x, ok = &lt;-ch</div><div class="line">x, ok := &lt;-ch</div><div class="line"><span class="keyword">var</span> x, ok = &lt;-ch</div></pre></td></tr></table></figure>

<h3 id="Order_of_evaluation">Order of evaluation</h3>
<p>表达式的运算(评估)顺序。</p>
<p>包一级的变量声明中的表达式的运算顺序会根据它们的依赖，这个以后讲，其它的表达式的运算顺序都是从左向右计算。</p>
<p>比如一个函数内的下面的表达式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">y[f()], ok = g(h(), i()+x[j()], &lt;-c), k()</div></pre></td></tr></table></figure>

<p>它的计算顺序为f(),  h(), i(), j(), &lt;-c, g(), k(),但是计算索引y[],x[]的顺序并没有指定。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a :=<span class="number"> 1</span></div><div class="line">f := <span class="keyword">func</span>() <span class="typename">int</span> { a++; <span class="keyword">return</span> a }</div><div class="line">x := []<span class="typename">int</span>{a, f()}            <span class="comment">// x may be [1, 2] or [2, 2]: evaluation order between a and f() is not specified</span></div><div class="line">m := <span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">int</span>{a:<span class="number"> 1</span>, a:<span class="number"> 2</span>}  <span class="comment">// m may be {2: 1} or {2: 2}: evaluation order between the two map assignments is not specified</span></div><div class="line">n := <span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">int</span>{a: f()}      <span class="comment">// n may be {2: 3} or {3: 3}: evaluation order between the key and the value is not specified</span></div></pre></td></tr></table></figure>

<p>对于包一级的变量声明中的表达式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a, b, c = f() + v(), g(), sqr(u()) + v()</div><div class="line"></div><div class="line"><span class="keyword">func</span> f() <span class="typename">int</span>        { <span class="keyword">return</span> c }</div><div class="line"><span class="keyword">func</span> g() <span class="typename">int</span>        { <span class="keyword">return</span> a }</div><div class="line"><span class="keyword">func</span> sqr(x <span class="typename">int</span>) <span class="typename">int</span> { <span class="keyword">return</span> x*x }</div></pre></td></tr></table></figure>

<p>顺序为 u(), sqr(), v(), f(), v(), g()。</p>
<p>下一章将介绍 类型转换(Conversion)、类型断言(type assertion) 和类型切换（type switch）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文介绍Go语言的表达式。</p>
<p>表达式代表一个值的计算， 计算通过运算符和函数应用在操作数上(operand)。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go语言 - 4]]></title>
    <link href="http://colobu.com/2016/06/20/dive-into-go-4/"/>
    <id>http://colobu.com/2016/06/20/dive-into-go-4/</id>
    <published>2016-06-20T04:35:19.000Z</published>
    <updated>2016-06-21T08:57:05.000Z</updated>
    <content type="html"><![CDATA[<p>本文介绍Go的声明和作用域。</p>
<a id="more"></a>
<p>声明用于常量、变量、类型、函数、标签和包。</p>
<p>每个非空标识符(identifier)必须声明。同一代码块中标识符只能声明一次。标识符不能同时声明在文件代码块和包代码块中。</p>
<p>空标识符为下划线 &quot;_&quot;，它可以做为匿名占位符。</p>
<p>一个声明的标识符的作用域总结如下：</p>
<ul>
<li>预声明的标识符的作用域是全局代码块如<code>int</code>、<code>true</code>等</li>
<li>顶层的(函数之外)的标识符， 用来声明常量、类型、变量或者函数(非方法), 这些标识符的作用域是包代码块</li>
<li>一个输入的包的包名的作用域是这个文件的文件代码块</li>
<li>用来表示方法 receiver、函数参数、结果变量的标识符的作用域是函数体</li>
<li>在一个函数内声明的常量或者变量的标识符的作用域起于ConstSpec 、 VarSpec之后(也就是标识符声明之后)， 结束于包含它的最内层的代码块尾部</li>
<li>函数内声明的类型标识符始于 TypeSpec， 结束于包含它的最内层的代码块尾部</li>
</ul>
<p>代码块中的标识符可以在内部的代码块中再次声明，但是内部的标识符和外部的标识符表示不同的对象，这个一定小心。</p>
<p><a href="https://golang.org/ref/spec#Package_clause" target="_blank" rel="external">package clause</a>并不是声明语句。<strong>包名不能出现在任何作用域中</strong>, 经常我们为了方便，声明一个变量的时候和包名一样，比如在引入<code>net/http</code>包的时候声明一个变量是<code>http</code>,这是不对的，这会导致变量名会隐藏(shadow)包名。</p>
<h3 id="标签作用域">标签作用域</h3>
<p>标签(label)作用域可以用于<code>break</code>、<code>continue</code>、<code>goto</code>语句，这在其它语言中也有定义，尽管不会推荐广泛应用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">i :=<span class="number"> 0</span></div><div class="line">回来:</div><div class="line">i++</div><div class="line">fmt.Println(i)</div><div class="line"><span class="keyword">if</span> i &lt;<span class="number"> 5</span> {</div><div class="line">  <span class="keyword">goto</span> 回来</div><div class="line">}</div></pre></td></tr></table></figure>

<p>定义一个未被使用的标签是非法的，这和函数内的定义未被使用的变量是一样的。</p>
<p>标签不会和其它同名的标识符冲突。</p>
<p>标签的作用域只在声明它的位置到函数体的尾部，不会作用于内部嵌套的函数。</p>
<h3 id="空标识符和预定义标识符">空标识符和预定义标识符</h3>
<p>空标识符前面已经提到了，下面是一些空标识符的应用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">	_ <span class="string">"net/http"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> _ = <span class="string">"hello world"</span></div><div class="line"><span class="keyword">var</span> _ =<span class="number"> 100</span></div><div class="line"><span class="keyword">type</span> _ []<span class="typename">int</span></div><div class="line"><span class="keyword">type</span> _ <span class="keyword">struct</span>{}</div><div class="line"><span class="keyword">type</span> _ <span class="keyword">interface</span>{}</div></pre></td></tr></table></figure>

<p>预定义的标识符<a href="http://colobu.com/2016/06/15/dive-into-go-1/" target="_blank" rel="external">第一章</a>中已经介绍了。</p>
<h3 id="输出标识符">输出标识符</h3>
<p>Go语言中没有 public、protect、private等关键字，如果想在其它包中访问当前包的标识符，<br>标识符应该具备下面两个条件,这和其它编程语言不太一样:<br>1、标识符名字的第一个字符应该是unicode upper case letter (Lu)<br>2、并且标识符声明在包代码块中，或者它是一个字段名或者方法名。</p>
<p>举个例子。<br>在当前的main程序所在的目录中创建一个目录p,在里面创建一个文件t.go,定义两个包作用域的变量:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> p</div><div class="line"></div><div class="line"><span class="keyword">var</span> str = <span class="string">"hello world"</span></div><div class="line"><span class="keyword">var</span> Str = <span class="string">"Hello World"</span></div></pre></td></tr></table></figure>

<p>然后在main程序中尝试访问package p下的这两个变量，会发现只能访问<code>Str</code>，<code>str</code>报错，说没有导出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line"></div><div class="line">	<span class="string">"./p"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	fmt.Println(p.str)</div><div class="line">	fmt.Println(p.Str)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>函数、常量、类型、struct、interface、方法都遵循这个法则。所以要想导出一个标识符，请首字母大写。</p>
<p>注意，这里要求的是首字母是unicode upper case letter,就是unicode分类为Lu的字符，对于Unicode字符，你需要知道哪些是大写字符,比如希腊字符也是有大小写的，中文不是大小写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> 一二三 = <span class="string">"123"</span> <span class="comment">//未输出</span></div><div class="line"><span class="keyword">var</span> Π =<span class="number"> 3.1415926</span> <span class="comment">//输出</span></div></pre></td></tr></table></figure>

<p>你可以在 <a href="http://www.fileformat.info/info/unicode/category/Lu/list.htm" target="_blank" rel="external">这里</a> 查看unicode 大写字符列表。</p>
<h3 id="iota">iota</h3>
<p>在常量定义中，<strong>iota</strong> 代表一个连续的未指定类型的整数常量。每当保留字const出现的时候，它都重置为0，后续的每个常量定义都会把它加一。 它常用来定义一组类似枚举的类型，比如月份、星期、颜色等。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ( <span class="comment">// iota is reset to 0</span></div><div class="line">	c0 = <span class="constant">iota</span>  <span class="comment">// c0 == 0</span></div><div class="line">	c1 = <span class="constant">iota</span>  <span class="comment">// c1 == 1</span></div><div class="line">	c2 = <span class="constant">iota</span>  <span class="comment">// c2 == 2</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> ( <span class="comment">// iota 重置为 0</span></div><div class="line">	a =<span class="number"> 1</span> &lt;&lt; <span class="constant">iota</span>  <span class="comment">// a == 1</span></div><div class="line">	b =<span class="number"> 1</span> &lt;&lt; <span class="constant">iota</span>  <span class="comment">// b == 2</span></div><div class="line">	c =<span class="number"> 3</span>          <span class="comment">// c == 3  (iota 虽然没有使用，但是还是会增加)</span></div><div class="line">	d =<span class="number"> 1</span> &lt;&lt; <span class="constant">iota</span>  <span class="comment">// d == 8</span></div><div class="line">)</div><div class="line"><span class="keyword">const</span> ( <span class="comment">// iota 重置为 0</span></div><div class="line">	u         = <span class="constant">iota</span> *<span class="number"> 42</span>  <span class="comment">// u == 0     (untyped integer constant)</span></div><div class="line">	v <span class="typename">float64</span> = <span class="constant">iota</span> *<span class="number"> 42</span>  <span class="comment">// v == 42.0  (float64 constant)</span></div><div class="line">	w         = <span class="constant">iota</span> *<span class="number"> 42</span>  <span class="comment">// w == 84    (untyped integer constant)</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> x = <span class="constant">iota</span>  <span class="comment">// x == 0  (iota 重置为 0)</span></div><div class="line"><span class="keyword">const</span> y = <span class="constant">iota</span>  <span class="comment">// y == 0  (iota 重置为 0)</span></div></pre></td></tr></table></figure>

<p>如果使用表达式列表，同一表达式的iota的值是相同的，因为只有遇到新的ConstSpec才会增加。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">	bit0, mask0 =<span class="number"> 1</span> &lt;&lt; <span class="constant">iota</span>,<span class="number"> 1</span>&lt;&lt;<span class="constant">iota</span> -<span class="number"> 1</span>  <span class="comment">// bit0 == 1, mask0 == 0, iota = 0</span></div><div class="line">	bit1, mask1                           <span class="comment">// bit1 == 2, mask1 == 1, iota = 1</span></div><div class="line">	_, _                                  <span class="comment">// skips iota == 2</span></div><div class="line">	bit3, mask3                           <span class="comment">// bit3 == 8, mask3 == 7, iota =3</span></div><div class="line">)</div></pre></td></tr></table></figure>

<p>Go语言中没有枚举类型，所以一般通过下面的方式定义枚举类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Week <span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> names = [...]<span class="typename">string</span>{<span class="string">"星期一"</span>, <span class="string">"星期二"</span>, <span class="string">"星期三"</span>, <span class="string">"星期四"</span>, <span class="string">"星期五"</span>, <span class="string">"星期六"</span>, <span class="string">"星期日"</span>}</div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">	Monday Week = <span class="constant">iota</span> +<span class="number"> 1</span></div><div class="line">	Tuesday</div><div class="line">	Wednesday</div><div class="line">	Thursday</div><div class="line">	Friday</div><div class="line">	Saturday</div><div class="line">	Sunday</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> (w Week) String() <span class="typename">string</span> {</div><div class="line">	<span class="keyword">if</span> w &gt;<span class="number"> 0</span> && w &lt;<span class="number"> 8</span> {</div><div class="line">		<span class="keyword">return</span> names[w<span class="number">-1</span>]</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="string">"非法的星期名"</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="函数声明">函数声明</h3>
<p>函数可以声明为签名，也可以定义方法体。</p>
<p>没有方法体的函数只有签名的函数可以声明在接口中，也可以声明包代码块中，此时标明方法是由外部实现的，比如汇编语言。</p>
<p>如果函数声明了返回类型，那么方法体中必须有相应的return语句。</p>
<p>匿名函数又叫函数字面量，它不包含函数名，可以用来赋值给变量(比如在一个函数内或者外赋值给一个变量)、或者直接调用(比如go语句中)。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">f := <span class="keyword">func</span>(x, y <span class="typename">int</span>) <span class="typename">int</span> { <span class="keyword">return</span> x + y }</div><div class="line"><span class="keyword">func</span>(ch <span class="keyword">chan</span> <span class="typename">int</span>) { ch &lt;- ACK }(replyChan)</div><div class="line"><span class="keyword">go</span> <span class="keyword">func</span>(ch <span class="keyword">chan</span> <span class="typename">int</span>) { ch &lt;- ACK }(replyChan)</div></pre></td></tr></table></figure>

<h3 id="方法声明">方法声明</h3>
<p>方法声明类似函数声明，但是它包含一个接受者receiver。</p>
<p>在方法名的前面要声明一个额外的参数，这个参数是单一的，不可变的，作为receiver，<br>它的类型为<code>T</code>或者<code>*T</code>，T叫做receiver base type。</p>
<p>注意<code>T</code>不能是指针类型或者皆苦类型，并且必须和方法声明在同一个包下。你想在自己的包下为标准库中的类型定义一个方法是不行的。</p>
<p>方法名仅仅在类型T 或者 *T的 selector中显示。</p>
<p>receiver名不能和参数名或者返回参数重名：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//错误</span></div><div class="line"><span class="keyword">func</span> (i IntArr) Say(i <span class="typename">int</span>) (i <span class="typename">int</span>) {</div><div class="line">	<span class="keyword">return</span><span class="number"> 0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>方法名唯一。</p>
<p>对于struct类型，方法名和字段名必须唯一。</p>
<p>方法的特性和selector在下一章的表达式介绍。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文介绍Go的声明和作用域。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Scala集合技术手册出版了]]></title>
    <link href="http://colobu.com/2016/06/19/scala-collections-cookbook-is-available/"/>
    <id>http://colobu.com/2016/06/19/scala-collections-cookbook-is-available/</id>
    <published>2016-06-19T09:45:47.000Z</published>
    <updated>2016-06-21T08:57:05.000Z</updated>
    <content type="html"><![CDATA[<p>拙著《Scala集合技术手册》出版了，详细信息请看 <a href="/ScalaCollectionsCookbook/">这里</a>。</p>
<p>这是我在学习和使用Scala过程中的技术总结和探索。</p>
<p>市面上第一本全面介绍Scala集合框架的图书。</p>
<p>首部国人原创中文Scala图书。</p>
<p><strong>编辑推荐</strong><br>√ Scala集合库不可多得的中文资料<br>√ 作为Scala的制胜法宝本书教你如何驾驭<br>√ 面向实际问题用示例代码讲解类的使用和原理<br>√ 全新角度实现基本数据结构是提升功力的不二法门</p>
<p><strong>挖财架构师《 Scala 函数式编程》译者 王宏江 作序</strong></p>
<p><strong>推荐</strong><br>√ 极牛创始人 CEO 吴际超<br>√ 《快学Scala》译者 高宇翔<br>√ 阿里巴巴 善马(柴克斌)<br>√ 联想 柴明贵</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>拙著《Scala集合技术手册》出版了，详细信息请看 <a href="/ScalaCollectionsCookbook/">这里</a>。</p>
<p>这是我在学习和使用Scala过程中的技术总结和探索。</p>
<p>市面上第一本全面介绍Scala集合框架的图书。</]]>
    </summary>
    
      <category term="Scala" scheme="http://colobu.com/tags/Scala/"/>
    
      <category term="Scala" scheme="http://colobu.com/categories/Scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go语言 - 3]]></title>
    <link href="http://colobu.com/2016/06/16/dive-into-go-3/"/>
    <id>http://colobu.com/2016/06/16/dive-into-go-3/</id>
    <published>2016-06-16T05:24:22.000Z</published>
    <updated>2016-06-21T08:57:05.000Z</updated>
    <content type="html"><![CDATA[<p>本文介绍Go的类型系统,以及类型的比较和语句块。</p>
<p>Go语言包含11种类型，你应该很熟悉了，下面让我们再深入的了解一下每种类型的细节。</p>
<ul>
<li>布尔类型</li>
<li>数值类型</li>
<li>字符串类型</li>
<li>数组类型</li>
<li>Slice类型</li>
<li>Struct类型</li>
<li>指针类型</li>
<li>函数类型</li>
<li>接口类型</li>
<li>Map类型</li>
<li>Channel类型</li>
</ul>
<a id="more"></a>
<p>bool、数值型类型、rune、字符串都是预定义的类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="typename">bool</span> <span class="typename">byte</span> <span class="typename">complex64</span> <span class="typename">complex128</span> error <span class="typename">float32</span> <span class="typename">float64</span></div><div class="line"><span class="typename">int</span> <span class="typename">int8</span> <span class="typename">int16</span> <span class="typename">int32</span> <span class="typename">int64</span> <span class="typename">rune</span> <span class="typename">string</span></div><div class="line"><span class="typename">uint</span> <span class="typename">uint8</span> <span class="typename">uint16</span> <span class="typename">uint32</span> <span class="typename">uint64</span> <span class="typename">uintptr</span></div></pre></td></tr></table></figure>

<p>复合类型array, struct, pointer, function, interface, slice, map 和 channel 由类型字面量构造而成。</p>
<p>每一个类型都有一个底层类型(underlying type),比如下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> T1 <span class="typename">string</span></div><div class="line"><span class="keyword">type</span> T2 T1</div><div class="line"><span class="keyword">type</span> T3 []T1</div><div class="line"><span class="keyword">type</span> T4 T3</div></pre></td></tr></table></figure>

<p><code>string</code>、<code>T1</code>、<code>T2</code>的底层类型</p>
<ul>
<li><strong>命名类型(named type)</strong> : 由一个确定的类型的名称指定</li>
<li><strong>未命名类型(unamed type)</strong>:由类型字面量指定，类型字面量由既有的类型组成</li>
</ul>
<p>比如下面的例子中, x的类型就是未命名类型，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x <span class="keyword">struct</span>{ I <span class="typename">int</span> }</div></pre></td></tr></table></figure>

<p>而下面的例子中，y的类型就是命名类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span>{ I <span class="typename">int</span> }</div><div class="line"><span class="keyword">var</span> y Foo</div></pre></td></tr></table></figure>

<p>未命名类型的一个重要属性就是用同样类型的未命名类型声明的变量拥有相同的类型，而两个不同的命名类型，即使底层的类型相同，它们的类型也是不同的。<br>更详细的总结会在下一篇文章中介绍，比如我们再定义两个类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x2 <span class="keyword">struct</span>{ I <span class="typename">int</span> }</div><div class="line"><span class="keyword">type</span> Bar <span class="keyword">struct</span>{ I <span class="typename">int</span> }</div><div class="line"><span class="keyword">var</span> y2 Bar</div></pre></td></tr></table></figure>

<p>其中 <strong>x</strong> 和 <strong>x2</strong> 的类型相同， 而 <strong>y</strong> 和 <strong>y2</strong> 的类型却不相同。</p>
<p>命名类型可以定义自己的函数， 而未命名类型确不行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (f *Foo) Hello() {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (a []<span class="typename">int</span>) Hello() { <span class="comment">//错误, []int是未命名类型</span></div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>比如上例中，<code>[]int</code>是未命名类型，没办法为它定义方法,所以我们可以像下面的例子一样定义一个命名类型，它的底层类型是<code>[]int</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> IntArr []<span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> (ia *IntArr) Hello() {</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>参考</p>
<ul>
<li><a href="https://github.com/golang/go/issues/5682" target="_blank" rel="external">https://github.com/golang/go/issues/5682</a></li>
<li><a href="http://stackoverflow.com/questions/32983546/named-and-unnamed-types" target="_blank" rel="external">http://stackoverflow.com/questions/32983546/named-and-unnamed-types</a></li>
<li><a href="http://blog.csdn.net/hittata/article/details/51250179" target="_blank" rel="external">http://blog.csdn.net/hittata/article/details/51250179</a></li>
</ul>
<h3 id="布尔类型">布尔类型</h3>
<p>很简单，类型名为<code>bool</code>,只有两个值： <code>true</code> 和 <code>false</code>。</p>
<p>参考</p>
<ul>
<li><a href="https://github.com/golang/go/issues/15171" target="_blank" rel="external">https://github.com/golang/go/issues/15171</a></li>
</ul>
<h3 id="数值类型">数值类型</h3>
<p>数值类型包括整数、浮点数和复数。总结如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint8</td>
<td>无符号8位整数，(0 to 255)｜</td>
</tr>
<tr>
<td>uint16</td>
<td>无符号16位整数， (0 to 65535)</td>
<td></td>
</tr>
<tr>
<td>uint32</td>
<td>无符号32位整数， (0 to 4294967295)</td>
</tr>
<tr>
<td>uint64</td>
<td>无符号64位整数， (0 to 18446744073709551615)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>int8</td>
<td>8位整数， (-128 to 127)</td>
</tr>
<tr>
<td>int16</td>
<td>16位整数， (-32768 to 32767)</td>
</tr>
<tr>
<td>int32</td>
<td>16位整数， (-2147483648 to 2147483647)</td>
</tr>
<tr>
<td>int64</td>
<td>64位整数， (-9223372036854775808 to 9223372036854775807)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>float32</td>
<td>IEEE-754 32位浮点数</td>
</tr>
<tr>
<td>float64</td>
<td>IEEE-754 64位浮点数</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>complex64</td>
<td>实部和虚部都是float32</td>
</tr>
<tr>
<td>complex128</td>
<td>实部和虚部都是float32</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>byte</td>
<td>uint8的别名</td>
</tr>
<tr>
<td>rune</td>
<td>int32的别名</td>
</tr>
</tbody>
</table>
<p>在不同的架构上，下面的几种类型可能的位数不同：<br><code>uint</code>可能是32位或者64位<br><code>int</code>可能是32位或者64位<br><code>uintptr</code> 是一个足够大的无符号整数，可以代表一个指针的值得</p>
<p><code>int</code>和<code>int32</code>并不是一个相同的类型，尽管在一些环境下它们的位数都是32位。</p>
<h3 id="数组类型">数组类型</h3>
<p>数组代表有限的同一元素类型的对象的序列。对象的数量就是数组的长度， 通过<code>len</code>方法得到。</p>
<p>数组是一维的，但是你可以构造多维数组：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">[3</span>]<span class="number">[5</span>]<span class="typename">int</span></div><div class="line"><span class="number">[2</span>]<span class="number">[2</span>]<span class="number">[2</span>]<span class="typename">float64</span>  <span class="comment">// 等价 [2]([2]([2]float64))</span></div></pre></td></tr></table></figure>

<p>数组可以通过下面的方式声明，需要指定它的长度：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> buffer <span class="number">[256</span>]<span class="typename">byte</span></div></pre></td></tr></table></figure>

<p>声明和初始化可以合在一起：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">buffer := <span class="number">[10</span>]<span class="typename">string</span>{}             <span class="comment">// len(buffer) == 10</span></div><div class="line">intSet := <span class="number">[6</span>]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 5</span>}       <span class="comment">// len(intSet) == 6</span></div><div class="line">days := [...]<span class="typename">string</span>{<span class="string">"Sat"</span>, <span class="string">"Sun"</span>}  <span class="comment">// len(days) == 2</span></div></pre></td></tr></table></figure>

<p><code>[...]</code>是根据初始化的元素的数量确定数组的长度。</p>
<h3 id="Slice类型">Slice类型</h3>
<p>实际在开发的过程中，我们使用数组的场合比较少，这是因为数组一旦定义，它的长度就不能再发生变化，这和很多其它编程语言的定义是一样的。<br>更多的情况下我们会使用slice。</p>
<p>Slice描述了数组的一个连续的片段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> slice []<span class="typename">byte</span> = buffer<span class="number">[100</span><span class="number">:150</span>]</div></pre></td></tr></table></figure>

<p>上面的例子中<code>slice</code>对象代表数组的索引位置为100 ~149的元素。</p>
<p>其实slice数据结构是由<code>SliceHeader</code>描述的,所以我们可以看到slice是由三个数据描述的：<code>第0个元素的指针</code>、<code>长度</code>、<code>容量</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> {</div><div class="line">        Data <span class="typename">uintptr</span></div><div class="line">        Len  <span class="typename">int</span></div><div class="line">        Cap  <span class="typename">int</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>在后面的文章中我会介绍通过指针操作SliceHeader。</p>
<p>slice可以从数组中生成，如上面的例子，也可以直接生成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 []<span class="typename">int</span></div><div class="line"><span class="keyword">var</span> s2 = <span class="built_in">make</span>([]<span class="typename">int</span>,<span class="number"> 10</span>)</div><div class="line"><span class="keyword">var</span> s3 = <span class="built_in">make</span>([]<span class="typename">int</span>,<span class="number"> 10</span>,<span class="number"> 20</span>)</div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"len:%d, cap:%d\n"</span>, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</div><div class="line">fmt.Printf(<span class="string">"len:%d, cap:%d\n"</span>, <span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2))</div><div class="line">fmt.Printf(<span class="string">"len:%d, cap:%d\n"</span>, <span class="built_in">len</span>(s3), <span class="built_in">cap</span>(s3))</div></pre></td></tr></table></figure>

<p>在生成的时候可以指定slice的长度和容量，如果没有指定容量(make的第三个参数)，则容量和长度相同。<br>如果不是通过<code>make</code>创建，而是通过<code>var</code>的方式声明一个零值的slice，则它的长度和容量都为0。</p>
<p>一旦一个slice创建出来，它的底层元素是由一个数组保存着。slice的容量就是这个数组的长度，可以通过<code>cap</code>获得。<br>如果slice的元素的数量超过容量，就需要创建新的数组。这是一个值得注意的地方，如果你初始的时候就可以确定元素的最大数量的情况下，<br>最好设置slice的容量的值，这样避免数组的重新分配和数据拷贝，提高程序的性能。</p>
<h4 id="index,_append,_remove_和_copy">index, append, remove 和 copy</h4>
<p>slice和数组一样，都是可以通过索引得到某个位置的元素。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a := [...]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 4</span>,<span class="number"> 5</span>}</div><div class="line"><span class="keyword">var</span> s = a[:]</div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"%d\n"</span>, s<span class="number">[0</span>])</div><div class="line">fmt.Printf(<span class="string">"%d/n"</span>, s<span class="number">[10</span>])<span class="comment">//panic: runtime error: index out of range</span></div></pre></td></tr></table></figure>

<p>如果超出slice的索引最大值，就会导致panic。</p>
<p>可以往slice增加元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">s2 := <span class="built_in">append</span>(s,<span class="number"> 6</span>)</div><div class="line">fmt.Printf(<span class="string">"s: %#v\ns2:%#v\n"</span>, s, s2)</div><div class="line"></div><div class="line"><span class="comment">//output:</span></div><div class="line"><span class="comment">//s: []int{1, 2, 3, 4, 5}</span></div><div class="line"><span class="comment">//s2:[]int{1, 2, 3, 4, 5, 6}</span></div></pre></td></tr></table></figure>

<p>通过<code>append</code>方法可以往slice增加元素，值得注意的是append的返回值是增加元素后的slice，和原始的slice不同，尽管它们底层的数组可能相同。<br>如果容量足够，元素就继续增加底层数组中，如果容量不够，则结果slice就会创建新的数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> <span class="built_in">append</span>(slice []Type, elems ...Type) []Type</div></pre></td></tr></table></figure>

<p>你可以往slice一次增加多个元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">slice = <span class="built_in">append</span>(slice, elem1, elem2)</div><div class="line">slice = <span class="built_in">append</span>(slice, anotherSlice...)</div></pre></td></tr></table></figure>

<p>注意<code>...</code>写法，它意味着你可以把一个slice中所有的元素全部增加到另外一个slice的尾部:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s3 := <span class="built_in">append</span>(s, s...)</div><div class="line">fmt.Printf(<span class="string">"s: %#v\ns3:%#v\n"</span>, s, s3)</div></pre></td></tr></table></figure>

<p>一个值得注意的技巧是可以将一个字符串的byte一次都增加到一个 []byte中:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s4 := <span class="built_in">append</span>([]<span class="typename">byte</span>(<span class="string">"hello "</span>), <span class="string">"world"</span>...)</div></pre></td></tr></table></figure>

<p>要删除slice某个索引的位置，可以通过下面的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s5 := <span class="built_in">append</span>(s[<span class="number">:2</span>], s<span class="number">[3</span>:]...)</div><div class="line">fmt.Printf(<span class="string">"s: %#v\ns5:%#v\n"</span>, s, s5)</div></pre></td></tr></table></figure>

<p>这个例子删除索引2处的元素。</p>
<p>slice的拷贝是通过<code>copy</code>方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> <span class="built_in">copy</span>(dst, src []Type) <span class="typename">int</span></div></pre></td></tr></table></figure>

<p>返回结果为 dst和src的长度的最小值。这也就是说，如果dst的长度大，则将src全部元素都复制到dst中。如果src的长度大，则将src的len(dst)个元素复制到dst中。</p>
<h4 id="slice类型再深入">slice类型再深入</h4>
<p>因为slice底层使用数组，而这个数组可能在数组和多个slice中共用，这会带来潜在的问题。</p>
<p>1、对数组中元素的更改会影响slice<br>下面的例子中我们将数组的第一个值改为100,可以看到slice的第一个值也变了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a := [...]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 4</span>,<span class="number"> 5</span>}</div><div class="line"><span class="keyword">var</span> s = a[:]</div><div class="line"></div><div class="line">a<span class="number">[0</span>] =<span class="number"> 100</span></div><div class="line">fmt.Printf(<span class="string">"a: %#v\ns:%#v\n"</span>, a, s)</div></pre></td></tr></table></figure>

<p>2、如果slice使用不同的数组，则不会有影响<br>这一条是显而易见的，既然数组都不相同了，当然也没有什么影响了。<br>但是有时候你不是很容易的发现:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a := [...]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 4</span>,<span class="number"> 5</span>}</div><div class="line"><span class="keyword">var</span> s = a[:]</div><div class="line">s = <span class="built_in">append</span>(s,<span class="number"> 6</span>)</div><div class="line"></div><div class="line">a<span class="number">[0</span>] =<span class="number"> 100</span></div><div class="line">fmt.Printf(<span class="string">"a: %#v\ns:%#v\n"</span>, a, s)</div></pre></td></tr></table></figure>

<p>第三行在增加6到数组的尾部的时候，其实slice的容量已经不够了，所以为返回结果的slice新建了数组。<br>因此对原始数组的更改不会影响s2,但是对s却有影响，s的第一个值也变了。</p>
<p>3、当两个slice有重叠时，可能会有影响</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">a := [...]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 4</span>,<span class="number"> 5</span>}</div><div class="line">s1 := a<span class="number">[0</span><span class="number">:1</span>]</div><div class="line">s2 := a<span class="number">[0</span><span class="number">:2</span>]</div><div class="line"></div><div class="line">s1 = <span class="built_in">append</span>(s1,<span class="number"> 100</span>)</div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"a: %#v\ns1:%#v\ns2:%#v\n"</span>, a, s1, s2)</div></pre></td></tr></table></figure>

<p>这个例子s1和s2都使用相同的数组a,而且它们的容量都是5，不同的是它们的长度分别是2和3。</p>
<p>当往s1增加增加一个元素的时候，它事实上将元素放在的数组的索引为2的位置。这会对原始数组和s2都有影响，<br>看到检查输出的结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">a</span>: <span class="attr_selector">[5]</span><span class="tag">int</span><span class="rules">{<span class="rule">1, 100, 3, 4, 5}</span></span></div><div class="line"><span class="tag">s1</span>:<span class="attr_selector">[]</span><span class="tag">int</span><span class="rules">{<span class="rule">1, 100}</span></span></div><div class="line"><span class="tag">s2</span>:<span class="attr_selector">[]</span><span class="tag">int</span><span class="rules">{<span class="rule">1, 100}</span></span></div></pre></td></tr></table></figure>

<p>4、 copy的时候有重叠<br>调用<code>copy</code>方法的时候也可能会产生副作用，比如下面的例子，copy到s1的操作导致底层的数组改变了，影响了a,s1,s2的值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a := [...]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 4</span>,<span class="number"> 5</span>}</div><div class="line">s1 := a<span class="number">[0</span><span class="number">:3</span>]</div><div class="line">s2 := a<span class="number">[1</span><span class="number">:5</span>]</div><div class="line"><span class="built_in">copy</span>(s1, s2)</div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"a: %#v\ns1:%#v\ns2:%#v\n"</span>, a, s1, s2)</div></pre></td></tr></table></figure>

<p>参考</p>
<ul>
<li><a href="https://blog.golang.org/slices" target="_blank" rel="external">https://blog.golang.org/slices</a></li>
<li><a href="https://golang.org/pkg/unsafe/" target="_blank" rel="external">https://golang.org/pkg/unsafe/</a></li>
</ul>
<h3 id="字符串类型">字符串类型</h3>
<p>字符串类型(string)是一个常用的类型，它的值是一组基本按照UTF-8编码的字节序列，可以为空。<br>在前一篇文章中我已经介绍了字符串类型，所以此处不再重复介绍了，我会介绍一些有趣的性能。</p>
<p>字符串是不可变的，一旦创建，它的值就不能修改了。</p>
<p>内建的<code>len</code>方法可以得到字符串的长度，每个字节可以根据索引得到，不能像 C 语言一样得到某个字节的地址，<code>&amp;s[i]</code>这样做是非法的。</p>
<p>你可以把字符串看成一个不可变的slice，比如根据索引得到某个位置的字节，copy操作, append 字符串到[]byte中等：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">s := <span class="string">"hello world"</span></div><div class="line">b := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 5</span>)</div><div class="line"><span class="built_in">copy</span>(b, s)</div><div class="line">fmt.Println(s<span class="number">[0</span>])</div><div class="line">fmt.Println(b)</div><div class="line">fmt.Println(<span class="built_in">append</span>([]<span class="typename">byte</span>{}, s...))</div></pre></td></tr></table></figure>

<p>字符串和slices of bytes可以很方便的进行互转，因为它们的结构类似，底层都是通过一个数组保存元素的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s := <span class="string">"hello world"</span></div><div class="line">b := []<span class="typename">byte</span>(s)</div><div class="line">s = <span class="typename">string</span>(b)</div></pre></td></tr></table></figure>

<p>通常情况下，这种转换是对底层数组的复制，所以对转换后的slice的更改不会影响原来的字符串，这也保证了字符串的不可变。</p>
<p>但是，数组的复制是有代价的，内存的分配和数据的拷贝以及垃圾回收都会带来性能等开销，所以在追求性能的场合，比如一些Web框架中，<br>采用来了一些&quot;花招&quot;实现&quot;零拷贝&quot;。</p>
<p>首先我们看看stirng和slice的数据结构是怎么样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> {</div><div class="line">        Data <span class="typename">uintptr</span></div><div class="line">        Len  <span class="typename">int</span></div><div class="line">        Cap  <span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> {</div><div class="line">        Data <span class="typename">uintptr</span></div><div class="line">        Len  <span class="typename">int</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>看起来结构类似明知不过slice对string多了一个Cap字段。<br>所以我们可以根据它们的结构进行转换，不需要拷贝底层的数据Data:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"reflect"</span></div><div class="line">	<span class="string">"unsafe"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	s := <span class="string">"hello world"</span></div><div class="line">	b := StringToBytes(s)</div><div class="line">	s = BytesToString(b)</div><div class="line"></div><div class="line">	fmt.Printf(<span class="string">"%s\n"</span>, s)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> BytesToString(b []<span class="typename">byte</span>) <span class="typename">string</span> {</div><div class="line">	bytesHeader := (*reflect.SliceHeader)(unsafe.Pointer(&b))</div><div class="line">	strHeader := reflect.StringHeader{bytesHeader.Data, bytesHeader.Len}</div><div class="line">	<span class="keyword">return</span> *(*<span class="typename">string</span>)(unsafe.Pointer(&strHeader))</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> StringToBytes(s <span class="typename">string</span>) []<span class="typename">byte</span> {</div><div class="line">	strHeader := (*reflect.StringHeader)(unsafe.Pointer(&s))</div><div class="line">	bytesHeader := reflect.SliceHeader{strHeader.Data, strHeader.Len, strHeader.Len}</div><div class="line">	<span class="keyword">return</span> *(*[]<span class="typename">byte</span>)(unsafe.Pointer(&bytesHeader))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>整数之间、整数和字符串之间、slice和整数之间的转换放在数据转换一文中专门介绍。<br>参考</p>
<ul>
<li><a href="https://golang.org/src/runtime/string.go" target="_blank" rel="external">https://golang.org/src/runtime/string.go</a></li>
<li><a href="https://golang.org/pkg/reflect/#SliceHeader" target="_blank" rel="external">https://golang.org/pkg/reflect/#SliceHeader</a></li>
<li><a href="https://github.com/alecthomas/unsafeslice" target="_blank" rel="external">https://github.com/alecthomas/unsafeslice</a></li>
</ul>
<h3 id="Struct类型">Struct类型</h3>
<p>了解C语言的同学都知道struct(结构体)。</p>
<p>struct是一组命名的元素的序列，每个元素都有名字和类型，这些元素叫做结构体的字段(field)。字段名可能显示地指定，也可能隐式地指定。字段名不能重复。</p>
<p>struct类型有很多有趣的特性。</p>
<p>1、匿名字段<br>空字段、占位字段自不必说，你应该都已经了解了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> A <span class="keyword">struct</span>{}</div><div class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> {</div><div class="line">	i1 <span class="typename">uint16</span></div><div class="line">	_  <span class="typename">int16</span></div><div class="line">	i2 <span class="typename">int</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>struct还允许定义匿名字段。 匿名字段指声明了类型的字段，也叫嵌入字段或者嵌入类型。嵌入类型由类型名T或者指向非接口类型的指针*T指定。T本身不能再是指针类型。 类型名作为字段的名字。</p>
<p>下面的例子中的结构体包含四个匿名字段，可以看到包名不会作为字段名的一部分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> {</div><div class="line">	T1        <span class="comment">// 字段名 T1</span></div><div class="line">	*T2       <span class="comment">// 字段名 T2</span></div><div class="line">	P.T3      <span class="comment">// 字段名 T3</span></div><div class="line">	*P.T4     <span class="comment">// 字段名 T4</span></div><div class="line">	x, y <span class="typename">int</span>  <span class="comment">// 字段名 x 和 y</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>下面的结构体的定义是非法的，因为三个字段重名了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> {</div><div class="line">	T     </div><div class="line">	*T    </div><div class="line">	*P.T  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果结构体x有一个嵌入字段E,并且E拥有字段或者方法f，那么你可以直接调用x.f (如果x.f是一个合法的selector的话)，<br>这叫做字段提升(promoted)。</p>
<p>提升的字段就像结构体的正常的字段一样，除了初始化的时候不能像普通的字段设置。</p>
<p>假设有一个struct S和一个类型T, 提升的方法有以下的特性：</p>
<ul>
<li>如果 <code>S</code> 包含一个嵌入字段 <code>T</code>, 那么 <code>S</code> 和 <code>*S</code> 的方法集包含 receiver <code>T</code>的方法. 而 <code>*S</code> 还包含 receiver <code>*T</code>的方法.</li>
<li>如果 <code>S</code> 包含一个嵌入字段 <code>*T</code>, 那么 <code>S</code> 和 <code>*S</code> 的方法集都包含 receiver <code>T</code> 和 <code>*T</code>的方法.</li>
</ul>
<p><code>*S</code> 可以直接访问 <code>S</code> 的方法，而不必求值后再访问。</p>
<p>关于方法集和receiver我们在以后再讲。</p>
<p>字段的声明中还可以包含一个缺省的字符串tag, 用来作为这个字段的属性，通过反射可以得到这个tag的值，在类型比较的时候会进行比较。经常用在结构体的序列化反序列化中,序列化库可以根据这些tag将相应的字段转换成合适的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ColorGroup <span class="keyword">struct</span> {</div><div class="line">	Id     <span class="typename">int</span>      <span class="string">`json:"id" xml:"id,attr" msg:"id"`</span></div><div class="line">	Name   <span class="typename">string</span>   <span class="string">`json:"name" xml:"name" msg:"name"`</span></div><div class="line">	Colors []<span class="typename">string</span> <span class="string">`json:"colors" xml:"colors" msg:"colors"`</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>struct本身也可以是匿名的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">struct</span> {</div><div class="line">	Name <span class="typename">string</span></div><div class="line">}{<span class="string">"鸟窝"</span>}</div></pre></td></tr></table></figure>

<p>但是不能把一个匿名struct作为匿名字段，因为Go不知道如何命名此字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>

<p>所以必须为匿名struct字段命名，初始化的时候还挺麻烦：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> u = <span class="keyword">struct</span> {</div><div class="line">	Age  <span class="typename">int</span></div><div class="line">	Name <span class="keyword">struct</span> {</div><div class="line">		FirstName <span class="typename">string</span></div><div class="line">		LastName  <span class="typename">string</span></div><div class="line">	}</div><div class="line">}{Age:<span class="number"> 18</span>, Name: <span class="keyword">struct</span> {</div><div class="line">	FirstName <span class="typename">string</span></div><div class="line">	LastName  <span class="typename">string</span></div><div class="line">}{<span class="string">"鸟"</span>, <span class="string">"窝"</span>}}</div></pre></td></tr></table></figure>

<h3 id="指针类型">指针类型</h3>
<p>指针类型相对于于C语言，是一个简化版的指针，避免了C语言指针复杂的计算带来的陷阱。</p>
<p>指针类型就是在原有的类型前面加星号 <code>*</code>。</p>
<p>假设有个操作数x, 类型为T, 那么 <code>&amp;T</code>则为x的指针，类型为 <code>*T</code>。</p>
<p>你可以声明指向指针的指针:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x :=<span class="number"> 10</span></div><div class="line">p := &x</div><div class="line"><span class="keyword">var</span> pp **<span class="typename">int</span> = &p</div><div class="line">fmt.Printf(<span class="string">"%d\n"</span>, **pp)</div></pre></td></tr></table></figure>

<p>但是不能像C语言一样直接移动指针:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x := [...]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 4</span>,<span class="number"> 5</span>}</div><div class="line">p := &x</div><div class="line">p = p +<span class="number"> 1</span></div><div class="line">fmt.Printf(<span class="string">"%d\n"</span>, *p)</div></pre></td></tr></table></figure>

<p>虽然我们不能直接移动指针，但是我们可以通过曲折的方法操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">x := [...]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 4</span>,<span class="number"> 5</span>}</div><div class="line">p := &x<span class="number">[0</span>]</div><div class="line"></div><div class="line"><span class="comment">//p = p + 1</span></div><div class="line">index2Pointer := unsafe.Pointer(<span class="typename">uintptr</span>(unsafe.Pointer(p)) + unsafe.Sizeof(x<span class="number">[0</span>]))</div><div class="line">p = (*<span class="typename">int</span>)(index2Pointer) <span class="comment">//x[1]</span></div><div class="line">fmt.Printf(<span class="string">"%d\n"</span>, *p)    <span class="comment">//2</span></div></pre></td></tr></table></figure>

<p>这个例子中我们成功地将指针移动到第二个索引处，虽然它和 &amp;x[1]的功能是一样的，但却表明我们可以根据偏移量计算指针。<br>这种方法更多的应用到struct的字段值的读取中，一些序列化的库通过它来读取struct字段的值。</p>
<p>首先我们认识两个对象: <code>uintptr</code>和<code>unsafe.Pointer</code>。<br><code>uintptr</code>是一个足够大的整数，用来存放指针的位。</p>
<p><code>unsafe.Pointer</code>定义如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ArbitraryType <span class="typename">int</span>  <span class="comment">// shorthand for an arbitrary Go type; it is not a real type</span></div><div class="line"><span class="keyword">type</span> Pointer *ArbitraryType</div></pre></td></tr></table></figure>

<p>Pointer代表指向任意类型的指针，它有四个独有的操作：<br>1) 任意类型的指针可以被转换成一个 Pointer对象.<br>2) 相反一个Pointer也可以转换成任意类型的指针.<br>3) 一个uintptr可以转换成一个Pointer.<br>4) 相反一个Pointer可以转换成uintptr.</p>
<p>通过Pointer我们就可以直接读取内存，使用起来要格外小心。<br>下面列出了几种转换：<br>1、*T -&gt;  Pointer to T2</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i <span class="typename">int64</span> =<span class="number"> 100</span></div><div class="line"><span class="keyword">var</span> p *<span class="typename">int64</span> = &i <span class="comment">//*int64</span></div><div class="line">P := unsafe.Pointer(p)</div></pre></td></tr></table></figure>

<p>2、Pointer to T2 -&gt; *T</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i <span class="typename">int64</span> =<span class="number"> 100</span></div><div class="line"><span class="keyword">var</span> p *<span class="typename">int64</span> = &i <span class="comment">//*int64</span></div><div class="line"></div><div class="line">P := unsafe.Pointer(p)</div><div class="line"></div><div class="line">p2 := (*<span class="typename">int32</span>)(P) <span class="comment">//*int32</span></div><div class="line">fmt.Println(*p2)</div></pre></td></tr></table></figure>

<p>3、Pointer -&gt; uintptr</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i <span class="typename">int64</span> =<span class="number"> 200</span>&lt;<span class="number">&lt;32</span> +<span class="number"> 100</span></div><div class="line"><span class="keyword">var</span> p = &i</div><div class="line">P0 := unsafe.Pointer(p)</div><div class="line"></div><div class="line">P := unsafe.Pointer(<span class="typename">uintptr</span>(P0) +<span class="number"> 4</span>)</div><div class="line">p2 := (*<span class="typename">int32</span>)(P)</div><div class="line"></div><div class="line">fmt.Println(*p2) <span class="comment">//200</span></div></pre></td></tr></table></figure>

<p>4、uintptr -&gt; Pointer<br>同上, Pointer(uintptr)转换即可。</p>
<p>内建的<code>new</code>函数可以为类型T创建零值的对象,它返回的对象类型为<code>*T</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i = <span class="built_in">new</span>(<span class="typename">int</span>)</div><div class="line"><span class="keyword">var</span> s = <span class="built_in">new</span>(<span class="typename">string</span>)</div><div class="line"><span class="keyword">var</span> j = <span class="built_in">new</span>(<span class="keyword">struct</span>{ <span class="typename">int</span> })</div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"%T %T %T\n"</span>, i, s, j) <span class="comment">//*int *string *struct { int }</span></div></pre></td></tr></table></figure>

<p>参考</p>
<ul>
<li><a href="https://golang.org/pkg/unsafe/" target="_blank" rel="external">https://golang.org/pkg/unsafe/</a></li>
<li><a href="http://learngowith.me/gos-pointer-pointer-type/" target="_blank" rel="external">http://learngowith.me/gos-pointer-pointer-type/</a></li>
</ul>
<h3 id="函数类型">函数类型</h3>
<p>在Go语言中，函数是第一类的，可以赋值给变量，当做参数传入传出。</p>
<p>参数名和返回值名可以省略，但是如果要省略，必须所有的参数名或者返回值名全省略，部分省略是不行的。</p>
<p>通过<code>...</code>支持变参，但是变参只能作为最后一个参数。</p>
<p>如果不需要返回值，则不需要定义返回类型。</p>
<p>可以命名函数类型。</p>
<p>以下都是合法的函数类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span>()</div><div class="line"><span class="keyword">func</span>(x <span class="typename">int</span>) <span class="typename">int</span></div><div class="line"><span class="keyword">func</span>(a, _ <span class="typename">int</span>, z <span class="typename">float32</span>) <span class="typename">bool</span></div><div class="line"><span class="keyword">func</span>(a, b <span class="typename">int</span>, z <span class="typename">float32</span>) (<span class="typename">bool</span>)</div><div class="line"><span class="keyword">func</span>(prefix <span class="typename">string</span>, values ...<span class="typename">int</span>)</div><div class="line"><span class="keyword">func</span>(a, b <span class="typename">int</span>, z <span class="typename">float64</span>, opt ...<span class="keyword">interface</span>{}) (success <span class="typename">bool</span>)</div><div class="line"><span class="keyword">func</span>(<span class="typename">int</span>, <span class="typename">int</span>, <span class="typename">float64</span>) (<span class="typename">float64</span>, *[]<span class="typename">int</span>)</div><div class="line"><span class="keyword">func</span>(n <span class="typename">int</span>) <span class="keyword">func</span>(p *T)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Handler <span class="keyword">func</span>(ResponseWriter, *Request)</div></pre></td></tr></table></figure>

<p>注意此处介绍的是函数类型，函数的定义可以指定函数名称，也可以定义匿名函数。</p>
<h3 id="接口类型">接口类型</h3>
<p>Go并没有Java那样的完全的面向对象的类型系统， 而是通过接口和duck typing支持面向对象的编程,也就是会呱呱叫的我们都认为它是鸭子。</p>
<p>一个接口代表一组方法的集合。任何实现了这些方法的类型的值都可以赋值给这个接口变量，我们也可以说这些类型实现了这个接口。</p>
<p>特殊的， <code>interface{}</code>代表一个万能的接口，其它类型都实现了这个接口，有点像Java中的Object类。</p>
<p>接口也可以嵌入,只要保证方法名唯一即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> {</div><div class="line">	Read(b Buffer) <span class="typename">bool</span></div><div class="line">	Write(b Buffer) <span class="typename">bool</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> File <span class="keyword">interface</span> {</div><div class="line">	ReadWriter  <span class="comment">// same as adding the methods of ReadWriter</span></div><div class="line">	Locker      <span class="comment">// same as adding the methods of Locker</span></div><div class="line">	Close()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> LockedFile <span class="keyword">interface</span> {</div><div class="line">	Locker</div><div class="line">	File        <span class="comment">// illegal: Lock, Unlock not unique</span></div><div class="line">	Lock()      <span class="comment">// illegal: Lock not unique</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>但是接口不能嵌入它本身，或者递归地嵌入本身。</p>
<p>参考</p>
<ul>
<li><a href="https://medium.com/@matryer/golang-advent-calendar-day-one-duck-typing-a513aaed544d#.m5iuzvhjg" target="_blank" rel="external">https://medium.com/@matryer/golang-advent-calendar-day-one-duck-typing-a513aaed544d#.m5iuzvhjg</a></li>
</ul>
<h3 id="Map类型">Map类型</h3>
<p>Map类型在Go语言中提高到语言规范的级别，在Java只是作为类库中的类实现的。</p>
<p>Map是一组无序的键值对的集合。键的类型相同，值的类型也相同。</p>
<p>Map的变量的定义可以通过下面几种方式,中括号中是键的类型，后边接着是值的类型，键：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span>)</div><div class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span>,<span class="number"> 100</span>)</div><div class="line">m3 := <span class="built_in">new</span>(<span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span>)</div><div class="line"><span class="keyword">var</span> m4 <span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span></div></pre></td></tr></table></figure>

<p>一般通过｀make｀方法生成，可以设置map的初始容量，但是在增加元素的时候容量会快速增加，这也是一般map集合应对元素扩展的时候的方法。</p>
<p>注意， map的键类型是必须是可以比较的(comparable),比如下面的类型都不能作为键值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Func <span class="keyword">func</span>()</div><div class="line"><span class="keyword">type</span> SL []<span class="typename">int</span></div><div class="line"><span class="keyword">type</span> M <span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[Func]<span class="typename">int</span>) <span class="comment">//错误</span></div><div class="line">	m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[SL]<span class="typename">int</span>) <span class="comment">//错误</span></div><div class="line">	m3 := <span class="built_in">make</span>(<span class="keyword">map</span>[M]<span class="typename">int</span>) <span class="comment">//错误</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>只有以下类型可以比较，也就是可以应用比较操作符(&gt;、 &lt;、＝＝ 等):</p>
<ul>
<li>布尔型</li>
<li>整型</li>
<li>浮点型</li>
<li>复数</li>
<li>字符串</li>
<li>指针</li>
<li>Channel</li>
<li>接口</li>
<li>struct</li>
<li>数组</li>
</ul>
<p>内置函数<code>delete</code>可以根据key删除map对象的entry, 如果map为nil或者键不存在，delete相当于一个空操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">delete</span>(m, k)  <span class="comment">// remove element m[k] from map m</span></div></pre></td></tr></table></figure>

<p>而往map中增加元素或者查找元素都是通过索引实现的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">m[k] = v</div><div class="line"><span class="keyword">var</span> v = m[k]</div><div class="line">t, ok := m[k]</div></pre></td></tr></table></figure>

<p>参考</p>
<ul>
<li><a href="https://blog.golang.org/go-maps-in-action" target="_blank" rel="external">https://blog.golang.org/go-maps-in-action</a></li>
</ul>
<h3 id="Channel类型">Channel类型</h3>
<p>Channel类型我在另外一篇文章中专门介绍了，本文中就不再赘述: <a href="http://colobu.com/2016/04/14/Golang-Channels/" target="_blank" rel="external">Go Channel 详解</a></p>
<h3 id="类型的零值">类型的零值</h3>
<p>当一个值被创建的时候，无论你是用什么方法，声明或者new方法创建，如果没有显示地初始化，Go就会给它分配一个零值(zero value)。</p>
<ul>
<li>布尔型: false</li>
<li>整数: 0</li>
<li>浮点数: 0.0</li>
<li>字符串: &quot;&quot;</li>
<li>指针: nil</li>
<li>函数: nil</li>
<li>接口: nil</li>
<li>slice: nil</li>
<li>channel: nil</li>
<li>map: nil</li>
</ul>
<p>值得注意的是字符串，从Java转过来的程序员会以为字符串的零值是nil，其实不是，字符串的零值是空的字符串。</p>
<h3 id="类型的比较">类型的比较</h3>
<p>如何判断两个对象的类型是一样的？本节我们来讨论类型一致性(Type identity, 类型完全相同)。</p>
<p>两个类型，要么类型一致，要不类型不同。</p>
<p>1、如果两个命名类型传承自同样的<a href="https://golang.org/ref/spec#Type_declarations" target="_blank" rel="external">TypeSpec</a>)，则它们是类型一致的。这是显然地，因为是自己和自己比较<br>2、一个命名类型和一个未命名类型肯定是类型不一致</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> (</div><div class="line">	T0 []<span class="typename">string</span></div><div class="line">	T1 []<span class="typename">string</span></div><div class="line">	T2 <span class="keyword">struct</span>{ a, b <span class="typename">int</span> }</div><div class="line">)</div></pre></td></tr></table></figure>

<p><code>T0</code>、<code>T1</code>、 <code>T2</code>和 <code>[]string</code>都是不同的。</p>
<p>对于两个未命名类型，如果类型的声明一致，则类型一致，具体如下：<br>1、两个数组类型一致， 如果它们的元素的类型是类型一致并且数组长度相同<br>2、两个slice类型一致，如果它们的元素的类型是类型一致<br>3、两个struct类型一致，如果它们拥有相同的字段序列，并且相应的字段的名字相同而且类型一致，并且tag相同。两个匿名字段被认为有相同的名字。不同包下的Lower-case字段总是不同的<br>4、两个指针类型相同，如果它们指向的对象的类型是类型一致的<br>5、两个函数的类型相同，如果它们的参数和返回值的数量一致，并且类型一致，都有变参或者都没有。不要求参数名和返回名一致<br>6、两个接口类型相同，如果它们的方法集相同，方法名相同，方法的类型一致。不同包下的Lower-case方法名是不同的。方法声明的顺序无关<br>7、两个map类型相同，如果它们的key和value的类型一致<br>8、两个channel类型一致，如果它们的值的类型一致，并且有相同的方法(direction)</p>
<p>对于下列类型:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> (</div><div class="line">	T0 []<span class="typename">string</span></div><div class="line">	T1 []<span class="typename">string</span></div><div class="line">	T2 <span class="keyword">struct</span>{ a, b <span class="typename">int</span> }</div><div class="line">	T3 <span class="keyword">struct</span>{ a, c <span class="typename">int</span> }</div><div class="line">	T4 <span class="keyword">func</span>(<span class="typename">int</span>, <span class="typename">float64</span>) *T0</div><div class="line">	T5 <span class="keyword">func</span>(x <span class="typename">int</span>, y <span class="typename">float64</span>) *[]<span class="typename">string</span></div><div class="line">)</div></pre></td></tr></table></figure>

<p>下列的类型是一致的：</p>
<ul>
<li><code>T0</code> 和 <code>T0</code></li>
<li><code>[]int</code> 和<code>[]int</code></li>
<li><code>struct{ a, b *T5 }</code> 和 <code>struct{ a, b *T5 }</code></li>
<li><code>func(x int, y float64) *[]string</code> 和 <code>func(int, float64) (result *[]string)</code></li>
</ul>
<p>但是<code>T0</code> 和 <code>T1</code> 类型不同; <code>func(int, float64) *T0</code> 和 <code>func(x int, y float64) *[]string</code> 也不同， 因为 <code>T0</code> 和 <code>[]string</code>不同。</p>
<p>这也容易理解，不同的类型可以拥有不同的方法集。</p>
<h3 id="赋值">赋值</h3>
<p>一个值x只有在下述情况下才能指派给类型<code>T</code> (类型为T的一个变量):</p>
<ul>
<li>x的类型和<code>T</code>类型一致。 相同类型的值当然可以赋值给相同类型的变量。</li>
<li>x的类型<code>V</code>和 类型<code>T</code>的底层类型一致， 并且至少<code>V</code>和<code>T</code>中的一个是未命名类型。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> S1 <span class="keyword">struct</span> {</div><div class="line">	Name <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> s2 = <span class="keyword">struct</span> {</div><div class="line">	Name <span class="typename">string</span></div><div class="line">}{<span class="string">"hello"</span>}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> s1 S1 = s2</div><div class="line">	fmt.Printf(<span class="string">"%#v\n"</span>, s1)</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li><code>T</code> 是一个接口, 而 x 实现了接口<code>T</code>。</li>
<li>x 是双向的channel, 而 <code>T</code>是一个channel类型，并且 x 的类型 <code>V</code> 和 <code>T</code>的元素的类型是类型一致的，并且 <code>V</code> 和 <code>T</code>至少有一个是未命名类型。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> CH1 *(<span class="keyword">chan</span> <span class="typename">int</span>)</div><div class="line"></div><div class="line"><span class="keyword">var</span> ch2 = <span class="built_in">new</span>(<span class="keyword">chan</span> <span class="typename">int</span>)</div><div class="line"></div><div class="line"><span class="keyword">type</span> CH3 *(<span class="keyword">chan</span> <span class="typename">int</span>)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> ch1 CH1 = ch2</div><div class="line">	<span class="comment">//var ch3 CH3 = ch2</span></div><div class="line">	<span class="comment">//ch1 = ch3</span></div><div class="line">	fmt.Printf(<span class="string">"%#v\n"</span>, ch1)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上例中ch2可以赋值给<code>CH1</code>、<code>CH2</code>类型的变量，因为ch2的类型是未命令类型,但是ch3就不可以赋值ch1，因为它们两个的类型都是命名类型。</p>
<ul>
<li>x 是预声明的值 <code>nil</code>,  <code>T</code>是一个指针、函数、slice、map、channel 或者接口的话，可以赋值，<code>nil</code>是这些类型的零值。</li>
<li>x 是一个未标明类型的常量，可以作为类型<code>T</code>的值。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> c =<span class="number"> 100</span></div><div class="line"><span class="keyword">var</span> _ <span class="typename">int</span> = c</div><div class="line"><span class="keyword">var</span> _ <span class="typename">int64</span> = c</div><div class="line"><span class="keyword">var</span> _ <span class="typename">int8</span> = c</div><div class="line"><span class="keyword">var</span> _ <span class="typename">float32</span> = c</div><div class="line"><span class="keyword">var</span> _ <span class="typename">float64</span> = c</div></pre></td></tr></table></figure>

<h3 id="代码块(block)">代码块(block)</h3>
<p>代码块是用括号&quot;{}&quot;括起来的包含声明和语句的一段代码。可以为空。</p>
<p>事实上当你编写Go代码的时候，就包含了隐式的代码块:</p>
<ul>
<li>全局的语句块包含所有的源码</li>
<li>package包含本package中的源码</li>
<li>每个文件包含一个文件代码块,它包含本文件中的所有源码</li>
<li><code>if</code>、<code>for</code> 和 <code>switch</code>语句包含在它们的隐式代码块中</li>
<li><code>switch</code>、<code>select</code>中的每一个clause语句都是一个隐式代码块</li>
</ul>
<p>代码块最重要的特性就是scope,以后讲。</p>
<blockquote>
<p>声明一下， 本系列的第一部分基本是按照Go语言的规范编写的，大量参考了Go语言规范的内容</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文介绍Go的类型系统,以及类型的比较和语句块。</p>
<p>Go语言包含11种类型，你应该很熟悉了，下面让我们再深入的了解一下每种类型的细节。</p>
<ul>
<li>布尔类型</li>
<li>数值类型</li>
<li>字符串类型</li>
<li>数组类型</li>
<li>Slice类型</li>
<li>Struct类型</li>
<li>指针类型</li>
<li>函数类型</li>
<li>接口类型</li>
<li>Map类型</li>
<li>Channel类型</li>
</ul>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go语言 - 2]]></title>
    <link href="http://colobu.com/2016/06/16/dive-into-go-2/"/>
    <id>http://colobu.com/2016/06/16/dive-into-go-2/</id>
    <published>2016-06-16T01:40:43.000Z</published>
    <updated>2016-06-21T08:57:05.000Z</updated>
    <content type="html"><![CDATA[<p>本文介绍Go语言的常量和变量的语言细节。</p>
<a id="more"></a>
<h3 id="常量">常量</h3>
<p>只有数值类型和字符串类型才可以作为常量。</p>
<p>数值类型包括 布尔类型、rune类型、各种整型、浮点类型、复数。</p>
<p>常量值既可以是数值类型的字面量，也可以是字符串字面量，以及常量的等价形式， 如：</p>
<ol>
<li>常量表达式， 如 <code>4 * 5</code></li>
<li>转换结果是常量， 如 <code>int(10.0)</code></li>
<li>内建函数的返回值， 如<code>unsafe.Sizeof</code>、<code>cap</code>、<code>len</code></li>
<li>复数、实数和虚数的应用</li>
<li><code>true</code>和<code>false</code>赋值给bool类型的常量</li>
<li>内建的 <code>iota</code></li>
</ol>
<p>用变量赋值给常量是不允许的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> vs = <span class="string">"hello world"</span></div><div class="line"><span class="keyword">const</span> s = vs <span class="comment">//错误</span></div></pre></td></tr></table></figure>

<p>常量的命名还是遵循前一篇文章的介绍，所有你看到一些&quot;奇怪&quot;的常量名不要觉得奇怪:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> π =<span class="number"> 3.1415926</span></div><div class="line"><span class="keyword">const</span> Π =<span class="number"> 3.1415926</span></div></pre></td></tr></table></figure>

<p>常量可以不声明类型(untyped), 它会根据常量值设置默认的类型，默认类型为：</p>
<ul>
<li>bool</li>
<li>rune</li>
<li>int</li>
<li>float64</li>
<li>complex128</li>
<li>string</li>
</ul>
<p>在需要类型的上下文中，常量可以<strong>隐式</strong>转换成相应的类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> v1 <span class="typename">int</span> = i</div><div class="line"><span class="keyword">var</span> v2 <span class="typename">float32</span> = i</div><div class="line"><span class="keyword">var</span> v3 <span class="typename">complex64</span> = i</div></pre></td></tr></table></figure>

<p>注意不同类型的变量是不能转换的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> v4 <span class="typename">float64</span> = v2</div></pre></td></tr></table></figure>

<p>你不能将一个不能隐式转换成常量类型的值赋值给常量，比如下面的例子中<code>2147483648.0</code>不能赋值给int32, 溢出了:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> i2 <span class="typename">int32</span> =<span class="number"> 2147483648.0</span></div></pre></td></tr></table></figure>

<p>Go对常量的底层实现有限制：</p>
<ul>
<li>Represent integer constants with at least 256 bits.</li>
<li>Represent floating-point constants, including the parts of a complex constant, with a mantissa of at least 256 bits and a signed exponent of at least 32 bits.</li>
<li>Give an error if unable to represent an integer constant precisely.</li>
<li>Give an error if unable to represent a floating-point or complex constant due to overflow.</li>
<li>Round to the nearest representable constant if unable to represent a floating-point or complex constant due to limits on precision.</li>
</ul>
<p>声明多个变量的时候可以将声明放在一起：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">	i =<span class="number"> 1</span></div><div class="line">	s = <span class="string">"hello word"</span></div><div class="line">)</div></pre></td></tr></table></figure>

<p>或者将多个常量的定义放在一行中:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> i1, i2, i3 =<span class="number"> 0</span>,<span class="number"> 1</span>, <span class="string">"hello world"</span></div></pre></td></tr></table></figure>

<p>常量也可以定义在函数中:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> G() {</div><div class="line">  <span class="keyword">const</span> t =<span class="number"> 100</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="变量">变量</h3>
<p>变量代表一个值的存储位置，每个值都有类型。</p>
<p>变量在声明的时候如果同时有赋值操作，那么类型可以省略，因为可以根据值推断出来：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i1 <span class="typename">int</span> =<span class="number"> 100</span></div><div class="line"><span class="keyword">var</span> i2 =<span class="number"> 100</span></div></pre></td></tr></table></figure>

<p>类似于常量定义，你可以同时声明多个变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> (</div><div class="line">  i3 =<span class="number"> 120</span></div><div class="line">  i4 = <span class="string">"hello world"</span></div><div class="line">)</div></pre></td></tr></table></figure>

<p>或者一行声明多个变量:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i5, i6, i7 =<span class="number"> 100</span>, <span class="string">"hello world"</span>, <span class="constant">true</span></div><div class="line"><span class="keyword">var</span> i8, i9, i10 <span class="typename">int</span></div></pre></td></tr></table></figure>

<p>在上面的例子中i8、i9、i10都是 int类型,所以将类型写在最后面，下面的写法是不允许的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i11 <span class="typename">int</span>, i12 <span class="typename">int</span>, i13 <span class="typename">int</span> <span class="comment">//错误</span></div></pre></td></tr></table></figure>

<p>下面的语句也是非法的，因为声明的变量和赋值列表的数值数量必须一样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i14, i15, i16 =<span class="number"> 100</span>,<span class="number"> 200</span> <span class="comment">//错误</span></div><div class="line"><span class="keyword">var</span> i17, i18, i19 <span class="typename">int</span> =<span class="number"> 100</span>,<span class="number"> 200</span> <span class="comment">//错误</span></div></pre></td></tr></table></figure>

<h3 id="变量声明简化">变量声明简化</h3>
<p>如果变量在声明的时候同时初始化，那么它就可以简化。<br>比如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i1, i2 =<span class="number"> 100</span>, <span class="string">"hello world"</span></div></pre></td></tr></table></figure>

<p>可以简化为</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">i1, i2 :=<span class="number"> 100</span>, <span class="string">"hello world"</span></div></pre></td></tr></table></figure>

<p>记住，这个简写方法<strong>只能用在函数中</strong>，函数之外的变量声明不能简写，下面的写法是错误的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line">s := <span class="string">"中国"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">}</div></pre></td></tr></table></figure>

<p>不像普通的变量声明，简写方式声明的变量可以&quot;重新声明&quot;已有变量，只要保证有一个新的变量在变量列表中即可，当然“重新声明”的变量和原有变量的类型相同。<br>看下面的例子就容易理解了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> f *os.File</div><div class="line">	f, err := os.Open(<span class="string">"dive-into-go.pdf"</span>)</div><div class="line"></div><div class="line">	fmt.Println(f, err)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个例子中<code>f</code>变量重新被声明了，程序正常编译，没有错误，这是因为<code>err</code>是新的变量。<br>下面这个例子就编译不过，因为第4行没有新的变量定义。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> f *os.File</div><div class="line">	<span class="keyword">var</span> err error</div><div class="line">	f, err := os.Open(<span class="string">"dive-into-go.pdf"</span>)</div><div class="line"></div><div class="line">	fmt.Println(f, err)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>不能用简写方法赋值给一个结构体的字段(field):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> MyFile <span class="keyword">struct</span> {</div><div class="line">	<span class="keyword">var</span> F *os.File</div><div class="line">}</div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> mf MyFile</div><div class="line">	<span class="comment">//var err error</span></div><div class="line">	mf.F, err := os.Open(<span class="string">"dive-into-go.pdf"</span>)</div><div class="line"></div><div class="line">	fmt.Println(f, err)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意，简写方法有时候会迷惑你，因为它可能<code>shadow</code>一个变量，而且正常编译通过:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">x :=<span class="number"> 100</span></div><div class="line"><span class="keyword">func</span>() {</div><div class="line">  x :=<span class="number"> 200</span></div><div class="line">  fmt.Println(x) <span class="comment">//200</span></div><div class="line">}()</div><div class="line"></div><div class="line">fmt.Println(x) <span class="comment">//100</span></div></pre></td></tr></table></figure>

<p>在上面的例子中，如果本意是通过一个方法修改变量x的值为200的话，最终打印结果可能是100，因为第三行实际是声明了一个新的变量。</p>
<p>你可以通过<code>vet</code>工具检查代码中是否包含<code>shadow</code>的代码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go tool vet -shadow main8.go</div></pre></td></tr></table></figure>

<p>输出结果为:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">main8</span><span class="class">.go</span><span class="pseudo">:8</span>: <span class="tag">declaration</span> <span class="tag">of</span> <span class="tag">x</span> <span class="tag">shadows</span> <span class="tag">declaration</span> <span class="tag">at</span> <span class="tag">main8</span><span class="class">.go</span><span class="pseudo">:6</span>:</div></pre></td></tr></table></figure>

<p>变量和常量都可以定义在函数内或者包下，但是如果函数内的变量没有被使用，则会编译出错，这是Go语言有意这样设计的。包下的变量和常量，函数内的常量没有这个限制。</p>
<p>参考<br>＊ <a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html#short_vars" target="_blank" rel="external">http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html#short_vars</a></p>
<h3 id="静态类型和动态类型">静态类型和动态类型</h3>
<p>静态类型(static type)是变量声明的时候的声明类型，在变量声明、new方法创建对象时或者结构体(struct)的元素的类型定义，参数类型等。</p>
<p>接口(interface)类型的变量还有一个动态类型，它是运行时赋值给这个变量的具体的值的类型(当然值为nil的时候没有动态类型)。一个变量的动态类型在运行时可能改变，<br>这主要依赖它的赋值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>{}  <span class="comment">// x 为零值 nil,静态类型为 interface{}</span></div><div class="line"><span class="keyword">var</span> v *T           <span class="comment">// v 为零值 nil, 静态类型为 *T</span></div><div class="line">x =<span class="number"> 42</span>             <span class="comment">// x 的值为 42,动态类型为int, 静态类型为interface{}</span></div><div class="line">x = v              <span class="comment">// x 的值为 (*T)(nil)， 动态类型为 *T, 静态类型为 *T</span></div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>本文介绍Go语言的常量和变量的语言细节。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go语言 - 1]]></title>
    <link href="http://colobu.com/2016/06/15/dive-into-go-1/"/>
    <id>http://colobu.com/2016/06/15/dive-into-go-1/</id>
    <published>2016-06-15T06:49:48.000Z</published>
    <updated>2016-06-21T08:57:05.000Z</updated>
    <content type="html"><![CDATA[<p>准备写一个Go 语言深入开发的系列，分为三个部分。第一部分为Go 语言的深入剖析，第二部分为一些官方库的深入开发，第三部分为一些第三方库的介绍。</p>
<a id="more"></a>
<h3 id="奇怪的变量名">奇怪的变量名</h3>
<p>标志符用来命名变量、类型、函数名等，最常规的，我们使用普通的拉丁字母和数字作为标志符,或者以下划线开始。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">str := <span class="string">"hello world"</span></div><div class="line">fmt.Println(str)</div><div class="line"></div><div class="line">_str09 := <span class="string">"hello w0rld"</span></div><div class="line">fmt.Println(_str09)</div></pre></td></tr></table></figure>

<p>但是根据Go语言规范，任何Unicode编码的letter字符和下划线都可以作为标识符的第一个字母，之后可以是任意的Unicode的letter字符或者数字。<br>允许的unicode字符为Unicode分类中的Lu、Ll、Lt、Lm、Lo等字符，比如中文、希腊字母等。你可以在参考链接中查看相应的Unicode字符分类。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">一个变量 := <span class="string">"hello 世界"</span></div><div class="line">fmt.Println(一个变量)</div><div class="line"></div><div class="line">ÆõĦǗΩצˮ𝟡 := <span class="string">"hello ¾"</span></div><div class="line">fmt.Println(ÆõĦǗΩצˮ𝟡)</div></pre></td></tr></table></figure>

<p>标识符业可以是类型名、函数名等：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> 学生 <span class="keyword">struct</span> {</div><div class="line">	姓名 <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> 小学生 学生</div><div class="line"></div><div class="line"><span class="keyword">type</span> 조선말 <span class="keyword">interface</span> {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> 函数名() {</div><div class="line">	fmt.Println(<span class="string">"I am a function"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当然，我相信绝大部分的程序员都会以普通的拉丁字母和数字作为标识符的，这样阅读起来更符合大众的习惯。在搞怪的情况下，可以尝试一下这些&quot;奇怪&quot;字符。</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/List_of_Unicode_characters" target="_blank" rel="external">https://en.wikipedia.org/wiki/List_of_Unicode_characters</a></li>
<li><a href="http://www.unicode.org/Public/UNIDATA/UnicodeData.txt" target="_blank" rel="external">http://www.unicode.org/Public/UNIDATA/UnicodeData.txt</a></li>
<li><a href="http://www.fileformat.info/info/unicode/category/index.htm" target="_blank" rel="external">http://www.fileformat.info/info/unicode/category/index.htm</a></li>
</ul>
<h3 id="预定义标识符">预定义标识符</h3>
<p>首先看下面一段代码，看看是否能变易成功：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> i <span class="constant">nil</span> =<span class="number"> 100</span></div><div class="line">	fmt.Println(i)</div><div class="line"></div><div class="line">	<span class="keyword">var</span> isSuccess <span class="typename">bool</span> =<span class="number"> 100</span></div><div class="line">	fmt.Println(isSuccess)</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>你肯定会说，不可能成功，类型不对呀。</p>
<p>没错，不可能将一个整数赋值给布尔类型的变量的。 那么你能不能加在方法外面加几行，让代码编译成功？</p>
<p>请注意，以下标识符实预先定义的标识符，而不是关键字，这意味着我们可以&quot;覆盖&quot;这些标识符的定义。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Types:</div><div class="line">	<span class="typename">bool</span> <span class="typename">byte</span> <span class="typename">complex64</span> <span class="typename">complex128</span> error <span class="typename">float32</span> <span class="typename">float64</span></div><div class="line">	<span class="typename">int</span> <span class="typename">int8</span> <span class="typename">int16</span> <span class="typename">int32</span> <span class="typename">int64</span> <span class="typename">rune</span> <span class="typename">string</span></div><div class="line">	<span class="typename">uint</span> <span class="typename">uint8</span> <span class="typename">uint16</span> <span class="typename">uint32</span> <span class="typename">uint64</span> <span class="typename">uintptr</span></div><div class="line"></div><div class="line">Constants:</div><div class="line">	<span class="constant">true</span> <span class="constant">false</span> <span class="constant">iota</span></div><div class="line"></div><div class="line">Zero value:</div><div class="line">	<span class="constant">nil</span></div><div class="line"></div><div class="line">Functions:</div><div class="line">	<span class="built_in">append</span> <span class="built_in">cap</span> <span class="built_in">close</span> <span class="built_in">complex</span> <span class="built_in">copy</span> <span class="built_in">delete</span> <span class="built_in">imag</span> <span class="built_in">len</span></div><div class="line">	<span class="built_in">make</span> <span class="built_in">new</span> <span class="built_in">panic</span> <span class="built_in">print</span> <span class="built_in">println</span> <span class="built_in">real</span> <span class="built_in">recover</span></div></pre></td></tr></table></figure>

<p>比如加上下面几行代码，程序就可以编译通过。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> <span class="constant">nil</span> <span class="typename">int</span></div><div class="line"><span class="keyword">type</span> <span class="typename">bool</span> <span class="typename">uint8</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> i <span class="constant">nil</span> =<span class="number"> 100</span></div><div class="line">	fmt.Println(i)</div><div class="line"></div><div class="line">	<span class="keyword">var</span> isSuccess <span class="typename">bool</span> =<span class="number"> 100</span></div><div class="line">	fmt.Println(isSuccess)</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="整数字面量">整数字面量</h3>
<p>Go语言不像其它语言， 如C++、Java，在声明数值类型的时候可以通过后缀如ll等表明变量的类型， 目前Go语言不提供这个功能。</p>
<p>如果值以0开始，则代表8进制。</p>
<p>如果值以0x或者0X开始，则代表16进制。</p>
<p>浮点数和其它语言的表示法相同。</p>
<p>复数表示法业和其它语言一致。</p>
<h3 id="Rune">Rune</h3>
<p>其它语言如Java、C#，字符串的字符操作很直观，但是Go语言的字符串的实现比较特殊，这可能和Go设计者的几位大牛有关，它保留着Unix和C的痕迹。</p>
<p>Java语言规范规定，Java的char类型是UTF-16的code unit，也就是两个字节,字符串是UTF-16 code unit的序列，因此每个字符都是定长的，要想获得某个位置字符，很容易计算出它的字节在字符串中的位置。</p>
<p>Go语言使用UTF-8作为字符串的内部编码，所以在没有byte字面量的情况下，字符串都是使用UTF－8编码的。因此对于大部分字符串都是ascii字符的情况下，<br>占用的内存空间就会大大减少，但是带来的问题是，从字符串的字节slice中查找第n个字符比较麻烦，因为不能直接的计算出来。</p>
<p>这里通称所有字母都为字符，其实是不准确的，在Unicodde规范中，它们称之为<code>code point</code>， 比如code point U+2318代表 <code>⌘</code>。<br><code>A</code>既是一个字符，也是一个code point: U+00E0。</p>
<p>code point有点拗口，所以Go语言用<code>rune</code>来表示，你只需记住它们是等价的即可。</p>
<p>rune有单引号定义，它包含单一的一个 code point。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> r <span class="typename">rune</span> = <span class="string">'文'</span></div><div class="line">fmt.Printf(<span class="string">"%#U\n"</span>, r)</div></pre></td></tr></table></figure>

<p>通过<code>range</code>可以遍历一个字符串中所有的rune:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> nihongo = <span class="string">"one world世界大同"</span></div><div class="line"><span class="keyword">for</span> index, runeValue := <span class="keyword">range</span> nihongo {</div><div class="line">	fmt.Printf(<span class="string">"%#U starts at byte position %d\n"</span>, runeValue, index)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>因为字符串是以UTF-8编码的，通过输出可以看到ascii字母只用一个字节，而这几个中文汉字每个汉字用了3个字节。</p>
<p>要想获得字符串中包含几个字符(rune)，下面的方法是不对的,它返回的是字符处内部的字slice的长度((9 + 4*3 =21)：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> str = <span class="string">"one world世界大同"</span></div><div class="line">fmt.Println(<span class="built_in">len</span>(str))</div></pre></td></tr></table></figure>

<p>我记得有个Go语言写的框架，在获取一篇文章的前N个字符的时候，就直接用<code>len</code>方法计算，这对于中文文章来说，肯定不对，截取的字符要少于期望的字符数，而且可能截取半个字符。</p>
<p>要想在字符串中操作rune，可以使用 package <a href="https://golang.org/pkg/unicode/utf8/" target="_blank" rel="external">unicode/utf8</a>，它提供了一组处理字符串和rune的方法，<br>比如我们正确计算一个字符串中包含的rune的数量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fmt.Println(utf8.RuneCountInString(str))</div></pre></td></tr></table></figure>

<p>字符串以两端用双引号包含的方式定义，允许使用转义字符存在或者&quot;\&quot;＋byte方式包含rune。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="string">"Hello, world!\n"</span></div><div class="line"><span class="string">"世界"</span></div><div class="line"><span class="string">"\u65e5本\U00008a9e"</span></div><div class="line"><span class="string">"\xff\u00FF"</span></div><div class="line"><span class="string">"\uD800"</span>             <span class="comment">//非法</span></div><div class="line"><span class="string">"\U00110000"</span>         <span class="comment">//非法</span></div></pre></td></tr></table></figure>

<ul>
<li><a href="https://blog.golang.org/strings" target="_blank" rel="external">https://blog.golang.org/strings</a></li>
<li><a href="https://blog.golang.org/constants" target="_blank" rel="external">https://blog.golang.org/constants</a></li>
</ul>
<h3 id="Rune和字符串互转">Rune和字符串互转</h3>
<p>直接通过<code>T(x)</code>类型转换即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">r := []<span class="typename">rune</span>(str)</div><div class="line">fmt.Printf(<span class="string">"%#v\n"</span>, r)</div><div class="line">str = <span class="typename">string</span>(r)</div><div class="line">fmt.Printf(<span class="string">"%#v\n"</span>, str)</div></pre></td></tr></table></figure>

<p>另外 package <a href="https://golang.org/pkg/strconv/#AppendQuoteToASCII" target="_blank" rel="external">strconv</a>也提供了格式化rune为字符串的一些方法， 比如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s := strconv.QuoteRune(<span class="string">'☺'</span>)</div><div class="line">fmt.Println(s)</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>准备写一个Go 语言深入开发的系列，分为三个部分。第一部分为Go 语言的深入剖析，第二部分为一些官方库的深入开发，第三部分为一些第三方库的介绍。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[vscode-icons: 提高生产力的 Visual Studio Code插件]]></title>
    <link href="http://colobu.com/2016/06/15/vscode-icons-Icons-for-VS-Code-Explorer/"/>
    <id>http://colobu.com/2016/06/15/vscode-icons-Icons-for-VS-Code-Explorer/</id>
    <published>2016-06-15T03:02:50.000Z</published>
    <updated>2016-06-21T08:57:05.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/robertohuertasm/vscode-icons" target="_blank" rel="external">vscode-icons</a>可以为你的 Visual Studio Code的文件类型提供相应的图标。</p>
<p><img src="/2016/06/15/vscode-icons-Icons-for-VS-Code-Explorer/icons.png" alt=""></p>
<a id="more"></a>
<p>之前我一直使用<a href="https://atom.io/" target="_blank" rel="external">atom editor</a>做开发， atom的一些插件非常优秀，比如<a href="https://atom.io/packages/activate-power-mode" target="_blank" rel="external">activate-power-mode</a>、<a href="https://atom.io/packages/file-icons" target="_blank" rel="external">file-icons</a>等，<br>自从vscode 1.0发布之后，使用vscode开发 Go 程序更方便，所以目前基本上开发以vscode为主。而且atom的插件地址也被墙了，要想安装、更新插件还得翻墙，挺麻烦的。</p>
<p>但是vscode的功能和插件目前还不丰富，尤其是编辑窗口的<a href="https://github.com/Microsoft/vscode/issues/224" target="_blank" rel="external">标签显示</a>功能, 估计还药一段时间才能实现。<br>activate-power-mode对应的插件还没有实现，但是file-icons对应的插件终于有人做出来了，那就是文章开头的 vscode-icons。</p>
<p>这个插件的安装业很简单，通过以下命令久可以安装。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ext <span class="operator"><span class="keyword">install</span> vscode-icons</span></div></pre></td></tr></table></figure>

<p>如果你通过这个命令未能找到这个插件的话，可以试试下面的命令：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ext <span class="operator"><span class="keyword">install</span> icons</span></div></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ext <span class="operator"><span class="keyword">install</span> <span class="string">"vscode-icons"</span></span></div></pre></td></tr></table></figure>

<p>由于vscode的插件设计还不完善， vscode-icons通过暴力修改vscode的以下两个文件来显示图标：</p>
<ul>
<li>workbench.main.js</li>
<li>workbench.main.css</li>
</ul>
<p>当然，当你禁用这个插件的时候vscode-icons会把这两个文件恢复回来。</p>
<p>安装完这个插件你需要通过命令 启用、禁用、更新插件：</p>
<ul>
<li><strong>Icons Enable</strong> : 启用这个插件</li>
<li><strong>Icons Disable</strong>: 禁止显示图标</li>
<li><strong>Icons Update</strong>: 更新插件，更新图标</li>
</ul>
<p>为什么要推荐这个插件呢？它可以将同一类型的文件以相同图标的方式，让程序员可以直观的选择文件，提供生产效率。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/robertohuertasm/vscode-icons" target="_blank" rel="external">vscode-icons</a>可以为你的 Visual Studio Code的文件类型提供相应的图标。</p>
<p><img src="/2016/06/15/vscode-icons-Icons-for-VS-Code-Explorer/icons.png" alt=""></p>
]]>
    
    </summary>
    
      <category term="vscode" scheme="http://colobu.com/tags/vscode/"/>
    
      <category term="工具" scheme="http://colobu.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Go实现TLS 服务器和客户端]]></title>
    <link href="http://colobu.com/2016/06/07/simple-golang-tls-examples/"/>
    <id>http://colobu.com/2016/06/07/simple-golang-tls-examples/</id>
    <published>2016-06-07T03:37:05.000Z</published>
    <updated>2016-06-21T08:57:05.000Z</updated>
    <content type="html"><![CDATA[<p>传输层安全协议（Transport Layer Security，缩写：TLS），及其前身安全套接层（Secure Sockets Layer，缩写：SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。</p>
<p>SSL包含记录层（Record Layer）和传输层，记录层协议确定了传输层数据的封装格式。传输层安全协议使用X.509认证，之后利用非对称加密演算来对通信方做身份认证，之后交换对称密钥作为会谈密钥（Session key）。这个会谈密钥是用来将通信两方交换的数据做加密，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听。</p>
<p>本文并没有提供一个TLS的深度教程，而是提供了两个Go应用TLS的简单例子，用来演示使用Go语言快速开发安全网络传输的程序。</p>
<a id="more"></a>
<h3 id="TLS历史">TLS历史</h3>
<blockquote>
<p>1994年早期，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。<br>1994年11月，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。<br>1996年11月，SSL 3.0版问世，得到大规模应用。<br>1999年1月，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版<a href="https://www.ietf.org/rfc/rfc2246.txt" target="_blank" rel="external">TLS 1.0版</a>。<br>2006年4月和2008年8月，TLS进行了两次升级，分别为<a href="https://tools.ietf.org/html/rfc4346" target="_blank" rel="external">TLS 1.1</a>版和<a href="https://tools.ietf.org/html/rfc5246" target="_blank" rel="external">TLS 1.2</a>版。最新的变动是2011年TLS 1.2的修订版。<br>现在正在制定 <a href="https://github.com/tlswg/tls13-spec" target="_blank" rel="external">tls 1.3</a>。</p>
</blockquote>
<h3 id="证书生成">证书生成</h3>
<p>首先我们创建私钥和证书。</p>
<h4 id="服务器端的证书生成">服务器端的证书生成</h4>
<p>使用了&quot;服务端证书&quot;可以确保服务器不是假冒的。</p>
<p>1、 生成服务器端的私钥</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl genrsa -<span class="keyword">out</span> server.key <span class="number">2048</span></div></pre></td></tr></table></figure>

<p>2、 生成服务器端证书</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl req -<span class="keyword">new</span> -x509 -<span class="keyword">key</span> server.<span class="keyword">key</span> -out server.pem -days <span class="number">3650</span></div></pre></td></tr></table></figure>

<h4 id="客户端的证书生成">客户端的证书生成</h4>
<p>除了&quot;服务端证书&quot;，在某些场合中还会涉及到&quot;客户端证书&quot;。所谓的&quot;客户端证书&quot;就是用来证明客户端访问者的身份。<br>比如在某些金融公司的内网，你的电脑上必须部署&quot;客户端证书&quot;，才能打开重要服务器的页面。<br>我会在后面的例子中演示&quot;客户端证书&quot;的使用。</p>
<p>3、 生成客户端的私钥</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl genrsa -<span class="keyword">out</span> client.key <span class="number">2048</span></div></pre></td></tr></table></figure>

<p>4、 生成客户端的证书</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl req -<span class="keyword">new</span> -x509 -<span class="keyword">key</span> client.<span class="keyword">key</span> -out client.pem -days <span class="number">3650</span></div></pre></td></tr></table></figure>

<p>或者使用下面的脚本：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="shebang">#!/bin/bash</span></div><div class="line"><span class="comment"># call this script with an email address (valid or not).</span></div><div class="line"><span class="comment"># like:</span></div><div class="line"><span class="comment"># ./makecert.sh demo@random.com</span></div><div class="line">mkdir certs</div><div class="line">rm certs/*</div><div class="line"><span class="built_in">echo</span> <span class="string">"make server cert"</span></div><div class="line">openssl req -new -nodes -x509 -out certs/server.pem -keyout certs/server.key -days <span class="number">3650</span> -subj <span class="string">"/C=DE/ST=NRW/L=Earth/O=Random Company/OU=IT/CN=www.random.com/emailAddress=<span class="variable">$1</span>"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"make client cert"</span></div><div class="line">openssl req -new -nodes -x509 -out certs/client.pem -keyout certs/client.key -days <span class="number">3650</span> -subj <span class="string">"/C=DE/ST=NRW/L=Earth/O=Random Company/OU=IT/CN=www.random.com/emailAddress=<span class="variable">$1</span>"</span></div></pre></td></tr></table></figure>

<h3 id="Golang_例子">Golang 例子</h3>
<p>Go <a href="https://golang.org/pkg/crypto/tls/" target="_blank" rel="external">Package tls</a>部分实现了 tls 1.2的功能，可以满足我们日常的应用。<a href="https://golang.org/pkg/crypto/x509/" target="_blank" rel="external">Package crypto/x509</a>提供了证书管理的相关操作。</p>
<h4 id="服务器证书的使用">服务器证书的使用</h4>
<p>本节代码提供了服务器使用证书的例子。</p>
<p>下面的代码是服务器的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"bufio"</span></div><div class="line">	<span class="string">"crypto/tls"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	cert, err := tls.LoadX509KeyPair(<span class="string">"server.pem"</span>, <span class="string">"server.key"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Println(err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	config := &tls.Config{Certificates: []tls.Certificate{cert}}</div><div class="line">	ln, err := tls.Listen(<span class="string">"tcp"</span>, <span class="string">":443"</span>, config)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Println(err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line">	<span class="keyword">defer</span> ln.Close()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		conn, err := ln.Accept()</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Println(err)</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		}</div><div class="line">		<span class="keyword">go</span> handleConn(conn)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> handleConn(conn net.Conn) {</div><div class="line">	<span class="keyword">defer</span> conn.Close()</div><div class="line">	r := bufio.NewReader(conn)</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		msg, err := r.ReadString(<span class="string">'\n'</span>)</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Println(err)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="built_in">println</span>(msg)</div><div class="line"></div><div class="line">		n, err := conn.Write([]<span class="typename">byte</span>(<span class="string">"world\n"</span>))</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Println(n, err)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>首先从上面我们创建的服务器私钥和pem文件中得到证书<code>cert</code>，并且生成一个tls.Config对象。这个对象有多个字段可以设置，本例中我们使用它的默认值。<br>然后用<code>tls.Listen</code>开始监听客户端的连接，accept后得到一个net.Conn，后续处理和普通的TCP程序一样。</p>
<p>然后，我们看看客户端是如何实现的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"crypto/tls"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	conf := &tls.Config{</div><div class="line">		InsecureSkipVerify: <span class="constant">true</span>,</div><div class="line">	}</div><div class="line"></div><div class="line">	conn, err := tls.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:443"</span>, conf)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Println(err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line">	<span class="keyword">defer</span> conn.Close()</div><div class="line"></div><div class="line">	n, err := conn.Write([]<span class="typename">byte</span>(<span class="string">"hello\n"</span>))</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Println(n, err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	buf := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 100</span>)</div><div class="line">	n, err = conn.Read(buf)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Println(n, err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="built_in">println</span>(<span class="typename">string</span>(buf[:n]))</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>InsecureSkipVerify</code>用来控制客户端是否证书和服务器主机名。如果设置为true,则不会校验证书以及证书中的主机名和服务器主机名是否一致。<br>因为在我们的例子中使用自签名的证书，所以设置它为true,仅仅用于测试目的。</p>
<p>可以看到，整个的程序编写和普通的TCP程序的编写差不太多，只不过初始需要做一些TLS的配置。</p>
<p>你可以<code>go run server.go</code>和<code>go run client.go</code>测试这个例子。</p>
<h4 id="客户端证书的使用">客户端证书的使用</h4>
<p>在有的情况下，需要双向认证，服务器也需要验证客户端的真实性。在这种情况下，我们需要服务器和客户端进行一点额外的配置。</p>
<p>服务器端：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"bufio"</span></div><div class="line">	<span class="string">"crypto/tls"</span></div><div class="line">	<span class="string">"crypto/x509"</span></div><div class="line">	<span class="string">"io/ioutil"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	cert, err := tls.LoadX509KeyPair(<span class="string">"server.pem"</span>, <span class="string">"server.key"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Println(err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	certBytes, err := ioutil.ReadFile(<span class="string">"client.pem"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"Unable to read cert.pem"</span>)</div><div class="line">	}</div><div class="line">	clientCertPool := x509.NewCertPool()</div><div class="line">	ok := clientCertPool.AppendCertsFromPEM(certBytes)</div><div class="line">	<span class="keyword">if</span> !ok {</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"failed to parse root certificate"</span>)</div><div class="line">	}</div><div class="line"></div><div class="line">	config := &tls.Config{</div><div class="line">		Certificates: []tls.Certificate{cert},</div><div class="line">		ClientAuth:   tls.RequireAndVerifyClientCert,</div><div class="line">		ClientCAs:    clientCertPool,</div><div class="line">	}</div><div class="line">	ln, err := tls.Listen(<span class="string">"tcp"</span>, <span class="string">":443"</span>, config)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Println(err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line">	<span class="keyword">defer</span> ln.Close()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		conn, err := ln.Accept()</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Println(err)</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		}</div><div class="line">		<span class="keyword">go</span> handleConn(conn)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> handleConn(conn net.Conn) {</div><div class="line">	<span class="keyword">defer</span> conn.Close()</div><div class="line">	r := bufio.NewReader(conn)</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		msg, err := r.ReadString(<span class="string">'\n'</span>)</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Println(err)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="built_in">println</span>(msg)</div><div class="line"></div><div class="line">		n, err := conn.Write([]<span class="typename">byte</span>(<span class="string">"world\n"</span>))</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Println(n, err)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>因为需要验证客户端，我们需要额外配置下面两个字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ClientAuth:   tls.RequireAndVerifyClientCert,</div><div class="line">ClientCAs:    clientCertPool,</div></pre></td></tr></table></figure>

<p>然后客户端也配置这个<code>clientCertPool</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"crypto/tls"</span></div><div class="line">	<span class="string">"crypto/x509"</span></div><div class="line">	<span class="string">"io/ioutil"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	cert, err := tls.LoadX509KeyPair(<span class="string">"client.pem"</span>, <span class="string">"client.key"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Println(err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	certBytes, err := ioutil.ReadFile(<span class="string">"client.pem"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"Unable to read cert.pem"</span>)</div><div class="line">	}</div><div class="line"></div><div class="line">	clientCertPool := x509.NewCertPool()</div><div class="line">	ok := clientCertPool.AppendCertsFromPEM(certBytes)</div><div class="line">	<span class="keyword">if</span> !ok {</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"failed to parse root certificate"</span>)</div><div class="line">	}</div><div class="line"></div><div class="line">	conf := &tls.Config{</div><div class="line">		RootCAs:            clientCertPool,</div><div class="line">		Certificates:       []tls.Certificate{cert},</div><div class="line">		InsecureSkipVerify: <span class="constant">true</span>,</div><div class="line">	}</div><div class="line"></div><div class="line">	conn, err := tls.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:443"</span>, conf)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Println(err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line">	<span class="keyword">defer</span> conn.Close()</div><div class="line"></div><div class="line">	n, err := conn.Write([]<span class="typename">byte</span>(<span class="string">"hello\n"</span>))</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Println(n, err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	buf := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 100</span>)</div><div class="line">	n, err = conn.Read(buf)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Println(n, err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="built_in">println</span>(<span class="typename">string</span>(buf[:n]))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行这两个代码<code>go run server2.go</code>和<code>go run client2.go</code>,可以看到两者可以正常的通讯，如果用前面的客户端<code>go run client.go</code>，不能正常通讯，因为前面的客户端并没有提供客户端证书。</p>
<h3 id="参考文档和代码">参考文档和代码</h3>
<ol>
<li><a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E5%8D%94%E8%AD%B0" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E5%8D%94%E8%AD%B0</a></li>
<li><a href="http://drops.wooyun.org/tips/6002" target="_blank" rel="external">http://drops.wooyun.org/tips/6002</a></li>
<li><a href="http://www.levigross.com/2015/11/21/mutual-tls-authentication-in-go/" target="_blank" rel="external">http://www.levigross.com/2015/11/21/mutual-tls-authentication-in-go/</a></li>
<li><a href="https://github.com/nareix/blog/blob/master/posts/golang-tls-guide.md" target="_blank" rel="external">https://github.com/nareix/blog/blob/master/posts/golang-tls-guide.md</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></li>
<li><a href="https://gist.github.com/spikebike/2232102" target="_blank" rel="external">https://gist.github.com/spikebike/2232102</a></li>
<li><a href="https://github.com/nareix/tls-example" target="_blank" rel="external">https://github.com/nareix/tls-example</a></li>
<li><a href="http://seanlook.com/2015/01/07/tls-ssl/" target="_blank" rel="external">http://seanlook.com/2015/01/07/tls-ssl/</a></li>
<li><a href="https://golang.org/pkg/crypto/tls/" target="_blank" rel="external">https://golang.org/pkg/crypto/tls/</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>传输层安全协议（Transport Layer Security，缩写：TLS），及其前身安全套接层（Secure Sockets Layer，缩写：SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。</p>
<p>SSL包含记录层（Record Layer）和传输层，记录层协议确定了传输层数据的封装格式。传输层安全协议使用X.509认证，之后利用非对称加密演算来对通信方做身份认证，之后交换对称密钥作为会谈密钥（Session key）。这个会谈密钥是用来将通信两方交换的数据做加密，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听。</p>
<p>本文并没有提供一个TLS的深度教程，而是提供了两个Go应用TLS的简单例子，用来演示使用Go语言快速开发安全网络传输的程序。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转]Java 8：StampedLock，ReadWriteLock以及synchronized的比较]]></title>
    <link href="http://colobu.com/2016/06/01/Java-8-StampedLocks-vs-ReadWriteLocks-and-Synchronized/"/>
    <id>http://colobu.com/2016/06/01/Java-8-StampedLocks-vs-ReadWriteLocks-and-Synchronized/</id>
    <published>2016-06-01T01:55:46.000Z</published>
    <updated>2016-06-21T08:57:04.000Z</updated>
    <content type="html"><![CDATA[<p>原文出处：<a href="http://blog.takipi.com/java-8-stampedlocks-vs-readwritelocks-and-synchronized/" target="_blank" rel="external">Tal Weiss</a>, 译文出处: <a href="http://it.deepinmind.com/%E5%B9%B6%E5%8F%91/2014/06/06/java-8-stampedlocks-vs-readwritelocks-and-synchronized.html" target="_blank" rel="external">有孚</a></p>
<p>同步区域有点像拜访你的公公婆婆。你当然是希望待的时间越短越好。说到锁的话情况也是一样的，你希望获取锁以及进入临界区域的时间越短越好，这样才不会造成瓶颈。</p>
<p>synchronized关键字是语言层面的加锁机制，它可以用于方法以及代码块。这个关键字是由HotSpot JVM来实现的。我们在代码中分配的每一个对象，比如String, Array或者一个JSON文档，在GC的层面的对象头部，都内建了一个加锁的机制。JIT编译器也是类似的，它在进行字节码的编译和反编译的时候，都取决于特定的某个锁的具体的状态和竞争级别。</p>
<p>同步块的一个问题在于——进入临界区域内的线程不能超过一个。这对生产者消费者场景是一个很大的打击，尽管这里有些线程会尝试进行独占式的数据编辑，而另外一些线程只是希望读取一下数据，这个是可以和别的线程同时进行的。</p>
<p>读写锁（<a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html" target="_blank" rel="external">ReadWriteLock</a>）是一个理想的解决方案。你可以指定哪些线程会阻塞别的操作（写线程），哪些线程可以和别人共同进行内容的消费（读线程）。一个美满的结局？恐怕不是。</p>
<p>读写锁不像同步块，它并不是JVM中内建支持的，它只不过是段普通的代码。同样的，要想实现锁机制，它得引导CPU原子地或者按某个特定的顺序来执行某些特定的操作，以避免竞争条件。这通常都是通过JVM预留的一个后门来实现的——<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/sun/misc/Unsafe.java" target="_blank" rel="external">unsafe</a>类。读写锁使用的是CAS操作来将值直接<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/java/util/concurrent/locks/AbstractQueuedSynchronizer.java#AbstractQueuedSynchronizer.compareAndSetState%28int%2Cint%29" target="_blank" rel="external">设置</a>到内存中去，这是它们线程排队算法中的一部分。</p>
<p>尽管这样，读写锁也还不够快，有时候甚至会表现得<a href="http://blog.takipi.com/2014/04/16/java-8-longadders-the-fastest-way-to-add-numbers-concurrently/" target="_blank" rel="external">非常慢</a>，慢到你压根儿就不应该使用它。然而JDK的这帮家伙们没有放弃治疗，现在他们带来了一个全新的<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/concurrent/locks/StampedLock.java#StampedLock" target="_blank" rel="external">StampedLock</a>。这个读写锁使用了一组新的算法以及Java 8 JDK中引入的<a href="http://openjdk.java.net/jeps/171" target="_blank" rel="external">内存屏障</a>的特性，这使得这个锁更高效也更健壮。</p>
<p>它兑现了自己的诺言了吗？让我们拭目以待。</p>
<a id="more"></a>
<h3 id="使用锁">使用锁</h3>
<p>StampedLock的用法 更为复杂。它使用了一个戳（stamp)的概念，这是一个long值，它用作加锁解锁操作的一个标签。这意味着想要解锁一个操作你得将它对应的戳给传递进去。如果你传入的戳是错误的，那么可能会抛出一个异常，或者更糟糕的是，无法预知的行为。</p>
<p>另外一个值得关注的重要问题是，StampedLock并不像ReadWriteLock，它不是可重入的。因此它虽然更快，但也有一个坏处是线程可能会自己产生死锁。在实践中，这意味着你应该始终确保锁以及对应的戳不要逃逸出所在的代码块。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> stamp = lock.writeLock();  <span class="comment">//blocking lock, returns a stamp</span></div><div class="line"><span class="keyword">try</span> {</div><div class="line">  write(stamp); <span class="comment">// this is a bad move, you’re letting the stamp escape</span></div><div class="line">} </div><div class="line"><span class="keyword">finally</span> {</div><div class="line">  lock.unlock(stamp);<span class="comment">// release the lock in the same block - way better</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个设计还有个让人无法忍受的地方是这个long类型的戳对你而言没有任何意义。我还是希望锁操作能返回一个描述这个戳的对象——包括它的类型，锁的时间，owner线程，等等。这让调试和跟踪日志变得更简单。不过这么做很有可能是故意的，以便阻止开发人员不要将这个戳在代码里传来传去，同时也减少了分配对象的开销。</p>
<h3 id="乐观锁">乐观锁</h3>
<p>这个锁最重要的一个新功能就是它的乐观锁模式。研究和实践表明，读操作占了绝大数，并且很少和写操作竞争 。因此，使用一个成熟的读锁有点浪费。更好的方式是直接去读，结束之后再看一下这段时间内这个值有没有被改动过。如果有的话，你再进行重试，或者升级成一个更重的锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> stamp = lock.tryOptimisticRead(); <span class="comment">// non blocking</span></div><div class="line">read();</div><div class="line"><span class="keyword">if</span>(!lock.validate(stamp)){ <span class="comment">// if a write occurred, try again with a read lock</span></div><div class="line">  <span class="keyword">long</span> stamp = lock.readLock();</div><div class="line">  <span class="keyword">try</span> {</div><div class="line">    read();</div><div class="line">  }</div><div class="line">  <span class="keyword">finally</span> {</div><div class="line">    lock.unlock(stamp);</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用锁最大的麻烦在于，它在生产环境的实际表现取决于应用的状态。这意味着你不能凭空选择使用何种锁，而是得将代码执行的具体环境也考虑进来 。</p>
<p>并发的读写线程数会影响到你具体使用哪种锁——同步区还是读写锁。如果这些线程数在JVM的执行生命周期内发生改变的话，这个问题就更棘手了，这取决于应用的状态以及线程的竞争级别。</p>
<p>为了能说明这点，我对四种模式下的锁进行了压测——synchronized，读写锁，StampedLock的读写锁，以及读写乐观锁，分别使用了不同的竞争级别以及不同读写线程数的组合。读线程会去消费一个计数器的值，而写线程会将它从0增加到1M。</p>
<h3 id="5个读线程，5个写线程">5个读线程，5个写线程</h3>
<p>5个读写线程分别在并发地执行，可以看到StampedLock明显胜出了，它的性能要比synchronized高出3倍。读写锁的性能也不错。奇怪的是，乐观锁，表面看起来应该是最快的，实际上这里却是最慢的。<br><img src="04.png" alt=""></p>
<h3 id="10个读线程，10个写线程">10个读线程，10个写线程</h3>
<p>下面，我将竞争级别提高到10个写线程和10个读线程。现在情况开始发生变化了。读写锁要比StampedLock以及synchronized<strong>慢了一个数量级</strong>。说到乐观锁还是很让人意外，它比StampedLock的读写锁还要慢。<br><img src="01.png" alt=""></p>
<h3 id="16个读线程，4个写线程">16个读线程，4个写线程</h3>
<p>下面，我保持同样的竞争级别，不过将读线程的比重调整了下：16个读，4个写。读写锁再说次说明了为什么它要被替换掉了——它<strong>慢了百倍以上</strong>。Stamped以及乐观锁都表现得不错，synchronized也紧随其后。<br><img src="02.png" alt=""></p>
<h3 id="19个读，1个写">19个读，1个写</h3>
<p>最后，我只留了一个写线程，剩下19个全是读。注意到结果更慢了，因为单个线程完成任务的时间会更长。这里的结果非常有意思。读定锁看起来像是完成不了了。StampedLock的话也不太理想——乐观锁在这里明显胜出，百倍于读写锁。需要记住的是这个模式下它可能会失败，因为写操作可能会在你读的时候出现。synchronized，我们忠实的老伙伴，依旧保持着很稳定的表现。</p>
<p><img src="03.png" alt=""></p>
<p>完整的结果可以在<a href="https://docs.google.com/spreadsheets/d/1ro6rLZCoGoTvtITLOHf7nGaI3kK6iNWduQaQz0AOggc/edit#gid=310836513" target="_blank" rel="external">这里</a>下载。硬件：Macbook Pro i7</p>
<p>测试代码见<a href="https://www.google.com/url?q=https%3A%2F%2Fgithub.com%2Ftakipi%2Fcounters-benchmark&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNHYM0s5o4bLoZznXrREiUSuR2Nb_g" target="_blank" rel="external">这里</a>。</p>
<h3 id="结论">结论</h3>
<p>看起来平均表现最佳的还是内部实现的synchronized锁。尽管如此，并不是说它在所有情况下都是表现得最好的。主要是想告诉你，采用哪种锁，应该在你的代码上线前在不同的竞争级别下，并且使用不同的读写线程数来进行详细的测试，根据结果来选择。否则你会面临线上故障的<a href="http://www.veritasstrength.com/Websites/veritasstrength/images/Peter_Griffin_in_Pain.jpg" target="_blank" rel="external">风险</a>。</p>
<p>更多的关于StampedLock的资料见<a href="http://javaspecialists.eu/talks/jfokus13/PhaserAndStampedLock.pdf" target="_blank" rel="external">这里</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文出处：<a href="http://blog.takipi.com/java-8-stampedlocks-vs-readwritelocks-and-synchronized/" target="_blank" rel="external">Tal Weiss</a>, 译文出处: <a href="http://it.deepinmind.com/%E5%B9%B6%E5%8F%91/2014/06/06/java-8-stampedlocks-vs-readwritelocks-and-synchronized.html" target="_blank" rel="external">有孚</a></p>
<p>同步区域有点像拜访你的公公婆婆。你当然是希望待的时间越短越好。说到锁的话情况也是一样的，你希望获取锁以及进入临界区域的时间越短越好，这样才不会造成瓶颈。</p>
<p>synchronized关键字是语言层面的加锁机制，它可以用于方法以及代码块。这个关键字是由HotSpot JVM来实现的。我们在代码中分配的每一个对象，比如String, Array或者一个JSON文档，在GC的层面的对象头部，都内建了一个加锁的机制。JIT编译器也是类似的，它在进行字节码的编译和反编译的时候，都取决于特定的某个锁的具体的状态和竞争级别。</p>
<p>同步块的一个问题在于——进入临界区域内的线程不能超过一个。这对生产者消费者场景是一个很大的打击，尽管这里有些线程会尝试进行独占式的数据编辑，而另外一些线程只是希望读取一下数据，这个是可以和别的线程同时进行的。</p>
<p>读写锁（<a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html" target="_blank" rel="external">ReadWriteLock</a>）是一个理想的解决方案。你可以指定哪些线程会阻塞别的操作（写线程），哪些线程可以和别人共同进行内容的消费（读线程）。一个美满的结局？恐怕不是。</p>
<p>读写锁不像同步块，它并不是JVM中内建支持的，它只不过是段普通的代码。同样的，要想实现锁机制，它得引导CPU原子地或者按某个特定的顺序来执行某些特定的操作，以避免竞争条件。这通常都是通过JVM预留的一个后门来实现的——<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/sun/misc/Unsafe.java" target="_blank" rel="external">unsafe</a>类。读写锁使用的是CAS操作来将值直接<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/java/util/concurrent/locks/AbstractQueuedSynchronizer.java#AbstractQueuedSynchronizer.compareAndSetState%28int%2Cint%29" target="_blank" rel="external">设置</a>到内存中去，这是它们线程排队算法中的一部分。</p>
<p>尽管这样，读写锁也还不够快，有时候甚至会表现得<a href="http://blog.takipi.com/2014/04/16/java-8-longadders-the-fastest-way-to-add-numbers-concurrently/" target="_blank" rel="external">非常慢</a>，慢到你压根儿就不应该使用它。然而JDK的这帮家伙们没有放弃治疗，现在他们带来了一个全新的<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/concurrent/locks/StampedLock.java#StampedLock" target="_blank" rel="external">StampedLock</a>。这个读写锁使用了一组新的算法以及Java 8 JDK中引入的<a href="http://openjdk.java.net/jeps/171" target="_blank" rel="external">内存屏障</a>的特性，这使得这个锁更高效也更健壮。</p>
<p>它兑现了自己的诺言了吗？让我们拭目以待。</p>
]]>
    
    </summary>
    
      <category term="StampedLock" scheme="http://colobu.com/tags/StampedLock/"/>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RPCX: 一个用Go实现的类似Dubbo的分布式RPC框架]]></title>
    <link href="http://colobu.com/2016/05/26/RPCX-a-distributed-rpc-dubbo-like-framework-by-Go/"/>
    <id>http://colobu.com/2016/05/26/RPCX-a-distributed-rpc-dubbo-like-framework-by-Go/</id>
    <published>2016-05-26T08:24:58.000Z</published>
    <updated>2016-06-21T08:57:04.000Z</updated>
    <content type="html"><![CDATA[<p>rpcx是一个类似阿里巴巴 <a href="http://dubbo.io/" target="_blank" rel="external">Dubbo</a> 和微博 <a href="https://github.com/weibocom/motan" target="_blank" rel="external">Motan</a> 的分布式的RPC服务框架，基于Golang net/rpc实现。 </p>
<p>谈起分布式的RPC框架，比较出名的是阿里巴巴的dubbo,包括由当当网维护的dubbox。<br>不知道dubbo在阿里的内部竞争中败给了HSF，还是阿里有意将其闭源了，官方的代码使用的spring还停留在2.5.6.SEC03的版本，dubbox的spring也只升级到3.2.9.RELEASE。<br>不管怎样，dubbo还是在电商企业得到广泛的应用，京东也有部分在使用dubbo开发。</p>
<blockquote>
<p>DUBBO是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，是阿里巴巴SOA服务化治理方案的核心框架，每天为2,000+个服务提供3,000,000,000+次访问量支持，并被广泛应用于阿里巴巴集团的各成员站点。<br>微博的RPC框架 Motan 也正式开源了，如张雷所说：</p>
<p>2013 年微博 RPC 框架 Motan 在前辈大师们（福林、fishermen、小麦、王喆等）的精心设计和辛勤工作中诞生，向各位大师们致敬，也得到了微博各个技术团队的鼎力支持及不断完善，如今 Motan 在微博平台中已经广泛应用，每天为数百个服务完成近千亿次的调用。</p>
</blockquote>
<p>这两个个优秀的框架都是使用Java开发的，国外的互联网企业也有非常出名的的RPC框架如<a href="https://thrift.apache.org/" target="_blank" rel="external">thrift</a>、<a href="https://github.com/twitter/finagle" target="_blank" rel="external">finagle</a>。</p>
<p>本项目<a href="https://github.com/smallnest/rpcx" target="_blank" rel="external">rpcx</a>的目标就是实现一个Go生态圈的Dubbo，为Go生态圈提供一个分布式的、多插件的、带有服务治理功能的产品级的RPC框架。</p>
<p>Go生态圈已经有一些RPC库，如官方的<a href="https://golang.org/pkg/net/rpc/" target="_blank" rel="external">net/rpc</a>、<a href="https://github.com/grpc/grpc-go" target="_blank" rel="external">grpc-go</a>、<a href="http://www.gorillatoolkit.org/pkg/rpc" target="_blank" rel="external">gorilla-rpc</a>等，为什么还要开发<strong>rpcx</strong>呢？</p>
<p>原因在于尽管这些框架都是为Go实现的RPC库，但是它们的功能比较单一，只是实现了点对点(End-to-End)的通讯框架。缺乏服务治理的功能，比如服务注册和发现、<br>负载均衡、容灾、服务监控等功能。因此我基于Go net/rpc框架实现了一个类似Dubbo的分布式框架。</p>
<p>和rpcx比较类似的Go RPC框架是<a href="https://github.com/micro/go-micro" target="_blank" rel="external">go-micro</a>，但是rpcx提供了更丰富的功能，基于TCP的通讯协议性能更好。</p>
<a id="more"></a>
<h2 id="RPC是什么">RPC是什么</h2>
<p>远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用，例：Java RMI。<br>简单地说就是能使应用像调用本地方法一样的调用远程的过程或服务。很显然，这是一种client-server的交互形式，调用者(caller)是client,执行者(executor)是server。典型的实现方式就是request–response通讯机制。</p>
<p>RPC 是进程之间的通讯方式(inter-process communication, IPC), 不同的进程有不同的地址空间。<br>如果client和server在同一台机器上，尽管物理地址空间是相同的，但是虚拟地址空间不同。<br>如果它们在不同的主机上，物理地址空间也不同。</p>
<p>RPC的实现的技术各不相同，也不一定兼容。</p>
<p>一个正常的RPC过程可以分成下面几步：</p>
<ol>
<li>client调用client stub，这是一次本地过程调用</li>
<li>client stub将参数打包成一个消息，然后发送这个消息。打包过程也叫做 marshalling</li>
<li>client所在的系统将消息发送给server</li>
<li>server的的系统将收到的包传给server stub</li>
<li>server stub解包得到参数。 解包也被称作 unmarshalling</li>
<li>最后server stub调用服务过程. 返回结果按照相反的步骤传给client</li>
</ol>
<p>RPC只是描绘了 Client 与 Server 之间的点对点调用流程，包括 stub、通信、RPC 消息解析等部分，在实际应用中，还需要考虑服务的高可用、负载均衡等问题，所以产品级的 RPC 框架除了点对点的 RPC 协议的具体实现外，还应包括服务的发现与注销、提供服务的多台 Server 的负载均衡、服务的高可用等更多的功能。<br>目前的 RPC 框架大致有两种不同的侧重方向，一种偏重于服务治理，另一种偏重于跨语言调用。</p>
<p>服务治理型的 RPC 框架有 Dubbo、DubboX、Motan 等，这类的 RPC 框架的特点是功能丰富，提供高性能的远程调用以及服务发现及治理功能，适用于大型服务的微服务化拆分以及管理，对于特定语言（Java）的项目可以十分友好的透明化接入。但缺点是语言耦合度较高，跨语言支持难度较大。</p>
<p>跨语言调用型的 RPC 框架有 Thrift、gRPC、Hessian、Hprose 等，这一类的 RPC 框架重点关注于服务的跨语言调用，能够支持大部分的语言进行语言无关的调用，非常适合于为不同语言提供通用远程服务的场景。但这类框架没有服务发现相关机制，实际使用时一般需要代理层进行请求转发和负载均衡策略控制。</p>
<p>本项目 rpcx 属于服务治理类型，是一个基于 Go 开发的高性能的轻量级 RPC 框架，Motan 提供了实用的服务治理功能和基于插件的扩展能力。</p>
<h2 id="RPCX的特点">RPCX的特点</h2>
<p>rpcx使用Go实现，适合使用Go语言实现RPC的功能。</p>
<ul>
<li>基于net/rpc,可以将net/rpc实现的RPC项目轻松的转换为分布式的RPC</li>
<li>插件式设计，可以配置所需的插件，比如服务发现、日志、统计分析等</li>
<li>基于TCP长连接,只需很小的额外的消息头</li>
<li>支持多种编解码协议，如Gob、Json、MessagePack、gencode、ProtoBuf等</li>
<li>服务发现：服务发布、订阅、通知等，支持多种发现方式如ZooKeeper、Etcd等</li>
<li>高可用策略：失败重试（Failover）、快速失败（Failfast）</li>
<li>负载均衡：支持随机请求、轮询、低并发优先、一致性 Hash等</li>
<li>规模可扩展，可以根据性能的需求增减服务器</li>
<li>其他：调用统计、访问日志等</li>
</ul>
<p>rpcx目标是轻量级的，小而简单，但是期望所有的功能都可以通过插件的方式搭积木的方式完成。</p>
<h2 id="RPCX架构">RPCX架构</h2>
<p>rpcx中有服务提供者 RPC Server，服务调用者 RPC Client 和服务注册中心 Registry 三个角色。</p>
<ul>
<li>Server 向 Registry 注册服务，并向注册中心发送心跳汇报状态(基于不同的registry有不同的实现)。</li>
<li>Client 需要向注册中心查询 RPC 服务者列表，Client 根据 Registry 返回的服务者列表，选取其中一个 Sever 进行 RPC 调用。</li>
<li>当 Server 发生宕机时，Registry 会监测到服务者不可用(zookeeper session机制或者手工心跳)，Client 感知后会对本地的服务列表作相应调整。client可能被动感知(zookeeper)或者主动定时拉取。</li>
<li>可选地，Server可以定期向Registry汇报调用统计信息，Client可以根据调用次数选择压力最小的Server</li>
</ul>
<p><img src="component.png" alt=""></p>
<p>当前rpcx支持zookeeper, etcd等注册中心，Consul注册中心正在开发中。</p>
<p>rpcx基于Go net/rpc的底层实现， Client和Server之间通讯是通过TCP进行通讯的，它们之间通过Client发送Request，Server返回Response实现。<br>Request和Response消息的格式都是<code>Header+Body</code>的格式。Header和Body具体的格式根据编码方式的不同而不同，可以是二进制，也可以是结构化数据如JSON。</p>
<h2 id="RPCX的特性">RPCX的特性</h2>
<p>rpcx拥有众多特性。</p>
<h3 id="服务器特性">服务器特性</h3>
<h4 id="编码_(序列化)">编码 (序列化)</h4>
<p>rpcx当前支持多种序列化/反序列化的方式，可以根据需求选择合适的编码库。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://golang.org/pkg/encoding/gob/" target="_blank" rel="external">gob</a></td>
<td>官方提供的序列化方式，基于一个包含元数据的流</td>
</tr>
<tr>
<td><a href="https://golang.org/pkg/net/rpc/jsonrpc/" target="_blank" rel="external">jsonrpc</a></td>
<td>也是官方提供的编码库，以JSON格式传输</td>
</tr>
<tr>
<td><a href="http://msgpack.org/" target="_blank" rel="external">msgp</a></td>
<td>类似json格式的编码，但是更小更快，可以直接编码struct</td>
</tr>
<tr>
<td><a href="https://github.com/andyleap/gencode" target="_blank" rel="external">gencode</a></td>
<td>一个超级快的序列化库，需要定义schema,但是定义方式和struct类似</td>
</tr>
<tr>
<td><a href="https://github.com/google/protobuf" target="_blank" rel="external">protobuf</a></td>
<td>Google推出的广受关注的序列化库，推荐使用<a href="https://github.com/gogo/protobuf" target="_blank" rel="external">gogo-protobuf</a>，可以获得更高的性能</td>
</tr>
</tbody>
</table>
<p>在数据结构简单的情况下，这几种库都可以满足需求，参照本文中的benchmark测试。但是如果追求性能，建议采用后面三种序列化库。</p>
<p>序列化库的选择对于RPC服务的影响是巨大的，我创建了另外一个项目专门比较各序列化库的性能： <a href="https://github.com/smallnest/gosercomp" target="_blank" rel="external">gosercomp</a>。</p>
<p>新的序列化库的实现也非常简单，只需实现下面两个方法即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> NewXXXXXServerCodec(conn io.ReadWriteCloser) rpc.ServerCodec {</div><div class="line">    ……</div><div class="line">}</div><div class="line"><span class="keyword">func</span> NewXXXXXClientCodec(conn io.ReadWriteCloser) rpc.ClientCodec {</div><div class="line">    ……</div><div class="line">}</div></pre></td></tr></table></figure>

<p>编码库负责marshal/unmarshal Reuqest/Response， 包括消息中的Header和Body。<br>如果你想，你也可以对Header和Body实现不同的编码。</p>
<h4 id="注册中心">注册中心</h4>
<p>目前提供了两种注册中心:</p>
<ul>
<li><strong>ZooKeeperRegisterPlugin</strong><br>通过ZooKeeper实现服务发现。<br>服务在注册的时候会自动在ZooKeeper上创建一个Ephemeral节点，因此当服务宕机的时候此节点就被删除，Client也会感知到。<br>同时，Server也会把调用次数定时更新到ZooKeeper，这样Client可以根据一段时间的调用次数选择压力较小的服务器节点进行连接。</li>
</ul>
<p>注册中心的配置只需在服务器初始化的时候增加以下代码，服务的实现无需做任何的改动，也不需要额外的配置。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">plugin := &ZooKeeperRegisterPlugin{</div><div class="line">	ServiceAddress:   <span class="string">"tcp@127.0.0.1:1234"</span>,</div><div class="line">	ZooKeeperServers: []<span class="typename">string</span>{<span class="string">"127.0.0.1:2181"</span>},</div><div class="line">	BasePath:         <span class="string">"/betterrpc"</span>,</div><div class="line">	metrics:          metrics.NewRegistry(),</div><div class="line">	Services:         <span class="built_in">make</span>([]<span class="typename">string</span>,<span class="number"> 1</span>),</div><div class="line">	updateInterval:   time.Minute,</div><div class="line">}</div><div class="line">   server.PluginContainer.Add(plugin)</div></pre></td></tr></table></figure>

<p>其中ServiceAddress为本机(Server)要暴露给Client地址。因为ZooKeeper的节点名不支持&quot;/&quot;，<br>所以此处用&quot;@&quot;代替&quot;://&quot;。</p>
<p>ZooKeeperServers为ZK集群的地址。</p>
<p>BasePath为一个服务组，此组下的服务对于Client都是可见的。</p>
<ul>
<li><strong>EtcdRegisterPlugin</strong><br>通过etcd也可以实现服务发现。</li>
</ul>
<p>etcd可以通过TTL判断服务器的存活，另外此插件也会定时把调用次数定时更新到etcd。</p>
<p>此插件可以使用下面的代码配置：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">plugin := &EtcdRegisterPlugin{</div><div class="line">	ServiceAddress: <span class="string">"tcp@127.0.0.1:1234"</span>,</div><div class="line">	EtcdServers:    []<span class="typename">string</span>{<span class="string">"http://127.0.0.1:2379"</span>},</div><div class="line">	BasePath:       <span class="string">"/betterrpc"</span>,</div><div class="line">	metrics:        metrics.NewRegistry(),</div><div class="line">	Services:       <span class="built_in">make</span>([]<span class="typename">string</span>,<span class="number"> 1</span>),</div><div class="line">	updateInterval: time.Minute,</div><div class="line">}</div><div class="line">   server.PluginContainer.Add(plugin)</div></pre></td></tr></table></figure>

<p>注意注册中心插件必须在配置服务之前设置，否则注册中心无法获取要注册的服务信息。</p>
<h4 id="扩展点">扩展点</h4>
<p>当前rpcx为server提供了以下扩展点：</p>
<ul>
<li>服务注册时</li>
<li>Client连接时</li>
<li>读取Request Header的前后</li>
<li>读取Request Body的前后</li>
<li>返回Response的前后</li>
</ul>
<p>你可以根据这些扩展点编写自己的插件，只需实现相应的接口即可。<br>定义的接口你可以看godoc的IXXXXXXPlugin的定义。</p>
<p>上面介绍的注册中心就是通过插件的方式实现。同时rpcx还实现了其它的插件，如下面的介绍。</p>
<ul>
<li>LogRegisterPlugin: 记录服务注册日志</li>
<li>MetricsPlugin: 统计服务调用次数和处理时间</li>
<li>RateLimitingPlugin: 限流操作，限定服务器的TPS</li>
</ul>
<h3 id="客户端特性">客户端特性</h3>
<h4 id="负载均衡">负载均衡</h4>
<p>负载均衡是通过不同的ClientSelector来实现的。</p>
<table>
<thead>
<tr>
<th>负载均衡器</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>DirectClientSelector</td>
<td>点对点的直连，客户端直接连接一个服务器</td>
</tr>
<tr>
<td>MultiClientSelector</td>
<td>多对多的直连，一个客户端可以从一组固定的服务器中选择一个直连，无需注册中心</td>
</tr>
<tr>
<td>ZooKeeperClientSelector</td>
<td>从ZK注册中心选择一个服务器连接</td>
</tr>
<tr>
<td>EtcdClientSelector</td>
<td>从Etcd注册中心选择一个服务器连接</td>
</tr>
</tbody>
</table>
<p>一个Selector需要实现ClientSelector接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ClientSelector <span class="keyword">interface</span> {</div><div class="line">	Select(clientCodecFunc ClientCodecFunc) (*rpc.Client, error)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>Client的序列化方式必须和服务器的序列化方式保持一致。</p>
<h4 id="容错">容错</h4>
<p>Client提供了两种容错方式: <code>Failfast</code>、<code>Failover</code>、<code>Failtry</code>:</p>
<ul>
<li>Failfast: 如果Client调用失败，立即返回，不会重试</li>
<li>Failover: 如果Client调用失败，会尝试从服务列表中选择另外一个服务器调用，直到成功或者到达重试次数</li>
<li>Failtry： 如果Client调用失败，会继续这个服务器重试，直到成功或者到达重试次数</li>
</ul>
<h4 id="重选算法">重选算法</h4>
<p>对于多个服务器，重选发送支持：</p>
<ul>
<li>随机选择： 随机选择一个服务器并返回，可能和上一次的重复</li>
<li>RoundRobin: 按顺序选择一个服务器</li>
<li>一致性哈希 [TODO]:使用<a href="https://arxiv.org/ftp/arxiv/papers/1406/1406.2294.pdf" target="_blank" rel="external">Jump Consistent Hash algorithm</a></li>
<li>CallLeast [TODO]: 根据调用次数选择压力最小的服务器</li>
</ul>
<h4 id="扩展点-1">扩展点</h4>
<p>Client的扩展点如下：</p>
<ul>
<li>读取Response Header的前后</li>
<li>读取Response Body的前后</li>
<li>写Request的前后</li>
</ul>
<h2 id="RPCX例子">RPCX例子</h2>
<h3 id="点对点">点对点</h3>
<p>点对点的实现和Go net/rpc的使用基本一致。</p>
<h4 id="Server">Server</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"github.com/smallnest/rpcx"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> {</div><div class="line">	A <span class="typename">int</span> <span class="string">`msg:"a"`</span></div><div class="line">	B <span class="typename">int</span> <span class="string">`msg:"b"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Reply <span class="keyword">struct</span> {</div><div class="line">	C <span class="typename">int</span> <span class="string">`msg:"c"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Arith <span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> (t *Arith) Mul(args *Args, reply *Reply) error {</div><div class="line">	reply.C = args.A * args.B</div><div class="line">	<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (t *Arith) Error(args *Args, reply *Reply) error {</div><div class="line">	<span class="built_in">panic</span>(<span class="string">"ERROR"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	server := rpcx.NewServer()</div><div class="line">	server.RegisterName(<span class="string">"Arith"</span>, <span class="built_in">new</span>(Arith))</div><div class="line">	server.Serve(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8972"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="Client">Client</h4>
<p>同步方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/smallnest/rpcx"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> {</div><div class="line">	A <span class="typename">int</span> <span class="string">`msg:"a"`</span></div><div class="line">	B <span class="typename">int</span> <span class="string">`msg:"b"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Reply <span class="keyword">struct</span> {</div><div class="line">	C <span class="typename">int</span> <span class="string">`msg:"c"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	s := &rpcx.DirectClientSelector{Network: <span class="string">"tcp"</span>, Address: <span class="string">"127.0.0.1:8972"</span>, Timeout:<span class="number"> 10</span> * time.Second}</div><div class="line">	client := rpcx.NewClient(s)</div><div class="line"></div><div class="line">	args := &Args<span class="number">{7</span>,<span class="number"> 8</span>}</div><div class="line">	<span class="keyword">var</span> reply Reply</div><div class="line">	err := client.Call(<span class="string">"Arith.Mul"</span>, args, &reply)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Printf(<span class="string">"error for Arith: %d*%d, %v \n"</span>, args.A, args.B, err)</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		fmt.Printf(<span class="string">"Arith: %d*%d=%d \n"</span>, args.A, args.B, reply.C)</div><div class="line">	}</div><div class="line"></div><div class="line">	client.Close()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>异步方式(通过Channel获得执行结果):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/smallnest/rpcx"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> {</div><div class="line">	A <span class="typename">int</span> <span class="string">`msg:"a"`</span></div><div class="line">	B <span class="typename">int</span> <span class="string">`msg:"b"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Reply <span class="keyword">struct</span> {</div><div class="line">	C <span class="typename">int</span> <span class="string">`msg:"c"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	s := &rpcx.DirectClientSelector{Network: <span class="string">"tcp"</span>, Address: <span class="string">"127.0.0.1:8972"</span>, Timeout:<span class="number"> 10</span> * time.Second}</div><div class="line">	client := rpcx.NewClient(s)</div><div class="line"></div><div class="line">	args := &Args<span class="number">{7</span>,<span class="number"> 8</span>}</div><div class="line">	<span class="keyword">var</span> reply Reply</div><div class="line">	divCall := client.Go(<span class="string">"Arith.Mul"</span>, args, &reply, <span class="constant">nil</span>)</div><div class="line">	replyCall := &lt;-divCall.Done <span class="comment">// will be equal to divCall</span></div><div class="line">	<span class="keyword">if</span> replyCall.Error != <span class="constant">nil</span> {</div><div class="line">		fmt.Printf(<span class="string">"error for Arith: %d*%d, %v \n"</span>, args.A, args.B, replyCall.Error)</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		fmt.Printf(<span class="string">"Arith: %d*%d=%d \n"</span>, args.A, args.B, reply.C)</div><div class="line">	}</div><div class="line"></div><div class="line">	client.Close()</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="多服务器">多服务器</h3>
<h4 id="Server-1">Server</h4>
<p>这里例子启动了两个服务器，其中一个服务器故意将 <code>7 * 8</code>计算成 <code>560</code>，以便和另外一个服务器进行区分，我们可以观察计算结果。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"github.com/smallnest/rpcx"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> {</div><div class="line">	A <span class="typename">int</span> <span class="string">`msg:"a"`</span></div><div class="line">	B <span class="typename">int</span> <span class="string">`msg:"b"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Reply <span class="keyword">struct</span> {</div><div class="line">	C <span class="typename">int</span> <span class="string">`msg:"c"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Arith <span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> (t *Arith) Mul(args *Args, reply *Reply) error {</div><div class="line">	reply.C = args.A * args.B</div><div class="line">	<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (t *Arith) Error(args *Args, reply *Reply) error {</div><div class="line">	<span class="built_in">panic</span>(<span class="string">"ERROR"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Arith2 <span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> (t *Arith2) Mul(args *Args, reply *Reply) error {</div><div class="line">	reply.C = args.A * args.B *<span class="number"> 10</span></div><div class="line">	<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (t *Arith2) Error(args *Args, reply *Reply) error {</div><div class="line">	<span class="built_in">panic</span>(<span class="string">"ERROR"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	server1 := rpcx.NewServer()</div><div class="line">	server1.RegisterName(<span class="string">"Arith"</span>, <span class="built_in">new</span>(Arith))</div><div class="line">	server1.Start(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8972"</span>)</div><div class="line"></div><div class="line">	server2 := rpcx.NewServer()</div><div class="line">	server2.RegisterName(<span class="string">"Arith"</span>, <span class="built_in">new</span>(Arith2))</div><div class="line">	server2.Serve(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8973"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="Client-1">Client</h4>
<p><strong>随机选取服务器的例子</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/smallnest/rpcx"</span></div><div class="line">	<span class="string">"github.com/smallnest/rpcx/clientselector"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> {</div><div class="line">	A <span class="typename">int</span> <span class="string">`msg:"a"`</span></div><div class="line">	B <span class="typename">int</span> <span class="string">`msg:"b"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Reply <span class="keyword">struct</span> {</div><div class="line">	C <span class="typename">int</span> <span class="string">`msg:"c"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	server1 := clientselector.ServerPair{Network: <span class="string">"tcp"</span>, Address: <span class="string">"127.0.0.1:8972"</span>}</div><div class="line">	server2 := clientselector.ServerPair{Network: <span class="string">"tcp"</span>, Address: <span class="string">"127.0.0.1:8973"</span>}</div><div class="line"></div><div class="line">	servers := []clientselector.ServerPair{server1, server2}</div><div class="line"></div><div class="line">	s := clientselector.NewMultiClientSelector(servers, rpcx.RandomSelect,<span class="number"> 10</span>*time.Second)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		callServer(s)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> callServer(s rpcx.ClientSelector) {</div><div class="line">	client := rpcx.NewClient(s)</div><div class="line"></div><div class="line">	args := &Args<span class="number">{7</span>,<span class="number"> 8</span>}</div><div class="line">	<span class="keyword">var</span> reply Reply</div><div class="line">	err := client.Call(<span class="string">"Arith.Mul"</span>, args, &reply)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Printf(<span class="string">"error for Arith: %d*%d, %v \n"</span>, args.A, args.B, err)</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		fmt.Printf(<span class="string">"Arith: %d*%d=%d \n"</span>, args.A, args.B, reply.C)</div><div class="line">	}</div><div class="line"></div><div class="line">	client.Close()</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>RoundRobin选取服务器的例子</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/smallnest/rpcx"</span></div><div class="line">	<span class="string">"github.com/smallnest/rpcx/clientselector"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> {</div><div class="line">	A <span class="typename">int</span> <span class="string">`msg:"a"`</span></div><div class="line">	B <span class="typename">int</span> <span class="string">`msg:"b"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Reply <span class="keyword">struct</span> {</div><div class="line">	C <span class="typename">int</span> <span class="string">`msg:"c"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	server1 := clientselector.ServerPair{Network: <span class="string">"tcp"</span>, Address: <span class="string">"127.0.0.1:8972"</span>}</div><div class="line">	server2 := clientselector.ServerPair{Network: <span class="string">"tcp"</span>, Address: <span class="string">"127.0.0.1:8973"</span>}</div><div class="line"></div><div class="line">	servers := []clientselector.ServerPair{server1, server2}</div><div class="line"></div><div class="line">	s := clientselector.NewMultiClientSelector(servers, rpcx.RoundRobin,<span class="number"> 10</span>*time.Second)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		callServer(s)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> callServer(s rpcx.ClientSelector) {</div><div class="line">	client := rpcx.NewClient(s)</div><div class="line">	args := &Args<span class="number">{7</span>,<span class="number"> 8</span>}</div><div class="line">	<span class="keyword">var</span> reply Reply</div><div class="line">	err := client.Call(<span class="string">"Arith.Mul"</span>, args, &reply)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Printf(<span class="string">"error for Arith: %d*%d, %v \n"</span>, args.A, args.B, err)</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		fmt.Printf(<span class="string">"Arith: %d*%d=%d \n"</span>, args.A, args.B, reply.C)</div><div class="line">	}</div><div class="line"></div><div class="line">	client.Close()</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>Failover</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/smallnest/rpcx"</span></div><div class="line">	<span class="string">"github.com/smallnest/rpcx/clientselector"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> {</div><div class="line">	A <span class="typename">int</span> <span class="string">`msg:"a"`</span></div><div class="line">	B <span class="typename">int</span> <span class="string">`msg:"b"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Reply <span class="keyword">struct</span> {</div><div class="line">	C <span class="typename">int</span> <span class="string">`msg:"c"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	server1 := clientselector.ServerPair{Network: <span class="string">"tcp"</span>, Address: <span class="string">"127.0.0.1:8972"</span>}</div><div class="line">	server2 := clientselector.ServerPair{Network: <span class="string">"tcp"</span>, Address: <span class="string">"127.0.0.1:8973"</span>}</div><div class="line">	server3 := clientselector.ServerPair{Network: <span class="string">"tcp"</span>, Address: <span class="string">"127.0.0.1:8974"</span>}</div><div class="line"></div><div class="line">	servers := []clientselector.ServerPair{server1, server2, server3}</div><div class="line"></div><div class="line">	s := clientselector.NewMultiClientSelector(servers, rpcx.RoundRobin,<span class="number"> 10</span>*time.Second)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		callServer(s)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> callServer(s rpcx.ClientSelector) {</div><div class="line">	client := rpcx.NewClient(s)</div><div class="line">	client.FailMode = rpcx.Failover</div><div class="line">	args := &Args<span class="number">{7</span>,<span class="number"> 8</span>}</div><div class="line">	<span class="keyword">var</span> reply Reply</div><div class="line">	err := client.Call(<span class="string">"Arith.Mul"</span>, args, &reply)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Printf(<span class="string">"error for Arith: %d*%d, %v \n"</span>, args.A, args.B, err)</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		fmt.Printf(<span class="string">"Arith: %d*%d=%d \n"</span>, args.A, args.B, reply.C)</div><div class="line">	}</div><div class="line"></div><div class="line">	client.Close()</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Benchmark">Benchmark</h2>
<p>rpcx基于Go net/rpc框架实现，它的插件机制并不会带来多少性能的损失，如下面的测试，rpcx性能和官方的Go net/rpc持平。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[root<span class="variable">@localhost</span> rpcx]<span class="comment"># go test -bench . -test.benchmem</span></div><div class="line"><span class="constant">PASS</span></div><div class="line"><span class="constant">BenchmarkNetRPC_gob</span>-<span class="number">16</span>            <span class="number">100000</span>             <span class="number">18742</span> ns/op             <span class="number">321</span> <span class="constant">B</span>/op          <span class="number">9</span> allocs/op</div><div class="line"><span class="constant">BenchmarkNetRPC_jsonrpc</span>-<span class="number">16</span>        <span class="number">100000</span>             <span class="number">21360</span> ns/op            <span class="number">1170</span> <span class="constant">B</span>/op         <span class="number">31</span> allocs/op</div><div class="line"><span class="constant">BenchmarkNetRPC_msgp</span>-<span class="number">16</span>           <span class="number">100000</span>             <span class="number">18617</span> ns/op             <span class="number">776</span> <span class="constant">B</span>/op         <span class="number">35</span> allocs/op</div><div class="line"><span class="constant">BenchmarkRPCX_gob</span>-<span class="number">16</span>              <span class="number">100000</span>             <span class="number">18718</span> ns/op             <span class="number">320</span> <span class="constant">B</span>/op          <span class="number">9</span> allocs/op</div><div class="line"><span class="constant">BenchmarkRPCX_json</span>-<span class="number">16</span>             <span class="number">100000</span>             <span class="number">21238</span> ns/op            <span class="number">1170</span> <span class="constant">B</span>/op         <span class="number">31</span> allocs/op</div><div class="line"><span class="constant">BenchmarkRPCX_msgp</span>-<span class="number">16</span>             <span class="number">100000</span>             <span class="number">18635</span> ns/op             <span class="number">776</span> <span class="constant">B</span>/op         <span class="number">35</span> allocs/op</div><div class="line"><span class="constant">BenchmarkRPCX_gencodec</span>-<span class="number">16</span>         <span class="number">100000</span>             <span class="number">18454</span> ns/op            <span class="number">4485</span> <span class="constant">B</span>/op         <span class="number">17</span> allocs/op</div><div class="line"><span class="constant">BenchmarkRPCX_protobuf</span>-<span class="number">16</span>         <span class="number">100000</span>             <span class="number">17234</span> ns/op             <span class="number">733</span> <span class="constant">B</span>/op         <span class="number">13</span> allocs/op</div></pre></td></tr></table></figure>

<h2 id="参考文档">参考文档</h2>
<ol>
<li><a href="https://www.zhihu.com/question/25536695" target="_blank" rel="external">谁能用通俗的语言解释一下什么是RPC框架？</a></li>
<li><a href="http://dubbo.io/" target="_blank" rel="external">DUBBO</a></li>
<li><a href="http://weibo.com/ttarticle/p/show?id=2309403951077522312320" target="_blank" rel="external">支撑微博千亿调用的轻量级RPC框架：Motan</a></li>
<li><a href="http://blog.jobbole.com/92290/" target="_blank" rel="external">你应该知道的 RPC 原理</a></li>
<li><a href="http://www.infoq.com/cn/news/2014/05/twitter-finagle-intro" target="_blank" rel="external">Twitter的RPC框架Finagle简介</a></li>
<li><a href="https://github.com/line/armeria" target="_blank" rel="external">armeria: Netty的作者正在开发的一个RPC库</a></li>
<li><a href="https://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank" rel="external">wikipedia RPC</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>rpcx是一个类似阿里巴巴 <a href="http://dubbo.io/" target="_blank" rel="external">Dubbo</a> 和微博 <a href="https://github.com/weibocom/motan" target="_blank" rel="external">Motan</a> 的分布式的RPC服务框架，基于Golang net/rpc实现。 </p>
<p>谈起分布式的RPC框架，比较出名的是阿里巴巴的dubbo,包括由当当网维护的dubbox。<br>不知道dubbo在阿里的内部竞争中败给了HSF，还是阿里有意将其闭源了，官方的代码使用的spring还停留在2.5.6.SEC03的版本，dubbox的spring也只升级到3.2.9.RELEASE。<br>不管怎样，dubbo还是在电商企业得到广泛的应用，京东也有部分在使用dubbo开发。</p>
<blockquote>
<p>DUBBO是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，是阿里巴巴SOA服务化治理方案的核心框架，每天为2,000+个服务提供3,000,000,000+次访问量支持，并被广泛应用于阿里巴巴集团的各成员站点。<br>微博的RPC框架 Motan 也正式开源了，如张雷所说：</p>
<p>2013 年微博 RPC 框架 Motan 在前辈大师们（福林、fishermen、小麦、王喆等）的精心设计和辛勤工作中诞生，向各位大师们致敬，也得到了微博各个技术团队的鼎力支持及不断完善，如今 Motan 在微博平台中已经广泛应用，每天为数百个服务完成近千亿次的调用。</p>
</blockquote>
<p>这两个个优秀的框架都是使用Java开发的，国外的互联网企业也有非常出名的的RPC框架如<a href="https://thrift.apache.org/" target="_blank" rel="external">thrift</a>、<a href="https://github.com/twitter/finagle" target="_blank" rel="external">finagle</a>。</p>
<p>本项目<a href="https://github.com/smallnest/rpcx" target="_blank" rel="external">rpcx</a>的目标就是实现一个Go生态圈的Dubbo，为Go生态圈提供一个分布式的、多插件的、带有服务治理功能的产品级的RPC框架。</p>
<p>Go生态圈已经有一些RPC库，如官方的<a href="https://golang.org/pkg/net/rpc/" target="_blank" rel="external">net/rpc</a>、<a href="https://github.com/grpc/grpc-go" target="_blank" rel="external">grpc-go</a>、<a href="http://www.gorillatoolkit.org/pkg/rpc" target="_blank" rel="external">gorilla-rpc</a>等，为什么还要开发<strong>rpcx</strong>呢？</p>
<p>原因在于尽管这些框架都是为Go实现的RPC库，但是它们的功能比较单一，只是实现了点对点(End-to-End)的通讯框架。缺乏服务治理的功能，比如服务注册和发现、<br>负载均衡、容灾、服务监控等功能。因此我基于Go net/rpc框架实现了一个类似Dubbo的分布式框架。</p>
<p>和rpcx比较类似的Go RPC框架是<a href="https://github.com/micro/go-micro" target="_blank" rel="external">go-micro</a>，但是rpcx提供了更丰富的功能，基于TCP的通讯协议性能更好。</p>
]]>
    
    </summary>
    
      <category term="RPC" scheme="http://colobu.com/tags/RPC/"/>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Scala DSL教程: 实现一个web框架路由器]]></title>
    <link href="http://colobu.com/2016/05/24/scala-dsl-tutorial-writing-web-framework-router/"/>
    <id>http://colobu.com/2016/05/24/scala-dsl-tutorial-writing-web-framework-router/</id>
    <published>2016-05-24T04:44:11.000Z</published>
    <updated>2016-06-21T08:57:05.000Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="http://codetunes.com/2012/scala-dsl-tutorial-writing-web-framework-router/" target="_blank" rel="external">Scala DSL tutorial - writing a web framework router</a>, 作者: Tymon Tobolski </p>
<p><strong>译者按:</strong><br>Scala非常适合实现DSL(<a href="https://en.wikipedia.org/wiki/Domain-specific_language" target="_blank" rel="external">Domain-specific language</a>)。我在使用Scala的过程中印象深刻的是<a href="http://www.scalatest.org/" target="_blank" rel="external">scalatest</a>和<a href="http://spray.io/documentation/1.2.3/spray-routing/" target="_blank" rel="external">spray-routing</a>,</p>
<p>比如scalatest的测试代码的编写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> collection.mutable.Stack</div><div class="line"><span class="keyword">import</span> org.scalatest._</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleSpec</span> <span class="keyword">extends</span> <span class="title">FlatSpec</span> <span class="keyword">with</span> <span class="title">Matchers</span> </span>{</div><div class="line"></div><div class="line">  <span class="string">"A Stack"</span> should <span class="string">"pop values in last-in-first-out order"</span> in {</div><div class="line">    <span class="keyword">val</span> stack = <span class="keyword">new</span> Stack[Int]</div><div class="line">    stack.push(<span class="number">1</span>)</div><div class="line">    stack.push(<span class="number">2</span>)</div><div class="line">    stack.pop() should be (<span class="number">2</span>)</div><div class="line">    stack.pop() should be (<span class="number">1</span>)</div><div class="line">  }</div><div class="line"></div><div class="line">  it should <span class="string">"throw NoSuchElementException if an empty stack is popped"</span> in {</div><div class="line">    <span class="keyword">val</span> emptyStack = <span class="keyword">new</span> Stack[Int]</div><div class="line">    a [NoSuchElementException] should be thrownBy {</div><div class="line">      emptyStack.pop()</div><div class="line">    } </div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>或者 <a href="http://doc.akka.io/docs/akka/2.4.6/scala/http/routing-dsl/overview.html" target="_blank" rel="external">akka-http</a>的路由(route)的配置 (akka-http可以看作是spray 2.0的版本,因为作者现在在lightbend,也就是原先的typesafe公司开发akka-http)：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> route =</div><div class="line">  get {</div><div class="line">    pathSingleSlash {</div><div class="line">      complete(HttpEntity(ContentTypes.`text/html(UTF-<span class="number">8</span>)`,<span class="string">"&lt;html&gt;&lt;body&gt;Hello world!&lt;/body&gt;&lt;/html&gt;"</span>))</div><div class="line">    } ~</div><div class="line">      path(<span class="string">"ping"</span>) {</div><div class="line">        complete(<span class="string">"PONG!"</span>)</div><div class="line">      } ~</div><div class="line">      path(<span class="string">"crash"</span>) {</div><div class="line">        sys.error(<span class="string">"BOOM!"</span>)</div><div class="line">      }</div><div class="line">  }</div></pre></td></tr></table></figure>

<p>可以看到，使用Scala实现的DSL非常简洁，也符合人类便于阅读的方式。但是我们如何实现自己的DSL呢？文末有几篇参考文档，介绍了使用Scala实现DSL的技术，但是本文翻译的这篇文章，使用Scala实现了一个鸡蛋的web路由DSL，步骤详细，代码简单，所以我特意翻译了一下。以下内容（除了参考文档）是对原文的翻译。</p>
<a id="more"></a>
<h3 id="目标">目标</h3>
<p>Play 2.0的发布给Java社区带来了新的创建web service的方式。尽管非常美好，但是有些组件缺不是我的菜，其中之一它的router定义，它使用定制的route文件，独立的编译器和难以捉摸的逻辑。作为一个Riby程序员，我开始想能否使用Scala实现一个简单的DSL.需求很简单:</p>
<ul>
<li>静态编译</li>
<li>静态类型</li>
<li>易于使用</li>
<li>可扩展</li>
<li>反向路由</li>
<li>尽可能的类型推断</li>
<li>不使用圆括号</li>
</ul>
<h3 id="设计">设计</h3>
<p>所以第一个问题是：什么是路由器(router)? 它可以表示为<code>PartialFunction[Request, Handler]</code>,这就是Play框架中实现的方式。让我们花几秒钟先看看Play的原始的路由器。</p>
<p>在编译的过程中， conf/routes文件下的文件被解析并转换成target/src_managed文件夹下的.scala文件。有两个文件会被产生<code>routing.scala</code> 和 <code>reverse_routing.scala</code>。 <code>routing.scala</code>是一个巨大的<code>PartialFunction</code>,每一个路由使用一个case语句。 <code>reverse_routing.scala</code>对象结构。我真的不喜欢这种方式。</p>
<p>让我们开始探索 <em>如何使用Scala创建一个有用的DSL</em>。</p>
<h4 id="最终用户ui">最终用户ui</h4>
<p>我不知道DSL设计的最佳实践，我也从没读过一本关于这方面的书。我用我的方式来实现它。</p>
<p>实现的结果应该自然而直接。首先，描述你想要的，然后实现它。</p>
<p>开始的例子很简单，<code>GET /foo</code>可以路由到<code>Application.foo()</code>方法:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET <span class="string">"/foo"</span> Application.foo</div></pre></td></tr></table></figure>

<p>这个DSL非常好，但不幸的是，不使用括号的话，无法用Scala按这种方式实现。</p>
<p>当然，你已经知道Scala可是使用<code>infix notation</code>和<code>suffix notation</code>去掉括号：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A.op(B)</div></pre></td></tr></table></figure>

<p>可以写成</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A op B</div></pre></td></tr></table></figure>

<p>同样</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A.op(B).opp(C)</div></pre></td></tr></table></figure>

<p>可以写成</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A op B opp C</div></pre></td></tr></table></figure>

<p>但是这种写法仅仅适用于只有一个参数的方法， 如<code>objectA method objectB</code>。但是在我们上面的DSL例子中(GET &quot;/foo&quot; Application.foo),中间的不是是一个字符串，而不是一个方法名，所以我们不能使用<code>infix notation</code>。增加一些中间单词如何:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">GET on <span class="string">"/foo"</span> to Application.foo </div><div class="line">GET.on(<span class="string">"/foo"</span>).to(Application.foo) <span class="comment">//等价于上面的写法</span></div></pre></td></tr></table></figure>

<p>编译通过。 <code>GET</code>可以是一个代表HTTP method的对象， <code>on</code>是一个方法， <code>/foo</code>是这个方法的参数，然后<code>to</code>是另外一个方法，而<code>Application.foo</code>是一个<code>Function0[Handler]</code>。 我犯了一个错误，开始去实现它，然后我不得不扔掉了大段代码，因为实现并不能满足我前面定义的需求。</p>
<p>我来把坑挖的更深，来看看路径参数。怎么写一个路由来匹配 <code>GET /foo/{id}</code>然后调用<code>Application.show(id)</code>?，我的初始想法是:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET on <span class="string">"foo"</span> / * to Application.show</div></pre></td></tr></table></figure>

<p>看起来很好，<code>/</code>作为路径分隔符，<code>*</code>作为参数，而<code>Application.show</code>作为<code>Function1[Int, Handler]</code>。<code>/</code>作为方法实现，而<code>*</code>可以作为一个对象，因此上面的语句等价于:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET.on(<span class="string">"foo"</span>)./(*).to(Application.show) <span class="comment">// 错误!</span></div></pre></td></tr></table></figure>

<p>事实上， 由于<a href="http://stackoverflow.com/questions/2922347/operator-precedence-in-scala" target="_blank" rel="external">Scala操作符优先级的问题</a>，它实际等价于:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET.on( <span class="string">"foo"</span>./(*) ).to(Application.show)</div></pre></td></tr></table></figure>

<p>好消息，路径可以组合在一起作为<code>on</code>的参数。</p>
<p>更多的例子:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">GET on <span class="string">"foo"</span> to Application.foo</div><div class="line">PUT on <span class="string">"show"</span> / * to Application.show</div><div class="line">POST on <span class="string">"bar"</span> / * / * / <span class="string">"blah"</span> / * to Application.bar</div></pre></td></tr></table></figure>

<p>最后一件事，反向路由(reverse routing)。Play框架默认的路由器有一个限制，一个路由一个action。如果已经定义了一个路由，为什么不把它赋值给val变量用来反向路由呢：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> foo = GET on <span class="string">"foo"</span> to Application.foo</div></pre></td></tr></table></figure>

<p>然后把路由放在一个对象中：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">routes</span> </span>{</div><div class="line">  <span class="keyword">val</span> foo = GET on <span class="string">"foo"</span> to Application.foo</div><div class="line">  <span class="keyword">val</span> show = PUT on <span class="string">"show"</span> / * to Application.show</div><div class="line">  <span class="keyword">val</span> bar = POST on <span class="string">"bar"</span> / * / * / <span class="string">"blah"</span> / * to Application.bar</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在可以调用<code>routes.foo()</code> 或者 <code>routes.show(5)</code>可以得到路径。</p>
<p>本文的下一部分描述内部实现。现在你可以自己去实现它，或者参考我的实现 <a href="http://github.com/teamon/play-navigator" target="_blank" rel="external">http://github.com/teamon/play-navigator</a>, 但我强烈推荐你继续阅读实现部分。</p>
<h3 id="实现">实现</h3>
<p>这里有两个难点:<code>type</code>和<code>arity</code>。Scala中的<code>Function</code>可以有0到22个参数，代表[Function0]到<a href="">Function22</a>,后面我会介绍到。</p>
<p>我的实现<code>play-navigator</code> Route有几个参数:</p>
<ul>
<li>HTTP method</li>
<li>path definition</li>
<li>handler function</li>
</ul>
<p>用下面的例子描述各个部分：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> foo = GET on <span class="string">"foo"</span> / * to Application.show</div></pre></td></tr></table></figure>

<p>我们已经知道它等价于:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> foo = GET.on( <span class="string">"foo"</span>./(*) ).to(Application.shows)</div></pre></td></tr></table></figure>

<p>从左边开始，首先<code>GET</code>还没有实现，让我们实现它：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Method</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">ANY</span> <span class="keyword">extends</span> <span class="title">Method</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">GET</span> <span class="keyword">extends</span> <span class="title">Method</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">POST</span> <span class="keyword">extends</span> <span class="title">Method</span></span></div></pre></td></tr></table></figure>

<p>我定义了两个HTTP method和<code>ANY</code>对应所有的HTTP method。接下来应该实现<code>on</code>方法，但是我们还不知道它使用什么参数。让我们先看看<code>&quot;foo&quot; / *</code>。</p>
<p>路径可以有多个变种：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"foo"</span> / <span class="string">"bar"</span> / <span class="string">"baz"</span> <span class="string">"foo"</span> / * / <span class="string">"blah"</span> * / * / *</div></pre></td></tr></table></figure>

<p>幸好路径的各个部分可以用有限的几个类型来表示，它可以是静态路径，也可能是占位符。如此说来，我们可以使用Scala直接实现：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">PathElem</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Static</span><span class="params">(name: String)</span> <span class="keyword">extends</span> <span class="title">PathElem</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> * <span class="keyword">extends</span> <span class="title">PathElem</span></span></div></pre></td></tr></table></figure>

<p><code>case class</code>包装了一个字符串，而<code>*</code>是一个case object。不幸的的是，因为每个部分都有关联，我不得不描述更多的数据结构。先前我说过Scala有23种不同类型的<code>Function</code>，它们有不同数量的参数。我想让类型系统比较 路径占位符的数量和函数参数的数量，如果不匹配就抛出错误。因此我定义了不同版本的<code>RouteDefN</code>，我将数量减少到3：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">RouteDef</span>[<span class="title">Self</span>] </span>{</div><div class="line">  <span class="keyword">def</span> withMethod(method: Method): Self</div><div class="line">  <span class="keyword">def</span> method: Method</div><div class="line">  <span class="keyword">def</span> elems: List[PathElem]</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">RouteDef0</span><span class="params">(method: Method, elems: List[PathElem])</span> <span class="keyword">extends</span> <span class="title">RouteDef</span>[<span class="title">RouteDef0</span>]</span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">RouteDef1</span><span class="params">(method: Method, elems: List[PathElem])</span> <span class="keyword">extends</span> <span class="title">RouteDef</span>[<span class="title">RouteDef1</span>]</span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">RouteDef2</span><span class="params">(method: Method, elems: List[PathElem])</span> <span class="keyword">extends</span> <span class="title">RouteDef</span>[<span class="title">RouteDef2</span>]</span></div></pre></td></tr></table></figure>

<p><code>Self</code>类型和<code>withMethod</code>稍候解释。注意<code>RouteDefN</code>并没有类型参数（我说过我想尽可能地在编译的时候检查）。事实是<code>RouteDefN</code>仅仅知道它的HTTP method和 path elements，并不会理会handler函数本身。</p>
<p>目前的挑战是如何将</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET on <span class="string">"foo"</span> / * / <span class="string">"bar"</span></div></pre></td></tr></table></figure>

<p>转换为</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RouteDef1(GET, List(Static(<span class="string">"foo"</span>), *, Static(<span class="string">"bar"</span>)))</div></pre></td></tr></table></figure>

<p>靠隐式函数来救驾了。</p>
<p>首先我们需要将<code>String</code>转换成<code>RouteDef0</code>:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">implicit <span class="keyword">def</span> stringToRouteDef0(name: String) = RouteDef0(ANY, Static(name) :: Nil)</div></pre></td></tr></table></figure>

<p>任意一个字符串都转换成一个<code>RouteDef0</code>，拥有<code>ANY</code> method,下一步，同样的技巧应用与<code>*</code>类型:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">implicit <span class="keyword">def</span> asterixToRoutePath1(ast: *.<span class="keyword">type</span>) = RouteDef1(ANY, ast :: Nil)</div></pre></td></tr></table></figure>

<p>之所以是<code>RouteDef1</code>是因为已经有一个参数占位符。我们需要实现<code>/</code>方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">RouteDef0</span><span class="params">(method: Method, elems: List[PathElem])</span> <span class="keyword">extends</span> <span class="title">RouteDef</span>[<span class="title">RouteDef0</span>] </span>{</div><div class="line">  <span class="keyword">def</span> /(static: Static) = RouteDef0(method, elems :+ static)</div><div class="line">  <span class="keyword">def</span> /(p: PathElem) = RouteDef1(method, elems :+ p)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">RouteDef1</span><span class="params">(method: Method, elems: List[PathElem])</span> <span class="keyword">extends</span> <span class="title">RouteDef</span>[<span class="title">RouteDef1</span>]</span>{</div><div class="line">  <span class="keyword">def</span> /(static: Static) = RouteDef1(method, elems :+ static)</div><div class="line">  <span class="keyword">def</span> /(p: PathElem) = RouteDef2(method, elems :+ p)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">RouteDef2</span><span class="params">(method: Method, elems: List[PathElem])</span> <span class="keyword">extends</span> <span class="title">RouteDef</span>[<span class="title">RouteDef2</span>]</span>{</div><div class="line">  <span class="keyword">def</span> /(static: Static) = RouteDef2(method, elems :+ static)</div><div class="line">}</div></pre></td></tr></table></figure>



<p><code>/</code>方法的逻辑很简单。如果它得到Static参数，那么它返回的类型还是相同的类型。如果得到<code>*</code>参数，它返回一个更&quot;高&quot;的路由。<code>RouteDef2</code>并不允许传递<code>*</code>参数，所以我们没有定义<code>RouteDef3</code>。我们还需要实现一个字符串到<code>Static</code>的隐式转换。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">implicit <span class="keyword">def</span> stringToStatic(name: String) = Static(name)</div></pre></td></tr></table></figure>

<p>现在我们定义的DSL可以处理:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET on someRouteDef</div></pre></td></tr></table></figure>

<p>现在是<code>on</code>方法如何实现？</p>
<p>让我们返回<code>Method</code>定义，它的<code>on</code>方法需要类型参数<code>R</code>，它会调用routeDef的withMethod方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Method</span> </span>{</div><div class="line">  <span class="keyword">def</span> on[R](routeDef: RouteDef[R]): R = routeDef.withMethod(<span class="keyword">this</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>还记得<code>RouteDef</code>特质的<code>withMethod</code>方法的实现么？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">RouteDef</span>[<span class="title">Self</span>] </span>{</div><div class="line">  <span class="keyword">def</span> withMethod(method: Method): Self</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在<code>RouteDefN</code>可以写做:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">RouteDef0</span><span class="params">(method: Method, elems: List[PathElem])</span> <span class="keyword">extends</span> <span class="title">RouteDef</span>[<span class="title">RouteDef0</span>] </span>{</div><div class="line">  <span class="keyword">def</span> withMethod(method: Method) = RouteDef0(method, elems)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">RouteDef1</span><span class="params">(method: Method, elems: List[PathElem])</span> <span class="keyword">extends</span> <span class="title">RouteDef</span>[<span class="title">RouteDef1</span>]</span>{</div><div class="line">  <span class="keyword">def</span> withMethod(method: Method) = RouteDef1(method, elems)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">RouteDef2</span><span class="params">(method: Method, elems: List[PathElem])</span> <span class="keyword">extends</span> <span class="title">RouteDef</span>[<span class="title">RouteDef2</span>]</span>{</div><div class="line">  <span class="keyword">def</span> withMethod(method: Method) = RouteDef2(method, elems)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这样<code>on</code>方法就是返回正确的类型。</p>
<p>最后就是和handler拼装起来：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">someRouteDef to Application.show</div></pre></td></tr></table></figure>

<p>我说过我想让编译器检查路径参数中的参数数量是否和handler需要的参数数量一致。现在隆重转为疯狂的类<code>RouteN</code>出场。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sealed trait Route[RD] {</div><div class="line">  def routeDef: RouteDef[RD]</div><div class="line">}</div><div class="line"></div><div class="line">case class Route0(routeDef: RouteDef0, f0: () ⇒ Out) extends Route[RouteDef0]</div><div class="line">case class Route1[A: PathParam : Manifest](routeDef: RouteDef1, f1: (A) ⇒ Out) extends Route[RouteDef1]</div><div class="line">case class Route2[A: PathParam : Manifest, B: PathParam : Manifest](routeDef: RouteDef2, f2: (A, B) ⇒ Out) extends Route[RouteDef2]</div></pre></td></tr></table></figure>

<p>呜呼哀哉， 类型、更多的类型、更多坨的类型，保持胃口继续看。<code>Route0</code>需要<code>RouteDef0</code>和<code>() ⇒ Out</code>参数。 <code>Route1</code> 需要<code>RouteDef1</code>和<code>function (A) ⇒ Out</code>,A为类型参数:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[A: PathParam : Manifest]</div></pre></td></tr></table></figure>


<p>是下面代码的简写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[A](implicit pp: PathParam[A], mf: Manifest[A])</div></pre></td></tr></table></figure>

<p><code>PathParam[A]</code> 和 <code>Manifest[A]</code>稍后解释。</p>
<p>你也可能已经推断出<code>Route2</code>使用<code>RouteDef2</code> 和 <code>function (A,B) ⇒ Out</code>做参数,  A 和 B 都是类型参数。</p>
<p>返回到<code>RouteDef</code>,增加<code>to</code>方法:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">RouteDef0</span><span class="params">(method: Method, elems: List[PathElem])</span> <span class="keyword">extends</span> <span class="title">RouteDef</span>[<span class="title">RouteDef0</span>] </span>{</div><div class="line">  <span class="keyword">def</span> to(f0: () ⇒ Out) = Route0(<span class="keyword">this</span>, f0)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">RouteDef1</span><span class="params">(method: Method, elems: List[PathElem])</span> <span class="keyword">extends</span> <span class="title">RouteDef</span>[<span class="title">RouteDef1</span>]</span>{</div><div class="line">  <span class="keyword">def</span> to[A: PathParam : Manifest](f1: (A) ⇒ Out) = Route1(<span class="keyword">this</span>, f1)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">RouteDef2</span><span class="params">(method: Method, elems: List[PathElem])</span> <span class="keyword">extends</span> <span class="title">RouteDef</span>[<span class="title">RouteDef2</span>]</span>{</div><div class="line">  <span class="keyword">def</span> to[A: PathParam : Manifest, B: PathParam : Manifest](f2: (A, B) ⇒ Out) = Route2(<span class="keyword">this</span>, f2)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>编译器会检查参数的匹配问题,<code>RouteDefN</code>的<code>to</code>方法只会允许正确的Handler作为参数。</p>
<p>我们可以为<code>RouteN</code>增加<code>def apply</code>来来检查参数的数量和正确的类型。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">case class Route1[A: PathParam : Manifest](routeDef: RouteDef1, f2: (A) ⇒ Out) extends Route[RouteDef1] {</div><div class="line">  def apply(a: A) = PathMatcher1(routeDef.elems)(a)</div><div class="line">}</div><div class="line"></div><div class="line">case class Route2[A: PathParam : Manifest, B: PathParam : Manifest](routeDef: RouteDef2, f2: (A, B) ⇒ Out) extends Route[RouteDef2] {</div><div class="line">  def apply(a: A, b: B) = PathMatcher2(routeDef.elems)(a, b)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>所以如果我们定义了一个路由：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> foo = GET on <span class="string">"foo"</span> / * to Application.show</div></pre></td></tr></table></figure>

<p>这里<code>foo</code>是一个类型为<code>Route1[Int](RouteDef1(GET, Static(&quot;foo&quot;) :: * :: Nil), Application.show)</code>的对象，同时<code>foo</code>还是<code>(Int) ⇒ String</code>类型。</p>
<p>关于<code>PathMatcherN</code>用来匹配request uri到正确的路由。因为在本文中我只想介绍DSL相关的实现，所以我不想多介绍它。你可以把它看成一个解析和构造url的函数。</p>
<p>现在只剩下一件事。既然所有的路由都是类型安全的，那么我们需要一个类型安全的方式匹配路径和action。一种方式是硬编码，比较傻。既然我们已经有了类型敏感的路由，Scala拥有强大的类型系统，为什么不让工作好上加好呢？</p>
<p>我们需要做什么？</p>
<ul>
<li>解析路径(字符串)为我们的类型</li>
<li>转换路径参数为字符串 (for 反向路由)</li>
</ul>
<p>如何实现呢？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PathParam</span>[<span class="title">T</span>]</span>{</div><div class="line">  <span class="keyword">def</span> apply(t: T): String</div><div class="line">  <span class="keyword">def</span> unapply(s: String): Option[T]</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>apply</code>将类型T转换成字符串。而<code>unapply</code>将字符串转换成<code>T</code>。</p>
<p>下面是两个将路径参数转换成相应类型的例子。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">implicit <span class="keyword">val</span> StringPathParam: PathParam[String] = <span class="keyword">new</span> PathParam[String] {</div><div class="line">  <span class="keyword">def</span> apply(s: String) = s</div><div class="line">  <span class="keyword">def</span> unapply(s: String) = Some(s)</div><div class="line">}</div><div class="line"></div><div class="line">implicit <span class="keyword">val</span> BooleanPathParam: PathParam[Boolean] = <span class="keyword">new</span> PathParam[Boolean] {</div><div class="line">  <span class="keyword">def</span> apply(b: Boolean) = b.toString</div><div class="line">  <span class="keyword">def</span> unapply(s: String) = s.toLowerCase <span class="keyword">match</span> {</div><div class="line">    <span class="keyword">case</span> <span class="string">"1"</span> | <span class="string">"true"</span> | <span class="string">"yes"</span> ⇒ Some(<span class="keyword">true</span>)</div><div class="line">    <span class="keyword">case</span> <span class="string">"0"</span> | <span class="string">"false"</span> | <span class="string">"no"</span> ⇒ Some(<span class="keyword">false</span>)</div><div class="line">    <span class="keyword">case</span> _ ⇒ None</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>因此可以定制类型作为action (handler)的参数。</p>
<p>上文中一个秘密就是RouteN中的PathParam[A]，Route类只关心PathParam,所以使用其它类型创建route是不允许的，编译器出错。</p>
<p>Manifest[A]是Scala编译器提供的一个特殊的类，为类型提供运行时的类型信息。</p>
<p>再提供一个java.util.UUID的路径参数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">implicit <span class="keyword">val</span> UUIDPathParam: PathParam[UUID] = <span class="keyword">new</span> PathParam[UUID] {</div><div class="line">  <span class="keyword">def</span> apply(uuid: UUID) = uuid.toString</div><div class="line">  <span class="keyword">def</span> unapply(s: String) = <span class="keyword">try</span> {</div><div class="line">    Some(UUID.fromString(s))</div><div class="line">  } <span class="keyword">catch</span> {</div><div class="line">    <span class="keyword">case</span> _ ⇒ None</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在，让我们检查一下我们的需求：</p>
<ul>
<li>静态编译 √</li>
<li>静态类型 √</li>
<li>易于使用 √</li>
<li>可扩展 √</li>
<li>反向路由 √</li>
<li>尽可能的类型推断 √</li>
<li>不使用圆括号 √</li>
</ul>
<p>所有需求都实现。</p>
<p>如果你发现文中有遗漏的地方，或者错误，可以和作者联系 <a href="http://twitter.com/iteamon" target="_blank" rel="external">twitter (@iteamon)</a>, teamon on <a href="irc://irc.freenode.net/#scala" target="_blank" rel="external">#scala @ irc.freenode.net</a>。</p>
<p>你也可以看完整的项目实现: <a href="http://teamon.github.com/play-navigator" target="_blank" rel="external">play-navigator</a></p>
<p>翻译完毕。</p>
<h3 id="其它参考资料">其它参考资料</h3>
<ol>
<li><a href="http://www.scala-lang.org/old/node/1403" target="_blank" rel="external">DSLs - A powerful Scala feature</a></li>
<li><a href="http://blog.scalac.io/2015/05/07/encog-dsl.html" target="_blank" rel="external">Creating Domain Specific Languages with Scala - Part 1</a></li>
<li><a href="https://stanford-ppl.github.io/Delite/myfirstdsl.html" target="_blank" rel="external">My First DSL</a></li>
<li><a href="https://www.manning.com/books/dsls-in-action" target="_blank" rel="external">DSLs in Action</a></li>
<li><a href="http://blog.siddhuw.info/writing-dsls-using-scala-part-1-underlying-concepts/" target="_blank" rel="external">Writing DSLs using Scala. Part 1 — Underlying Concepts</a></li>
<li><a href="http://blog.siddhuw.info/writing-dsls-using-scala-part-ii-a-simple-matcher-dsl/" target="_blank" rel="external">Writing DSLs using Scala. Part II - A simple matcher DSL</a></li>
<li><a href="https://www.safaribooksonline.com/library/view/programming-scala/9780596801908/ch11.html" target="_blank" rel="external">Domain-Specific Languages in Scala</a></li>
<li><a href="https://github.com/p3t0r/scala-sql-dsl" target="_blank" rel="external">scala-sql-dsl</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="http://codetunes.com/2012/scala-dsl-tutorial-writing-web-framework-router/" target="_blank" rel="external">Scala DSL tutorial - writing a web framework router</a>, 作者: Tymon Tobolski </p>
<p><strong>译者按:</strong><br>Scala非常适合实现DSL(<a href="https://en.wikipedia.org/wiki/Domain-specific_language" target="_blank" rel="external">Domain-specific language</a>)。我在使用Scala的过程中印象深刻的是<a href="http://www.scalatest.org/" target="_blank" rel="external">scalatest</a>和<a href="http://spray.io/documentation/1.2.3/spray-routing/" target="_blank" rel="external">spray-routing</a>,</p>
<p>比如scalatest的测试代码的编写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> collection.mutable.Stack</div><div class="line"><span class="keyword">import</span> org.scalatest._</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleSpec</span> <span class="keyword">extends</span> <span class="title">FlatSpec</span> <span class="keyword">with</span> <span class="title">Matchers</span> </span>{</div><div class="line"></div><div class="line">  <span class="string">"A Stack"</span> should <span class="string">"pop values in last-in-first-out order"</span> in {</div><div class="line">    <span class="keyword">val</span> stack = <span class="keyword">new</span> Stack[Int]</div><div class="line">    stack.push(<span class="number">1</span>)</div><div class="line">    stack.push(<span class="number">2</span>)</div><div class="line">    stack.pop() should be (<span class="number">2</span>)</div><div class="line">    stack.pop() should be (<span class="number">1</span>)</div><div class="line">  }</div><div class="line"></div><div class="line">  it should <span class="string">"throw NoSuchElementException if an empty stack is popped"</span> in {</div><div class="line">    <span class="keyword">val</span> emptyStack = <span class="keyword">new</span> Stack[Int]</div><div class="line">    a [NoSuchElementException] should be thrownBy {</div><div class="line">      emptyStack.pop()</div><div class="line">    } </div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>或者 <a href="http://doc.akka.io/docs/akka/2.4.6/scala/http/routing-dsl/overview.html" target="_blank" rel="external">akka-http</a>的路由(route)的配置 (akka-http可以看作是spray 2.0的版本,因为作者现在在lightbend,也就是原先的typesafe公司开发akka-http)：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> route =</div><div class="line">  get {</div><div class="line">    pathSingleSlash {</div><div class="line">      complete(HttpEntity(ContentTypes.`text/html(UTF-<span class="number">8</span>)`,<span class="string">"&lt;html&gt;&lt;body&gt;Hello world!&lt;/body&gt;&lt;/html&gt;"</span>))</div><div class="line">    } ~</div><div class="line">      path(<span class="string">"ping"</span>) {</div><div class="line">        complete(<span class="string">"PONG!"</span>)</div><div class="line">      } ~</div><div class="line">      path(<span class="string">"crash"</span>) {</div><div class="line">        sys.error(<span class="string">"BOOM!"</span>)</div><div class="line">      }</div><div class="line">  }</div></pre></td></tr></table></figure>

<p>可以看到，使用Scala实现的DSL非常简洁，也符合人类便于阅读的方式。但是我们如何实现自己的DSL呢？文末有几篇参考文档，介绍了使用Scala实现DSL的技术，但是本文翻译的这篇文章，使用Scala实现了一个鸡蛋的web路由DSL，步骤详细，代码简单，所以我特意翻译了一下。以下内容（除了参考文档）是对原文的翻译。</p>
]]>
    
    </summary>
    
      <category term="DSL" scheme="http://colobu.com/tags/DSL/"/>
    
      <category term="Scala" scheme="http://colobu.com/categories/Scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[更好的Scala I/O: better-files]]></title>
    <link href="http://colobu.com/2016/05/11/better-files-Simple-safe-and-intuitive-Scala-I-O/"/>
    <id>http://colobu.com/2016/05/11/better-files-Simple-safe-and-intuitive-Scala-I-O/</id>
    <published>2016-05-11T08:09:21.000Z</published>
    <updated>2016-06-21T08:57:04.000Z</updated>
    <content type="html"><![CDATA[<p>对于使用Scala的程序员来说， I/O操作如文件的读写通常使用<a href="http://www.scala-lang.org/api/current/#scala.io.Source$" target="_blank" rel="external">scala.io.Source</a>来实现。但是这个类功能还是欠缺的，而且功能混乱，因此在Scala类库的增强提案(<a href="https://github.com/scala/slip/issues/19" target="_blank" rel="external">Scala IO fix-up/overhaul</a>)中如何改进它争论相当的大，甚至有些开发者提议将这个库废掉，让社区实现的第三方来完成这方面的工作，或者引导开发者使用<code>java.nio</code>来实现I/O操作。</p>
<p>当然，作为一个使用Scala的公司来说，可能会自己实现了辅助的I/O操作的方法， 比如类似FileUtils等名称的一些类。Java程序员可能已经熟悉了使用<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html" target="_blank" rel="external">java.nio.file.Files</a>、<a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/io/Files.html" target="_blank" rel="external">Guava</a>、<a href="https://commons.apache.org/proper/commons-io/" target="_blank" rel="external">Apache common-io</a>、<a href="http://jodd.org/api/jodd/io/FileUtil.html" target="_blank" rel="external">jodd FileUtil</a>等开源I/O库，但是如果使用Scala进行I/O操作时，虽然还是可以使用这些Java I/O库,但是毕竟还是不是那么纯粹，因此，我们可以关注一下Scala实现的I/O库，比如<a href="https://github.com/sbt/io" target="_blank" rel="external">sbt io</a>、<a href="http://www.lihaoyi.com/Ammonite/#Ammonite-Ops" target="_blank" rel="external">Ammonite-Ops</a>、<a href="https://github.com/pathikrit/better-files" target="_blank" rel="external">better-files</a>等。</p>
<p>本文为你推荐<a href="https://github.com/pathikrit/better-files" target="_blank" rel="external">better-files</a>。</p>
<a id="more"></a>
<p>为什么推荐<a href="https://github.com/pathikrit/better-files" target="_blank" rel="external">better-files</a>呢？让我们看看它的功能，就明白它的简单而强大了，就像一把I/O操作的瑞士军刀。</p>
<p>要使用better-files,只需加入下面的依赖：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">libraryDependencies += <span class="string">"com.github.pathikrit"</span> %% <span class="string">"better-files"</span> % <span class="keyword">version</span></div></pre></td></tr></table></figure>

<p>它对Java NIO库进行了包装，不依赖其它的第三方库。</p>
<blockquote>
<p>以下介绍摘译自better-files的<a href="https://github.com/pathikrit/better-files#tutorial-" target="_blank" rel="external">官方文档</a>。</p>
</blockquote>
<h3 id="实例化">实例化</h3>
<p>下面的实例都是等价的，才可以采用多种方式得到File对象。可以通过字符串、String interpolator, Java File、隐式转换、定义的常量和操作符&quot;/&quot;等产生File对象。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> better.files._</div><div class="line"><span class="keyword">import</span> java.io.{File =&gt; JFile}</div><div class="line"></div><div class="line"><span class="keyword">val</span> f = File(<span class="string">"/User/johndoe/Documents"</span>)                      <span class="comment">// using constructor</span></div><div class="line"><span class="keyword">val</span> f1: File = file<span class="string">"/User/johndoe/Documents"</span>                 <span class="comment">// using string interpolator</span></div><div class="line"><span class="keyword">val</span> f2: File = <span class="string">"/User/johndoe/Documents"</span>.toFile              <span class="comment">// convert a string path to a file</span></div><div class="line"><span class="keyword">val</span> f3: File = <span class="keyword">new</span> JFile(<span class="string">"/User/johndoe/Documents"</span>).toScala  <span class="comment">// convert a Java file to Scala</span></div><div class="line"><span class="keyword">val</span> f4: File = root/<span class="string">"User"</span>/<span class="string">"johndoe"</span>/<span class="string">"Documents"</span>             <span class="comment">// using root helper to start from root</span></div><div class="line"><span class="keyword">val</span> f5: File = `~` / <span class="string">"Documents"</span>                             <span class="comment">// also equivalent to `home / "Documents"`</span></div><div class="line"><span class="keyword">val</span> f6: File = <span class="string">"/User"</span>/<span class="string">"johndoe"</span>/<span class="string">"Documents"</span>                 <span class="comment">// using file separator DSL</span></div><div class="line"><span class="keyword">val</span> f7: File = home/<span class="string">"Documents"</span>/<span class="string">"presentations"</span>/`..`         <span class="comment">// Use `..` to navigate up to parent</span></div></pre></td></tr></table></figure>

<h3 id="文件读写">文件读写</h3>
<p>可以一行搞定：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> file = root/<span class="string">"tmp"</span>/<span class="string">"test.txt"</span></div><div class="line">file.overwrite(<span class="string">"hello"</span>)</div><div class="line">file.appendLine().append(<span class="string">"world"</span>)</div><div class="line">assert(file.contentAsString == <span class="string">"hello\nworld"</span>)</div></pre></td></tr></table></figure>

<p>类似C++/Shell风格的读写，和上面的功能一样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">file &lt; <span class="string">"hello"</span>     <span class="comment">// same as file.overwrite("hello")</span></div><div class="line">file &lt;&lt; <span class="string">"world"</span>    <span class="comment">// same as file.appendLines("world")</span></div><div class="line">assert(file! == <span class="string">"hello\nworld"</span>)</div></pre></td></tr></table></figure>

<p>或者这样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"hello"</span> `&gt;:` file</div><div class="line"><span class="string">"world"</span> &gt;&gt;: file</div><div class="line"><span class="keyword">val</span> bytes: Array[Byte] = file.loadBytes</div></pre></td></tr></table></figure>

<p><strong>流式接口风格：</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(root/<span class="string">"tmp"</span>/<span class="string">"diary.txt"</span>)</div><div class="line"> .createIfNotExists()  </div><div class="line"> .appendLine()</div><div class="line"> .appendLines(<span class="string">"My name is"</span>, <span class="string">"Inigo Montoya"</span>)</div><div class="line"> .moveTo(home/<span class="string">"Documents"</span>)</div><div class="line"> .renameTo(<span class="string">"princess_diary.txt"</span>)</div><div class="line"> .changeExtensionTo(<span class="string">".md"</span>)</div><div class="line"> .lines</div></pre></td></tr></table></figure>


<h3 id="Stream和编码">Stream和编码</h3>
<p>产生迭代器：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> bytes  : Iterator[Byte]            = file.bytes</div><div class="line"><span class="keyword">val</span> chars  : Iterator[Char]            = file.chars</div><div class="line"><span class="keyword">val</span> lines  : Iterator[String]          = file.lines</div><div class="line"><span class="keyword">val</span> source : scala.io.BufferedSource   = file.newBufferedSource <span class="comment">// needs to be closed, unlike the above APIs which auto closes when iterator ends</span></div></pre></td></tr></table></figure>

<p>编解码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> content: String = file.contentAsString  <span class="comment">// default codec</span></div><div class="line"><span class="comment">// custom codec:</span></div><div class="line"><span class="keyword">import</span> scala.io.Codec</div><div class="line">file.contentAsString(Codec.ISO8859)</div><div class="line"><span class="comment">//or</span></div><div class="line"><span class="keyword">import</span> scala.io.Codec.string2codec</div><div class="line">file.write(<span class="string">"hello world"</span>)(codec = <span class="string">"US-ASCII"</span>)</div></pre></td></tr></table></figure>

<h3 id="与Java交互">与Java交互</h3>
<p>转换成Java对象：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> file: File = tmp / <span class="string">"hello.txt"</span></div><div class="line"><span class="keyword">val</span> javaFile     : java.io.File                 = file.toJava</div><div class="line"><span class="keyword">val</span> uri          : java.net.uri                 = file.uri</div><div class="line"><span class="keyword">val</span> reader       : java.io.BufferedReader       = file.newBufferedReader </div><div class="line"><span class="keyword">val</span> outputstream : java.io.OutputStream         = file.newOutputStream </div><div class="line"><span class="keyword">val</span> writer       : java.io.BufferedWriter       = file.newBufferedWriter </div><div class="line"><span class="keyword">val</span> inputstream  : java.io.InputStream          = file.newInputStream</div><div class="line"><span class="keyword">val</span> path         : java.nio.file.Path           = file.path</div><div class="line"><span class="keyword">val</span> fs           : java.nio.file.FileSystem     = file.fileSystem</div><div class="line"><span class="keyword">val</span> channel      : java.nio.channel.FileChannel = file.newFileChannel</div><div class="line"><span class="keyword">val</span> ram          : java.io.RandomAccessFile     = file.newRandomAccess</div><div class="line"><span class="keyword">val</span> fr           : java.io.FileReader           = file.newFileReader</div><div class="line"><span class="keyword">val</span> fw           : java.io.FileWriter           = file.newFileWriter(append = <span class="keyword">true</span>)</div><div class="line"><span class="keyword">val</span> printer      : java.io.PrintWriter          = file.newPrintWriter</div></pre></td></tr></table></figure>

<p>以及</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">file1.reader &gt; file2.writer       <span class="comment">// pipes a reader to a writer</span></div><div class="line">System.in &gt; file2.out             <span class="comment">// pipes an inputstream to an outputstream</span></div><div class="line">src.pipeTo(sink)                  <span class="comment">// if you don't like symbols</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> bytes   : Iterator[Byte]        = inputstream.bytes</div><div class="line"><span class="keyword">val</span> bis     : BufferedInputStream   = inputstream.buffered  </div><div class="line"><span class="keyword">val</span> bos     : BufferedOutputStream  = outputstream.buffered   </div><div class="line"><span class="keyword">val</span> reader  : InputStreamReader     = inputstream.reader</div><div class="line"><span class="keyword">val</span> writer  : OutputStreamWriter    = outputstream.writer</div><div class="line"><span class="keyword">val</span> printer : PrintWriter           = outputstream.printWriter</div><div class="line"><span class="keyword">val</span> br      : BufferedReader        = reader.buffered</div><div class="line"><span class="keyword">val</span> bw      : BufferedWriter        = writer.buffered</div><div class="line"><span class="keyword">val</span> mm      : MappedByteBuffer      = fileChannel.toMappedByteBuffer</div></pre></td></tr></table></figure>

<h3 id="模式匹配">模式匹配</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * <span class="property">@return</span> <span class="literal">true</span> <span class="keyword">if</span> file <span class="keyword">is</span> a directory <span class="reserved">with</span> <span class="literal">no</span> children <span class="keyword">or</span> a file <span class="reserved">with</span> <span class="literal">no</span> contents</div><div class="line"> */</div><div class="line">def isEmpty(<span class="attribute">file</span>: File): Boolean = file match {</div><div class="line">  <span class="reserved">case</span> File.Type.SymbolicLink<span class="function"><span class="params">(to)</span> =&gt;</span> isEmpty(to)  <span class="regexp">//</span> <span class="keyword">this</span> must be first <span class="reserved">case</span> statement <span class="keyword">if</span> you want to handle symlinks specially; <span class="keyword">else</span> will follow link</div><div class="line">  <span class="reserved">case</span> File.Type.Directory<span class="function"><span class="params">(files)</span> =&gt;</span> files.isEmpty</div><div class="line">  <span class="reserved">case</span> File.Type.RegularFile<span class="function"><span class="params">(content)</span> =&gt;</span> content.isEmpty</div><div class="line">  <span class="reserved">case</span> _<span class="function"> =&gt;</span> file.notExists    <span class="regexp">//</span> a file may <span class="keyword">not</span> be one <span class="keyword">of</span> the above e.g. UNIX pipes, sockets, devices etc</div><div class="line">}</div><div class="line"><span class="regexp">//</span> <span class="keyword">or</span> as extractors <span class="literal">on</span> <span class="attribute">LHS</span>:</div><div class="line">val File.Type.Directory(researchDocs) = home<span class="regexp">/"Downloads"/</span><span class="string">"research"</span></div></pre></td></tr></table></figure>

<h3 id="通配符">通配符</h3>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> dir = <span class="string">"src"</span>/<span class="string">"test"</span></div><div class="line"><span class="keyword">val</span> matches: Iterator[File] = dir.glob(<span class="string">"**/*.{java,scala}"</span>)</div><div class="line"><span class="comment">// above code is equivalent to:</span></div><div class="line">dir.listRecursively.filter(f =&gt; f.extension == Some(<span class="string">".java"</span>) || f.extension == Some(<span class="string">".scala"</span>))</div></pre></td></tr></table></figure>

<p>甚至使用正则表达式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> matches = dir.glob(<span class="string">"^\\w*$"</span>)(syntax = File.PathMatcherSyntax.regex)</div></pre></td></tr></table></figure>

<h3 id="文件系统操作">文件系统操作</h3>
<p>文件系统操作也非常的便利：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">file</span>.touch()</div><div class="line"><span class="keyword">file</span>.<span class="keyword">delete</span>()     <span class="comment">// unlike the Java API, also works on directories as expected (deletes children recursively)</span></div><div class="line"><span class="keyword">file</span>.clear()      <span class="comment">// If directory, deletes all children; if file clears contents</span></div><div class="line"><span class="keyword">file</span>.renameTo(newName: String)</div><div class="line"><span class="keyword">file</span>.moveTo(destination)</div><div class="line"><span class="keyword">file</span>.copyTo(destination)       <span class="comment">// unlike the default API, also works on directories (copies recursively)</span></div><div class="line"><span class="keyword">file</span>.linkTo(destination)                     <span class="comment">// ln file destination</span></div><div class="line"><span class="keyword">file</span>.symbolicLinkTo(destination)             <span class="comment">// ln -s file destination</span></div><div class="line"><span class="keyword">file</span>.{checksum, md5, sha1, sha256, sha512, digest}   <span class="comment">// also works for directories</span></div><div class="line"><span class="keyword">file</span>.setOwner(user: String)    <span class="comment">// chown user file</span></div><div class="line"><span class="keyword">file</span>.setGroup(<span class="keyword">group</span>: String)   <span class="comment">// chgrp group file</span></div><div class="line">Seq(file1, file2) &gt;: file3     <span class="comment">// same as cat file1 file2 &gt; file3</span></div><div class="line">Seq(file1, file2) &gt;&gt;: file3    <span class="comment">// same as cat file1 file2 &gt;&gt; file3</span></div><div class="line"><span class="keyword">file</span>.isReadLocked <span class="regexp">/ file.isWriteLocked /</span> <span class="keyword">file</span>.isLocked</div><div class="line"><span class="keyword">File</span>.newTemporaryDirectory() <span class="regexp">/ File.newTemporaryFile() /</span><span class="regexp">/ create temp dir/</span><span class="keyword">file</span></div></pre></td></tr></table></figure>

<h3 id="UNIX_DSL">UNIX DSL</h3>
<p>甚至提供了UNIX命令风格的操作：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import better.files_, Cmds._  <span class="comment"> // must import Cmds._ to bring in these utils</span></div><div class="line">pwd / cwd    <span class="comment"> // current dir</span></div><div class="line">cp(file1, file2)</div><div class="line">mv(file1, file2)</div><div class="line">rm(<span class="built_in">file</span>) <span class="comment">/*or*/</span> del(<span class="built_in">file</span>)</div><div class="line">ls(<span class="built_in">file</span>) <span class="comment">/*or*/</span> dir(<span class="built_in">file</span>)</div><div class="line"><span class="built_in">ln</span>(file1, file2)    <span class="comment"> // hard link</span></div><div class="line">ln_s(file1, file2)  <span class="comment"> // soft link</span></div><div class="line">cat(file1)</div><div class="line">cat(file1) &gt;&gt;: <span class="built_in">file</span></div><div class="line">touch(<span class="built_in">file</span>)</div><div class="line">mkdir(<span class="built_in">file</span>)</div><div class="line">mkdirs(<span class="built_in">file</span>)        <span class="comment"> // mkdir -p</span></div><div class="line">chown(owner, <span class="built_in">file</span>)</div><div class="line">chgrp(owner, <span class="built_in">file</span>)</div><div class="line">chmod_+(permission, <span class="built_in">files</span>) <span class="comment"> // add permission</span></div><div class="line">chmod_-(permission, <span class="built_in">files</span>) <span class="comment"> // remove permission</span></div><div class="line">md5(<span class="built_in">file</span>) / sha1(<span class="built_in">file</span>) / sha256(<span class="built_in">file</span>) / sha512(<span class="built_in">file</span>)</div><div class="line">unzip(zipFile)(targetDir)</div><div class="line">zip(<span class="built_in">file</span>*)(zipFile)</div></pre></td></tr></table></figure>

<h3 id="文件属性">文件属性</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">file</span>.name       // simpler than java.io.File#getName</div><div class="line"><span class="keyword">file</span>.extension</div><div class="line"><span class="keyword">file</span>.contentType</div><div class="line"><span class="keyword">file</span>.lastModifiedTime     // returns JSR-<span class="number">310</span> time</div><div class="line"><span class="keyword">file</span>.owner / <span class="keyword">file</span>.group</div><div class="line"><span class="keyword">file</span>.isDirectory / <span class="keyword">file</span>.isSymbolicLink / <span class="keyword">file</span>.isRegularFile</div><div class="line"><span class="keyword">file</span>.isHidden</div><div class="line"><span class="keyword">file</span>.<span class="keyword">hide</span>() / <span class="keyword">file</span>.<span class="keyword">unhide</span>()</div><div class="line"><span class="keyword">file</span>.isOwnerExecutable / <span class="keyword">file</span>.isGroupReadable // etc. see <span class="keyword">file</span>.permissions</div><div class="line"><span class="keyword">file</span>.size                 // <span class="keyword">for</span> <span class="keyword">a</span> directory, computes the directory size</div><div class="line"><span class="keyword">file</span>.posixAttributes / <span class="keyword">file</span>.dosAttributes  // see <span class="keyword">file</span>.attributes</div><div class="line"><span class="keyword">file</span>.isEmpty      // true <span class="keyword">if</span> <span class="keyword">file</span> <span class="built_in">has</span> <span class="keyword">no</span> content (<span class="built_in">or</span> <span class="keyword">no</span> children <span class="keyword">if</span> directory) <span class="built_in">or</span> does not exist</div><div class="line"><span class="keyword">file</span>.isParentOf / <span class="keyword">file</span>.isChildOf / <span class="keyword">file</span>.isSiblingOf / <span class="keyword">file</span>.siblings</div></pre></td></tr></table></figure>

<p><code>chmod</code>:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.nio.file.attribute.PosixFilePermission</div><div class="line">file.addPermission(PosixFilePermission.OWNER_EXECUTE)      <span class="comment">// chmod +X file</span></div><div class="line">file.removePermission(PosixFilePermission.OWNER_WRITE)     <span class="comment">// chmod -w file</span></div><div class="line">assert(file.permissionsAsString == <span class="string">"rw-r--r--"</span>)</div><div class="line"></div><div class="line"><span class="comment">// The following are all equivalent:</span></div><div class="line">assert(file.permissions contains PosixFilePermission.OWNER_EXECUTE)</div><div class="line">assert(file(PosixFilePermission.OWNER_EXECUTE))</div><div class="line">assert(file.isOwnerExecutable)</div></pre></td></tr></table></figure>

<h3 id="文件比较">文件比较</h3>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">file1 == file2    <span class="comment">// equivalent to `file1.isSamePathAs(file2)`</span></div><div class="line">file1 === file2   <span class="comment">// equivalent to `file1.isSameContentAs(file2)` (works for regular-files and directories)</span></div><div class="line">file1 != file2    <span class="comment">// equivalent to `!file1.isSamePathAs(file2)`</span></div><div class="line">file1 =!= file2   <span class="comment">// equivalent to `!file1.isSameContentAs(file2)`</span></div></pre></td></tr></table></figure>

<p>排序:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> files = myDir.list.toSeq</div><div class="line">files.sorted(File.Order.byName) </div><div class="line">files.max(File.Order.bySize) </div><div class="line">files.min(File.Order.byDepth) </div><div class="line">files.max(File.Order.byModificationTime) </div><div class="line">files.sorted(File.Order.byDirectoriesFirst)</div></pre></td></tr></table></figure>

<h3 id="压缩解压缩">压缩解压缩</h3>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Unzipping:</span></div><div class="line"><span class="keyword">val</span> zipFile: File = file<span class="string">"path/to/research.zip"</span></div><div class="line"><span class="keyword">val</span> research: File = zipFile.unzipTo(destination = home/<span class="string">"Documents"</span>/<span class="string">"research"</span>) </div><div class="line"></div><div class="line"><span class="comment">// Zipping:</span></div><div class="line"><span class="keyword">val</span> zipFile: File = directory.zipTo(destination = home/<span class="string">"Desktop"</span>/<span class="string">"toEmail.zip"</span>)</div><div class="line"></div><div class="line"><span class="comment">// Zipping/Unzipping to temporary files/directories:</span></div><div class="line"><span class="keyword">val</span> someTempZipFile: File = directory.zip()</div><div class="line"><span class="keyword">val</span> someTempDir: File = zipFile.unzip()</div><div class="line">assert(directory === someTempDir)</div><div class="line"></div><div class="line"><span class="comment">// Gzip handling:</span></div><div class="line">File(<span class="string">"countries.gz"</span>).newInputStream.gzipped.lines.take(<span class="number">10</span>).foreach(println)</div></pre></td></tr></table></figure>

<h3 id="轻量级的ARM_(自动化的资源管理)">轻量级的ARM (自动化的资源管理)</h3>
<p>Auto-close Java closeables:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> {</div><div class="line">  in &lt;- file1.newInputStream.autoClosed</div><div class="line">  out &lt;- file2.newOutputStream.autoClosed</div><div class="line">} in.pipeTo(out)</div></pre></td></tr></table></figure>

<p><code>better-files</code>提供了更加便利的管理，因此下面的代码</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> {</div><div class="line"> reader &lt;- file.newBufferedReader.autoClosed</div><div class="line">} foo(reader)</div></pre></td></tr></table></figure>

<p>可以写成：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> {</div><div class="line"> reader &lt;- file.bufferedReader    <span class="comment">// returns ManagedResource[BufferedReader]</span></div><div class="line">} foo(reader)</div><div class="line"></div><div class="line"><span class="comment">// or simply:</span></div><div class="line">file.bufferedReader.map(foo)</div></pre></td></tr></table></figure>

<h3 id="Scanner">Scanner</h3>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> data = t1 &lt;&lt; s<span class="string">"""</span></div><div class="line">  | Hello World</div><div class="line">  | 1 true 2 3</div><div class="line">""".stripMargin</div><div class="line"><span class="keyword">val</span> scanner: Scanner = data.newScanner()</div><div class="line">assert(scanner.next[String] == <span class="string">"Hello"</span>)</div><div class="line">assert(scanner.lineNumber == <span class="number">1</span>)</div><div class="line">assert(scanner.next[String] == <span class="string">"World"</span>)</div><div class="line">assert(scanner.next[(Int, Boolean)] == (<span class="number">1</span>, <span class="keyword">true</span>))</div><div class="line">assert(scanner.tillEndOfLine() == <span class="string">" 2 3"</span>)</div><div class="line">assert(!scanner.hasNext)</div></pre></td></tr></table></figure>

<p>你甚至可以写定制的Scanner。</p>
<h3 id="文件监控">文件监控</h3>
<p>普通的Java文件监控：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.nio.file.{StandardWatchEventKinds =&gt; EventType}</div><div class="line"><span class="keyword">val</span> service: java.nio.file.WatchService = myDir.newWatchService</div><div class="line">myDir.register(service, events = Seq(EventType.ENTRY_CREATE, EventType.ENTRY_DELETE))</div></pre></td></tr></table></figure>

<p><code>better-files</code>抽象了一个简单的接口：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> watcher = <span class="keyword">new</span> ThreadBackedFileMonitor(myDir, recursive = <span class="keyword">true</span>) {</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> onCreate(file: File) = println(s<span class="string">"$file got created"</span>)</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> onModify(file: File) = println(s<span class="string">"$file got modified"</span>)</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> onDelete(file: File) = println(s<span class="string">"$file got deleted"</span>)</div><div class="line">}</div><div class="line">watcher.start()</div></pre></td></tr></table></figure>

<p>或者用下面的写法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.nio.file.{Path, StandardWatchEventKinds =&gt; EventType, WatchEvent}</div><div class="line"></div><div class="line"><span class="keyword">val</span> watcher = <span class="keyword">new</span> ThreadBackedFileMonitor(myDir, recursive = <span class="keyword">true</span>) {</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> dispatch(eventType: WatchEvent.Kind[Path], file: File) = eventType <span class="keyword">match</span> {</div><div class="line">    <span class="keyword">case</span> EventType.ENTRY_CREATE =&gt; println(s<span class="string">"$file got created"</span>)</div><div class="line">    <span class="keyword">case</span> EventType.ENTRY_MODIFY =&gt; println(s<span class="string">"$file got modified"</span>)</div><div class="line">    <span class="keyword">case</span> EventType.ENTRY_DELETE =&gt; println(s<span class="string">"$file got deleted"</span>)</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Akka_风格的文件监控">Akka 风格的文件监控</h3>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> akka.actor.{ActorRef, ActorSystem}</div><div class="line"><span class="keyword">import</span> better.files._, FileWatcher._</div><div class="line"></div><div class="line">implicit <span class="keyword">val</span> system = ActorSystem(<span class="string">"mySystem"</span>)</div><div class="line"></div><div class="line"><span class="keyword">val</span> watcher: ActorRef = (home/<span class="string">"Downloads"</span>).newWatcher(recursive = <span class="keyword">true</span>)</div><div class="line"></div><div class="line"><span class="comment">// register partial function for an event</span></div><div class="line">watcher ! on(EventType.ENTRY_DELETE) {    </div><div class="line">  <span class="keyword">case</span> file <span class="keyword">if</span> file.isDirectory =&gt; println(s<span class="string">"$file got deleted"</span>) </div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// watch for multiple events</span></div><div class="line">watcher ! when(events = EventType.ENTRY_CREATE, EventType.ENTRY_MODIFY) {   </div><div class="line">  <span class="keyword">case</span> (EventType.ENTRY_CREATE, file) =&gt; println(s<span class="string">"$file got created"</span>)</div><div class="line">  <span class="keyword">case</span> (EventType.ENTRY_MODIFY, file) =&gt; println(s<span class="string">"$file got modified"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>对于使用Scala的程序员来说， I/O操作如文件的读写通常使用<a href="http://www.scala-lang.org/api/current/#scala.io.Source$" target="_blank" rel="external">scala.io.Source</a>来实现。但是这个类功能还是欠缺的，而且功能混乱，因此在Scala类库的增强提案(<a href="https://github.com/scala/slip/issues/19" target="_blank" rel="external">Scala IO fix-up/overhaul</a>)中如何改进它争论相当的大，甚至有些开发者提议将这个库废掉，让社区实现的第三方来完成这方面的工作，或者引导开发者使用<code>java.nio</code>来实现I/O操作。</p>
<p>当然，作为一个使用Scala的公司来说，可能会自己实现了辅助的I/O操作的方法， 比如类似FileUtils等名称的一些类。Java程序员可能已经熟悉了使用<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html" target="_blank" rel="external">java.nio.file.Files</a>、<a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/io/Files.html" target="_blank" rel="external">Guava</a>、<a href="https://commons.apache.org/proper/commons-io/" target="_blank" rel="external">Apache common-io</a>、<a href="http://jodd.org/api/jodd/io/FileUtil.html" target="_blank" rel="external">jodd FileUtil</a>等开源I/O库，但是如果使用Scala进行I/O操作时，虽然还是可以使用这些Java I/O库,但是毕竟还是不是那么纯粹，因此，我们可以关注一下Scala实现的I/O库，比如<a href="https://github.com/sbt/io" target="_blank" rel="external">sbt io</a>、<a href="http://www.lihaoyi.com/Ammonite/#Ammonite-Ops" target="_blank" rel="external">Ammonite-Ops</a>、<a href="https://github.com/pathikrit/better-files" target="_blank" rel="external">better-files</a>等。</p>
<p>本文为你推荐<a href="https://github.com/pathikrit/better-files" target="_blank" rel="external">better-files</a>。</p>
]]>
    
    </summary>
    
      <category term="Scala" scheme="http://colobu.com/tags/Scala/"/>
    
      <category term="Scala" scheme="http://colobu.com/categories/Scala/"/>
    
  </entry>
  
</feed>
